{"ast":null,"code":"import { web3 } from '@coral-xyz/anchor';\nimport { PublicKey, Transaction, Keypair, SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport idlFile from '../idl/moon_wallet_program.json';\n\n// Export programID từ biến môi trường thay vì hardcode\nexport const programID = new PublicKey(process.env.REACT_APP_PROGRAM_ID || 'DeN1rBfabZezHPvrq9q7BbzUbZkrjnHE1kQDrPK8kWQ3');\n\n// Hằng số cho chương trình secp256r1\nexport const SECP256R1_PROGRAM_ID = new PublicKey('Secp256r1SigVerify1111111111111111111111111');\n\n// Hằng số cho Sysvar accounts với địa chỉ chính xác\nexport const SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');\nexport const SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');\n\n// Sửa lỗi type cho IDL\nconst idl = idlFile;\n\n// Cập nhật: Chương trình secp256r1 là một chương trình native của Solana, \n// nên không thể kiểm tra bằng getAccountInfo\nexport const checkSecp256r1Program = async () => {\n  // Chương trình native luôn tồn tại trên validator chính thức\n  // Chỉ cần đảm bảo validator được khởi động với tham số phù hợp\n  return true;\n};\n\n// Thêm hàm kiểm tra chương trình secp256r1 thông qua transaction thử nghiệm nếu cần\nexport const testSecp256r1Instruction = async connection => {\n  try {\n    // Tạo một cặp khóa giả lập cho việc kiểm tra\n    const testKeyPair = web3.Keypair.generate();\n\n    // Tạo một chữ ký và message giả\n    const testSignature = Buffer.alloc(64, 1); // Chữ ký giả 64 bytes\n    const testPubkey = Buffer.alloc(33, 2); // Khóa công khai giả 33 bytes\n    testPubkey[0] = 0x02; // Định dạng khóa nén\n    const testMessage = Buffer.alloc(32, 3); // Message hash giả 32 bytes\n\n    // Tạo instruction secp256r1 giả\n    const testInstruction = createSecp256r1Instruction(testPubkey, testSignature, testMessage);\n\n    // Tạo transaction giả với instruction trên\n    const testTx = new web3.Transaction().add(testInstruction);\n    testTx.feePayer = testKeyPair.publicKey;\n    const {\n      blockhash\n    } = await connection.getLatestBlockhash();\n    testTx.recentBlockhash = blockhash;\n\n    // Chỉ mô phỏng giao dịch, không gửi thật\n    await connection.simulateTransaction(testTx);\n\n    // Nếu không có lỗi \"program not found\", chương trình tồn tại\n    return true;\n  } catch (error) {\n    // Kiểm tra lỗi cụ thể\n    const errorMessage = error.toString();\n    // Nếu lỗi là về chương trình không tồn tại\n    if (errorMessage.includes(\"Attempt to load a program that does not exist\") || errorMessage.includes(\"Program not found\")) {\n      console.error(\"Chương trình secp256r1 không tồn tại:\", error);\n      return false;\n    }\n\n    // Nếu là lỗi khác (vd: chữ ký không hợp lệ), chương trình vẫn tồn tại\n    console.warn(\"Lỗi khi kiểm tra secp256r1, nhưng chương trình có thể tồn tại:\", error);\n    return true;\n  }\n};\n\n// Cập nhật lại hàm tạo transaction\nexport const createInitializeMultisigTx = async (threshold, multisigPDA, owner, feePayer, recoveryHash, credentialId) => {\n  try {\n    const ownerPubkey = owner instanceof Keypair ? owner.publicKey : owner;\n\n    // Sử dụng discriminator chính xác từ IDL\n    const discriminator = Buffer.from([220, 130, 117, 21, 27, 227, 78, 213]);\n\n    // Đảm bảo recoveryHash có đúng 32 bytes\n    if (recoveryHash.length !== 32) {\n      throw new Error(\"Recovery hash phải đúng 32 bytes\");\n    }\n    const thresholdBuffer = Buffer.from([threshold]);\n    const recoveryHashBuffer = Buffer.from(recoveryHash);\n\n    // Tạo buffer cho độ dài credential ID\n    const credentialIdLenBuffer = Buffer.alloc(4);\n    credentialIdLenBuffer.writeUInt32LE(credentialId.length, 0);\n\n    // Nối tất cả lại với nhau\n    const data = Buffer.concat([new Uint8Array(discriminator), new Uint8Array(thresholdBuffer), new Uint8Array(recoveryHashBuffer), new Uint8Array(credentialIdLenBuffer), new Uint8Array(credentialId)]);\n\n    // Tạo transaction instruction\n    const instruction = new TransactionInstruction({\n      keys: [{\n        pubkey: multisigPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: feePayer.publicKey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: programID,\n      data\n    });\n    const tx = new Transaction().add(instruction);\n    return tx;\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction initialize multisig:\", error);\n    throw error;\n  }\n};\n\n// Thêm hàm compressPublicKey cho việc nén khóa công khai\nfunction compressPublicKey(uncompressedKey) {\n  // Đảm bảo khóa bắt đầu với byte 0x04 (không nén)\n  if (uncompressedKey[0] !== 0x04 || uncompressedKey.length !== 65) {\n    throw new Error('Khóa không đúng định dạng không nén ECDSA');\n  }\n\n  // Sử dụng Uint8Array để tránh lỗi type\n  const x = Buffer.from(uncompressedKey.subarray(1, 33));\n  const y = Buffer.from(uncompressedKey.subarray(33, 65));\n\n  // Tính prefix: 0x02 nếu y chẵn, 0x03 nếu y lẻ\n  const prefix = (y[31] & 1) === 0 ? 0x02 : 0x03;\n\n  // Tạo khóa nén: prefix (1 byte) + x (32 bytes)\n  const compressedKey = Buffer.alloc(33);\n  compressedKey[0] = prefix;\n  new Uint8Array(compressedKey).set(new Uint8Array(x), 1);\n  return compressedKey;\n}\n\n// Cập nhật hàm configure_webauthn với discriminator chính xác từ IDL\nexport const createConfigureWebAuthnTx = async (webauthnPubkey, multisigPDA, owner) => {\n  try {\n    // Lấy từ IDL: discriminator chính xác cho hàm configure_webauthn\n    const discriminator = Buffer.from([40, 149, 116, 224, 148, 48, 159, 54]);\n\n    // Nén khóa công khai từ 65 bytes xuống 33 bytes\n    let compressedKey;\n    if (webauthnPubkey.length === 65 && webauthnPubkey[0] === 0x04) {\n      // Khóa không nén, cần nén lại\n      compressedKey = compressPublicKey(webauthnPubkey);\n      console.log(\"Đã nén khóa từ 65 bytes xuống 33 bytes\");\n    } else if (webauthnPubkey.length === 33 && (webauthnPubkey[0] === 0x02 || webauthnPubkey[0] === 0x03)) {\n      // Khóa đã nén, sử dụng trực tiếp\n      compressedKey = webauthnPubkey;\n      console.log(\"Khóa đã ở định dạng nén (33 bytes)\");\n    } else {\n      console.warn(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPubkey.length} bytes`);\n      // Nếu không thể xử lý, tạo khóa giả\n      compressedKey = Buffer.alloc(33);\n      compressedKey[0] = 0x02; // Prefix cho khóa nén\n      if (webauthnPubkey.length > 0) {\n        // Sao chép dữ liệu nếu có\n        new Uint8Array(compressedKey).set(new Uint8Array(webauthnPubkey.subarray(0, Math.min(webauthnPubkey.length, 32))), 1);\n      }\n    }\n    console.log(\"Khóa công khai WebAuthn (nén):\", compressedKey.toString('hex'));\n    console.log(\"Độ dài khóa (bytes):\", compressedKey.length);\n\n    // Tạo dữ liệu instruction\n    const data = Buffer.concat([new Uint8Array(discriminator), new Uint8Array(compressedKey)]);\n\n    // Tạo instruction với đúng accounts theo IDL\n    const instruction = new TransactionInstruction({\n      keys: [{\n        pubkey: multisigPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: programID,\n      data\n    });\n    const tx = new Transaction().add(instruction);\n    return tx;\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction configure webauthn:\", error);\n    throw error;\n  }\n};\n\n/**\n * Tạo transaction cho storePasswordHash\n */\nexport const createStorePasswordHashTx = async (passwordHash, multisigPDA, ownerPubkey) => {\n  const tx = new web3.Transaction();\n\n  // Sửa lỗi Buffer.from\n  const discriminator = Buffer.from([\n  // Thay thế với giá trị discriminator thực tế\n  125, 106, 39, 42, 99, 108, 43, 50]);\n\n  // Sửa lại cách tạo data buffer\n  const data = Buffer.concat([new Uint8Array(discriminator), new Uint8Array(Buffer.from(Array.from(passwordHash)))]);\n\n  // Thêm instruction để lưu password hash\n  tx.add(new web3.TransactionInstruction({\n    keys: [{\n      pubkey: multisigPDA,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: ownerPubkey,\n      isSigner: true,\n      isWritable: false\n    }],\n    programId: programID,\n    data: data\n  }));\n  return tx;\n};\n\n/**\n * Tạo transaction xác thực WebAuthn\n */\nexport const createWebAuthnAuthTx = async (multisigPDA, ownerPubkey, webauthnSignature, authenticatorData, clientDataJSON) => {\n  const tx = new web3.Transaction();\n\n  // Thêm discriminator đúng cho verify_webauthn_auth\n  const instructionData = Buffer.concat([new Uint8Array(Buffer.from([234, 182, 165, 23, 186, 223, 208, 119])),\n  // discriminator từ IDL\n  new Uint8Array(Buffer.from(webauthnSignature)), new Uint8Array(Buffer.from(authenticatorData)), new Uint8Array(Buffer.from(clientDataJSON))]);\n  const instruction = new web3.TransactionInstruction({\n    keys: [{\n      pubkey: multisigPDA,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: ownerPubkey,\n      isSigner: false,\n      isWritable: false\n    }],\n    programId: programID,\n    data: instructionData\n  });\n  tx.add(instruction);\n  return tx;\n};\n\n// Tạo hàm mới createAddGuardianTx\nexport const createAddGuardianTx = (multisigPDA, guardianPDA, guardianPubkey, guardianName, recoveryHash, isOwner, webauthnPubkey) => {\n  try {\n    // Discriminator cho add_guardian\n    const discriminator = Buffer.from([167, 189, 170, 27, 74, 240, 201, 241]);\n\n    // Tạo buffer cho tên guardian\n    const nameBuffer = Buffer.from(guardianName);\n    const nameLenBuffer = Buffer.alloc(4);\n    nameLenBuffer.writeUInt32LE(nameBuffer.length, 0);\n\n    // Tạo buffer cho các tham số\n    const isOwnerByte = Buffer.from([isOwner ? 1 : 0]);\n\n    // Tạo buffers cho instruction data\n    const dataBuffers = [discriminator, guardianPubkey.toBuffer(), nameLenBuffer, nameBuffer, Buffer.from(recoveryHash)];\n\n    // Thêm isOwner\n    dataBuffers.push(isOwnerByte);\n\n    // Xử lý webauthn_pubkey (option)\n    if (webauthnPubkey && isOwner) {\n      // Some variant (1)\n      dataBuffers.push(Buffer.from([1]));\n\n      // Nén khóa công khai nếu cần\n      let compressedKey;\n      if (webauthnPubkey.length === 65 && webauthnPubkey[0] === 0x04) {\n        // Khóa không nén, cần nén lại\n        compressedKey = compressPublicKey(webauthnPubkey);\n      } else if (webauthnPubkey.length === 33 && (webauthnPubkey[0] === 0x02 || webauthnPubkey[0] === 0x03)) {\n        // Khóa đã nén, sử dụng trực tiếp\n        compressedKey = webauthnPubkey;\n      } else {\n        throw new Error(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPubkey.length} bytes`);\n      }\n      dataBuffers.push(compressedKey);\n    } else {\n      // None variant (0)\n      dataBuffers.push(Buffer.from([0]));\n    }\n\n    // Nối tất cả buffer lại với nhau\n    const data = Buffer.concat(dataBuffers.map(buffer => new Uint8Array(buffer)));\n\n    // Tạo instruction\n    const instruction = new TransactionInstruction({\n      keys: [{\n        pubkey: multisigPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: guardianPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: guardianPubkey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: programID,\n      data\n    });\n    return new Transaction().add(instruction);\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction add guardian:\", error);\n    throw error;\n  }\n};\n\n// Thêm các hằng số cho curve secp256r1\n// Order của curve secp256r1\nconst SECP256R1_ORDER = new Uint8Array([0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51]);\n\n// Nửa order của curve secp256r1\nconst SECP256R1_HALF_ORDER = new Uint8Array([0x7f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xde, 0x73, 0x7d, 0x56, 0xd3, 0x8b, 0xcf, 0x42, 0x79, 0xdc, 0xe5, 0x61, 0x7e, 0x31, 0x92, 0xa8]);\n\n// Thêm hàm so sánh số lớn\nfunction isGreaterThan(a, b) {\n  const aBuf = Buffer.isBuffer(a) ? a : Buffer.from(a);\n  if (aBuf.length !== b.length) {\n    return aBuf.length > b.length;\n  }\n  for (let i = 0; i < aBuf.length; i++) {\n    if (aBuf[i] !== b[i]) {\n      return aBuf[i] > b[i];\n    }\n  }\n  return false;\n}\n\n// Sửa lại hàm subtractBigNumbers để xử lý big-endian đúng cách\nfunction subtractBigNumbers(a, b) {\n  const bBuf = Buffer.isBuffer(b) ? b : Buffer.from(b);\n  const result = new Uint8Array(a.length);\n  let borrow = 0;\n\n  // Đảm bảo cả a và b đều có đúng 32 bytes\n  if (a.length !== 32 || bBuf.length !== 32) {\n    console.error(`Độ dài không đúng: a=${a.length}, b=${bBuf.length}, phải là 32 bytes`);\n  }\n\n  // Tính từ byte ít quan trọng nhất đến quan trọng nhất (big endian)\n  for (let i = a.length - 1; i >= 0; i--) {\n    let diff = a[i] - bBuf[i] - borrow;\n    if (diff < 0) {\n      diff += 256;\n      borrow = 1;\n    } else {\n      borrow = 0;\n    }\n    result[i] = diff;\n  }\n\n  // Log giá trị input và output để debug\n  console.log('Input a (hex):', Buffer.from(a).toString('hex'));\n  console.log('Input b (hex):', Buffer.from(bBuf).toString('hex'));\n  console.log('Result (hex):', Buffer.from(result).toString('hex'));\n  return result;\n}\n\n// Sửa hàm createSecp256r1Instruction phần đóng gói dữ liệu\nexport const createSecp256r1Instruction = (publicKey, signature, message) => {\n  try {\n    console.log('Tạo secp256r1 instruction với:');\n    console.log('- Public key length:', publicKey.length);\n    console.log('- Signature length:', signature.length);\n    console.log('- Message length:', message.length);\n    if (!publicKey || !signature || !message) {\n      throw new Error('Public key, signature, hoặc message không được để trống');\n    }\n    if (publicKey.length !== 33) {\n      throw new Error(`Public key phải có độ dài 33 bytes (dạng nén), nhận được ${publicKey.length} bytes`);\n    }\n    if (signature.length !== 64) {\n      throw new Error(`Signature phải có độ dài 64 bytes, nhận được ${signature.length} bytes`);\n    }\n    if (message.length !== 32) {\n      throw new Error(`Message phải có độ dài 32 bytes, nhận được ${message.length} bytes`);\n    }\n\n    // Chuẩn hóa chữ ký theo chuẩn ECDSA\n    // Chia signature thành r và s\n    const r = signature.slice(0, 32);\n    const s = signature.slice(32, 64);\n    console.log('Signature components:');\n    console.log('- r (hex):', r.toString('hex'));\n    console.log('- s (hex):', s.toString('hex'));\n\n    // Kiểm tra và chuẩn hóa giá trị s nếu cần\n    if (isGreaterThan(s, SECP256R1_HALF_ORDER)) {\n      console.log('Chuẩn hóa signature: s > HALF_ORDER, thực hiện s = ORDER - s');\n      const newS = subtractBigNumbers(SECP256R1_ORDER, s);\n\n      // Đảm bảo newS đúng độ dài 32 bytes\n      const newSBuf = Buffer.from(newS);\n      if (newSBuf.length !== 32) {\n        console.error(`newS có độ dài ${newSBuf.length}, không phải 32 bytes!`);\n      }\n\n      // Tạo signature mới với r giữ nguyên và s chuẩn hóa\n      signature = Buffer.concat([r, Buffer.from(newS)]);\n      console.log('Signature sau khi chuẩn hóa (hex):', signature.toString('hex'));\n      console.log('Độ dài signature sau khi chuẩn hóa:', signature.length);\n    } else {\n      console.log('Signature đã chuẩn hóa, không cần thay đổi');\n    }\n\n    // Cấu trúc hóa dữ liệu cho instruction theo đúng quy trình\n    const numSignatures = 1;\n    const instructionData = Buffer.alloc(2 + 14 + signature.length + publicKey.length + message.length);\n\n    // Số lượng signatures (2 bytes)\n    instructionData.writeUInt8(numSignatures, 0);\n    instructionData.writeUInt8(0, 1); // padding\n\n    // Offset và index cho signature, pubkey và message\n    const sigOffset = 2 + 14; // 2 bytes header + 14 bytes offsets\n    const pubkeyOffset = sigOffset + signature.length;\n    const messageOffset = pubkeyOffset + publicKey.length;\n\n    // Viết các offset và index (14 bytes total)\n    instructionData.writeUInt16LE(sigOffset, 2); // signature_offset (2 bytes)\n    instructionData.writeUInt16LE(0, 4); // signature_instruction_index (2 bytes) - current instruction\n    instructionData.writeUInt16LE(pubkeyOffset, 6); // public_key_offset (2 bytes)\n    instructionData.writeUInt16LE(0, 8); // public_key_instruction_index (2 bytes) - current instruction\n    instructionData.writeUInt16LE(messageOffset, 10); // message_offset (2 bytes)\n    instructionData.writeUInt16LE(message.length, 12); // message_size (2 bytes)\n    instructionData.writeUInt16LE(0, 14); // message_instruction_index (2 bytes) - current instruction\n\n    // Copy dữ liệu vào các vị trí tương ứng\n    signature.copy(instructionData, sigOffset); // copy signature\n    publicKey.copy(instructionData, pubkeyOffset); // copy public key\n    message.copy(instructionData, messageOffset); // copy message\n\n    console.log('Secp256r1 instruction data:', {\n      totalSize: instructionData.length,\n      signatureOffset: sigOffset,\n      publicKeyOffset: pubkeyOffset,\n      messageOffset: messageOffset,\n      headerHex: instructionData.slice(0, 16).toString('hex')\n    });\n\n    // Tạo instruction\n    return new web3.TransactionInstruction({\n      keys: [],\n      programId: SECP256R1_PROGRAM_ID,\n      data: instructionData\n    });\n  } catch (error) {\n    console.error('❌ Lỗi khi tạo secp256r1 instruction:', error);\n    throw error;\n  }\n};\n\n/**\n * Kiểm tra xem chữ ký secp256r1 có hợp lệ không bằng cách mô phỏng transaction\n * @param connection Kết nối đến Solana cluster\n * @param publicKey Khóa công khai (dạng nén) dùng để xác minh\n * @param signature Chữ ký (raw format, 64 bytes) cần xác minh\n * @param message Message đã hash (32 bytes) đã được ký\n * @returns Promise<{isValid: boolean, error?: string}> Kết quả kiểm tra và lỗi nếu có\n */\nexport const testSecp256r1Signature = async (connection, publicKey, signature, message) => {\n  try {\n    // Tạo instruction secp256r1 để kiểm tra\n    const testInstruction = createSecp256r1Instruction(publicKey, signature, message);\n\n    // Tạo một feePayer giả lập để dùng cho transaction test\n    const feePayer = web3.Keypair.generate();\n    console.log('Kiểm tra chữ ký secp256r1 với transaction riêng biệt...');\n    console.log('Tạo instruction secp256r1 thành công:', {\n      publicKeyLength: publicKey.length,\n      signatureLength: signature.length,\n      messageLength: message.length\n    });\n\n    // Tiến hành airdrop SOL cho feePayer trước khi mô phỏng\n    try {\n      const airdropSignature = await connection.requestAirdrop(feePayer.publicKey, web3.LAMPORTS_PER_SOL / 100 // Chỉ cần một lượng nhỏ SOL\n      );\n\n      // Đợi xác nhận airdrop\n      await connection.confirmTransaction(airdropSignature);\n      console.log('Đã airdrop SOL cho fee payer để mô phỏng');\n\n      // Xác nhận số dư\n      const balance = await connection.getBalance(feePayer.publicKey);\n      console.log(`Số dư feePayer: ${balance / web3.LAMPORTS_PER_SOL} SOL`);\n      if (balance === 0) {\n        throw new Error('Không thể airdrop SOL');\n      }\n    } catch (airdropError) {\n      console.warn('Lỗi khi airdrop SOL:', airdropError);\n      console.log('Tiếp tục mô phỏng mà không có airdrop...');\n      // Không return ở đây, vẫn tiếp tục mô phỏng\n    }\n\n    // Tạo transaction riêng chỉ với instruction secp256r1\n    const testTx = new web3.Transaction().add(testInstruction);\n    testTx.feePayer = feePayer.publicKey;\n\n    // Thiết lập blockhash cho transaction\n    const {\n      blockhash\n    } = await connection.getLatestBlockhash();\n    testTx.recentBlockhash = blockhash;\n\n    // Ký transaction bằng feePayer\n    testTx.sign(feePayer);\n    try {\n      // Mô phỏng transaction để kiểm tra (không gửi lên blockchain)\n      const simulationResult = await connection.simulateTransaction(testTx);\n\n      // Kiểm tra kết quả mô phỏng\n      if (simulationResult.value.err) {\n        // Có lỗi, kiểm tra xem có phải lỗi chữ ký không\n        const errorString = JSON.stringify(simulationResult.value.err);\n        console.error('Lỗi khi mô phỏng chữ ký secp256r1:', errorString);\n\n        // Nếu lỗi chứa các string liên quan đến chữ ký không hợp lệ\n        if (errorString.includes('signature') && (errorString.includes('invalid') || errorString.includes('verification failed'))) {\n          return {\n            isValid: false,\n            error: 'Chữ ký không hợp lệ: ' + errorString\n          };\n        }\n\n        // Có lỗi khác không liên quan đến chữ ký\n        return {\n          isValid: false,\n          error: 'Lỗi khi mô phỏng transaction: ' + errorString\n        };\n      }\n\n      // Không có lỗi, chữ ký hợp lệ\n      console.log('Kiểm tra chữ ký secp256r1 thành công!');\n      return {\n        isValid: true\n      };\n    } catch (simError) {\n      // Xử lý lỗi mô phỏng\n      console.error('Lỗi khi mô phỏng transaction:', simError);\n\n      // Kiểm tra nếu lỗi là AccountNotFound\n      if (simError.toString().includes('AccountNotFound')) {\n        console.log('Lỗi AccountNotFound: Đây là lỗi mô phỏng, không phải lỗi chữ ký');\n        console.log('Tiếp tục với giả định chữ ký hợp lệ...');\n\n        // Trả về kết quả giả định chữ ký hợp lệ, nhưng có ghi chú về lỗi\n        return {\n          isValid: true,\n          error: 'Không thể xác minh hoàn toàn do lỗi AccountNotFound trong mô phỏng'\n        };\n      }\n\n      // Các lỗi khác\n      return {\n        isValid: false,\n        error: simError.toString()\n      };\n    }\n  } catch (error) {\n    console.error('Lỗi khi kiểm tra chữ ký secp256r1:', error);\n    return {\n      isValid: false,\n      error: error.toString()\n    };\n  }\n};\n\n/**\n * Tạo transaction để chuyển tiền\n * @param multisigPDA PDA của ví multisig\n * @param guardianPDA PDA của guardian\n * @param destination Địa chỉ đích để chuyển token\n * @param amountLamports Số lượng lamports để chuyển\n * @param nonce Nonce tránh replay attack\n * @param timestamp Timestamp cho giao dịch\n * @param message Thông điệp gốc (chưa hash)\n * @param payer Người trả phí giao dịch\n */\nexport const createTransferTx = (multisigPDA, guardianPDA, destination, amountLamports, nonce, timestamp, message, payer) => {\n  try {\n    // Kiểm tra các input\n    if (!(multisigPDA instanceof PublicKey)) {\n      throw new Error(`multisigPDA không phải PublicKey: ${typeof multisigPDA}`);\n    }\n    if (!(guardianPDA instanceof PublicKey)) {\n      throw new Error(`guardianPDA không phải PublicKey: ${typeof guardianPDA}`);\n    }\n    if (!(destination instanceof PublicKey)) {\n      throw new Error(`destination không phải PublicKey: ${typeof destination}`);\n    }\n    if (!(payer instanceof PublicKey)) {\n      throw new Error(`payer không phải PublicKey: ${typeof payer}`);\n    }\n\n    // Đảm bảo các giá trị số hợp lệ\n    if (isNaN(amountLamports) || amountLamports <= 0) {\n      throw new Error(`amountLamports không hợp lệ: ${amountLamports}`);\n    }\n    if (isNaN(nonce) || nonce < 0) {\n      throw new Error(`nonce không hợp lệ: ${nonce}`);\n    }\n    if (isNaN(timestamp) || timestamp <= 0) {\n      throw new Error(`timestamp không hợp lệ: ${timestamp}`);\n    }\n\n    // Log thông tin debug để kiểm tra\n    console.log('Tạo transaction chuyển tiền với thông tin:');\n    console.log('- multisigPDA:', multisigPDA.toString());\n    console.log('- guardianPDA:', guardianPDA.toString());\n    console.log('- destination:', destination.toString());\n    console.log('- amountLamports:', amountLamports);\n    console.log('- nonce:', nonce);\n    console.log('- timestamp:', timestamp);\n    console.log('- message length:', message.length);\n    console.log('- payer:', payer.toString());\n\n    // Discriminator cho verify_and_execute\n    const discriminator = Buffer.from([80, 118, 102, 72, 125, 57, 218, 137]);\n\n    // Tham số cho 'action' - chuỗi \"transfer\"\n    const action = \"transfer\";\n    const actionBuffer = Buffer.from(action);\n    const actionLenBuffer = Buffer.alloc(4);\n    actionLenBuffer.writeUInt32LE(actionBuffer.length, 0);\n\n    // Encode ActionParams\n    const amountBuffer = Buffer.alloc(9); // 1 byte cho Option + 8 bytes cho u64\n    amountBuffer.writeUInt8(1, 0); // 1 = Some\n    const amountBigInt = BigInt(amountLamports);\n    for (let i = 0; i < 8; i++) {\n      amountBuffer.writeUInt8(Number(amountBigInt >> BigInt(8 * i) & BigInt(0xFF)), i + 1);\n    }\n\n    // Encode destination\n    const destinationBuffer = Buffer.alloc(33); // 1 byte cho Option + 32 bytes cho PublicKey\n    destinationBuffer.writeUInt8(1, 0); // 1 = Some\n    Buffer.from(destination.toBuffer()).copy(destinationBuffer, 1);\n\n    // Encode token_mint (None)\n    const tokenMintBuffer = Buffer.alloc(1);\n    tokenMintBuffer.writeUInt8(0, 0); // 0 = None\n\n    // Encode nonce (u64, little-endian)\n    const nonceBuffer = Buffer.alloc(8);\n    const nonceBigInt = BigInt(nonce);\n    for (let i = 0; i < 8; i++) {\n      nonceBuffer.writeUInt8(Number(nonceBigInt >> BigInt(8 * i) & BigInt(0xFF)), i);\n    }\n\n    // Encode timestamp (i64, little-endian)\n    const timestampBuffer = Buffer.alloc(8);\n    const timestampBigInt = BigInt(timestamp);\n    for (let i = 0; i < 8; i++) {\n      timestampBuffer.writeUInt8(Number(timestampBigInt >> BigInt(8 * i) & BigInt(0xFF)), i);\n    }\n\n    // Encode message (vec<u8>)\n    const messageLenBuffer = Buffer.alloc(4);\n    messageLenBuffer.writeUInt32LE(message.length, 0);\n    const messageBuffer = Buffer.from(message);\n\n    // Nối tất cả buffer lại với nhau\n    const data = Buffer.concat([discriminator, actionLenBuffer, actionBuffer, amountBuffer, destinationBuffer, tokenMintBuffer, nonceBuffer, timestampBuffer, messageLenBuffer, messageBuffer]);\n\n    // Kiểm tra địa chỉ của instruction sysvar\n    const sysvarInstructionPubkey = SYSVAR_INSTRUCTIONS_PUBKEY;\n    const sysvarClockPubkey = SYSVAR_CLOCK_PUBKEY;\n\n    // Tạo instruction verify_and_execute\n    const ix = new TransactionInstruction({\n      keys: [{\n        pubkey: multisigPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: guardianPDA,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: sysvarClockPubkey,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: sysvarInstructionPubkey,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: payer,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: destination,\n        isSigner: false,\n        isWritable: true\n      }],\n      programId: programID,\n      data\n    });\n\n    // Tạo transaction mới\n    return new Transaction().add(ix);\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction chuyển tiền:\", error);\n    throw error;\n  }\n};","map":{"version":3,"names":["web3","PublicKey","Transaction","Keypair","SystemProgram","TransactionInstruction","Buffer","idlFile","programID","process","env","REACT_APP_PROGRAM_ID","SECP256R1_PROGRAM_ID","SYSVAR_INSTRUCTIONS_PUBKEY","SYSVAR_CLOCK_PUBKEY","idl","checkSecp256r1Program","testSecp256r1Instruction","connection","testKeyPair","generate","testSignature","alloc","testPubkey","testMessage","testInstruction","createSecp256r1Instruction","testTx","add","feePayer","publicKey","blockhash","getLatestBlockhash","recentBlockhash","simulateTransaction","error","errorMessage","toString","includes","console","warn","createInitializeMultisigTx","threshold","multisigPDA","owner","recoveryHash","credentialId","ownerPubkey","discriminator","from","length","Error","thresholdBuffer","recoveryHashBuffer","credentialIdLenBuffer","writeUInt32LE","data","concat","Uint8Array","instruction","keys","pubkey","isSigner","isWritable","programId","tx","compressPublicKey","uncompressedKey","x","subarray","y","prefix","compressedKey","set","createConfigureWebAuthnTx","webauthnPubkey","log","Math","min","createStorePasswordHashTx","passwordHash","Array","createWebAuthnAuthTx","webauthnSignature","authenticatorData","clientDataJSON","instructionData","createAddGuardianTx","guardianPDA","guardianPubkey","guardianName","isOwner","nameBuffer","nameLenBuffer","isOwnerByte","dataBuffers","toBuffer","push","map","buffer","SECP256R1_ORDER","SECP256R1_HALF_ORDER","isGreaterThan","a","b","aBuf","isBuffer","i","subtractBigNumbers","bBuf","result","borrow","diff","signature","message","r","slice","s","newS","newSBuf","numSignatures","writeUInt8","sigOffset","pubkeyOffset","messageOffset","writeUInt16LE","copy","totalSize","signatureOffset","publicKeyOffset","headerHex","testSecp256r1Signature","publicKeyLength","signatureLength","messageLength","airdropSignature","requestAirdrop","LAMPORTS_PER_SOL","confirmTransaction","balance","getBalance","airdropError","sign","simulationResult","value","err","errorString","JSON","stringify","isValid","simError","createTransferTx","destination","amountLamports","nonce","timestamp","payer","isNaN","action","actionBuffer","actionLenBuffer","amountBuffer","amountBigInt","BigInt","Number","destinationBuffer","tokenMintBuffer","nonceBuffer","nonceBigInt","timestampBuffer","timestampBigInt","messageLenBuffer","messageBuffer","sysvarInstructionPubkey","sysvarClockPubkey","ix"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/frontend_test/src/utils/transactionUtils.ts"],"sourcesContent":["import { web3, BN } from '@coral-xyz/anchor';\nimport { PublicKey, Transaction, Keypair, SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport idlFile from '../idl/moon_wallet_program.json';\n\n// Export programID từ biến môi trường thay vì hardcode\nexport const programID = new PublicKey(process.env.REACT_APP_PROGRAM_ID || 'DeN1rBfabZezHPvrq9q7BbzUbZkrjnHE1kQDrPK8kWQ3');\n\n// Hằng số cho chương trình secp256r1\nexport const SECP256R1_PROGRAM_ID = new PublicKey('Secp256r1SigVerify1111111111111111111111111');\n\n// Hằng số cho Sysvar accounts với địa chỉ chính xác\nexport const SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');\nexport const SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');\n\n// Sửa lỗi type cho IDL\nconst idl: any = idlFile;\n\n// Cập nhật: Chương trình secp256r1 là một chương trình native của Solana, \n// nên không thể kiểm tra bằng getAccountInfo\nexport const checkSecp256r1Program = async (): Promise<boolean> => {\n  // Chương trình native luôn tồn tại trên validator chính thức\n  // Chỉ cần đảm bảo validator được khởi động với tham số phù hợp\n  return true;\n};\n\n// Thêm hàm kiểm tra chương trình secp256r1 thông qua transaction thử nghiệm nếu cần\nexport const testSecp256r1Instruction = async (connection: web3.Connection): Promise<boolean> => {\n  try {\n    // Tạo một cặp khóa giả lập cho việc kiểm tra\n    const testKeyPair = web3.Keypair.generate();\n    \n    // Tạo một chữ ký và message giả\n    const testSignature = Buffer.alloc(64, 1); // Chữ ký giả 64 bytes\n    const testPubkey = Buffer.alloc(33, 2); // Khóa công khai giả 33 bytes\n    testPubkey[0] = 0x02; // Định dạng khóa nén\n    const testMessage = Buffer.alloc(32, 3); // Message hash giả 32 bytes\n    \n    // Tạo instruction secp256r1 giả\n    const testInstruction = createSecp256r1Instruction(\n      testPubkey,\n      testSignature,\n      testMessage\n    );\n    \n    // Tạo transaction giả với instruction trên\n    const testTx = new web3.Transaction().add(testInstruction);\n    testTx.feePayer = testKeyPair.publicKey;\n    const { blockhash } = await connection.getLatestBlockhash();\n    testTx.recentBlockhash = blockhash;\n    \n    // Chỉ mô phỏng giao dịch, không gửi thật\n    await connection.simulateTransaction(testTx);\n    \n    // Nếu không có lỗi \"program not found\", chương trình tồn tại\n    return true;\n  } catch (error: any) {\n    // Kiểm tra lỗi cụ thể\n    const errorMessage = error.toString();\n    // Nếu lỗi là về chương trình không tồn tại\n    if (errorMessage.includes(\"Attempt to load a program that does not exist\") ||\n        errorMessage.includes(\"Program not found\")) {\n      console.error(\"Chương trình secp256r1 không tồn tại:\", error);\n      return false;\n    }\n    \n    // Nếu là lỗi khác (vd: chữ ký không hợp lệ), chương trình vẫn tồn tại\n    console.warn(\"Lỗi khi kiểm tra secp256r1, nhưng chương trình có thể tồn tại:\", error);\n    return true;\n  }\n};\n\n// Cập nhật lại hàm tạo transaction\nexport const createInitializeMultisigTx = async (\n  threshold: number,\n  multisigPDA: PublicKey,\n  owner: PublicKey | Keypair,\n  feePayer: Keypair,\n  recoveryHash: Uint8Array,\n  credentialId: Buffer\n): Promise<Transaction> => {\n  try {\n    const ownerPubkey = owner instanceof Keypair ? owner.publicKey : owner;\n    \n    // Sử dụng discriminator chính xác từ IDL\n    const discriminator = Buffer.from([\n      220, 130, 117, 21, 27, 227, 78, 213\n    ]);\n    \n    // Đảm bảo recoveryHash có đúng 32 bytes\n    if (recoveryHash.length !== 32) {\n      throw new Error(\"Recovery hash phải đúng 32 bytes\");\n    }\n    \n    const thresholdBuffer = Buffer.from([threshold]);\n    const recoveryHashBuffer = Buffer.from(recoveryHash);\n    \n    // Tạo buffer cho độ dài credential ID\n    const credentialIdLenBuffer = Buffer.alloc(4);\n    credentialIdLenBuffer.writeUInt32LE(credentialId.length, 0);\n    \n    // Nối tất cả lại với nhau\n    const data = Buffer.concat([\n      new Uint8Array(discriminator),\n      new Uint8Array(thresholdBuffer),\n      new Uint8Array(recoveryHashBuffer),\n      new Uint8Array(credentialIdLenBuffer),\n      new Uint8Array(credentialId)\n    ]);\n    \n    // Tạo transaction instruction\n    const instruction = new TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: feePayer.publicKey, isSigner: true, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n      ],\n      programId: programID,\n      data\n    });\n    \n    const tx = new Transaction().add(instruction);\n    return tx;\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction initialize multisig:\", error);\n    throw error;\n  }\n};\n\n// Thêm hàm compressPublicKey cho việc nén khóa công khai\nfunction compressPublicKey(uncompressedKey: Buffer): Buffer {\n  // Đảm bảo khóa bắt đầu với byte 0x04 (không nén)\n  if (uncompressedKey[0] !== 0x04 || uncompressedKey.length !== 65) {\n    throw new Error('Khóa không đúng định dạng không nén ECDSA');\n  }\n  \n  // Sử dụng Uint8Array để tránh lỗi type\n  const x = Buffer.from(uncompressedKey.subarray(1, 33));\n  const y = Buffer.from(uncompressedKey.subarray(33, 65));\n  \n  // Tính prefix: 0x02 nếu y chẵn, 0x03 nếu y lẻ\n  const prefix = (y[31] & 1) === 0 ? 0x02 : 0x03;\n  \n  // Tạo khóa nén: prefix (1 byte) + x (32 bytes)\n  const compressedKey = Buffer.alloc(33);\n  compressedKey[0] = prefix;\n  new Uint8Array(compressedKey).set(new Uint8Array(x), 1);\n  \n  return compressedKey;\n}\n\n// Cập nhật hàm configure_webauthn với discriminator chính xác từ IDL\nexport const createConfigureWebAuthnTx = async (\n  webauthnPubkey: Buffer,\n  multisigPDA: PublicKey,\n  owner: PublicKey\n): Promise<Transaction> => {\n  try {\n    // Lấy từ IDL: discriminator chính xác cho hàm configure_webauthn\n    const discriminator = Buffer.from([\n      40, 149, 116, 224, 148, 48, 159, 54\n    ]);\n    \n    // Nén khóa công khai từ 65 bytes xuống 33 bytes\n    let compressedKey: Buffer;\n    \n    if (webauthnPubkey.length === 65 && webauthnPubkey[0] === 0x04) {\n      // Khóa không nén, cần nén lại\n      compressedKey = compressPublicKey(webauthnPubkey);\n      console.log(\"Đã nén khóa từ 65 bytes xuống 33 bytes\");\n    } else if (webauthnPubkey.length === 33 && (webauthnPubkey[0] === 0x02 || webauthnPubkey[0] === 0x03)) {\n      // Khóa đã nén, sử dụng trực tiếp\n      compressedKey = webauthnPubkey;\n      console.log(\"Khóa đã ở định dạng nén (33 bytes)\");\n    } else {\n      console.warn(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPubkey.length} bytes`);\n      // Nếu không thể xử lý, tạo khóa giả\n      compressedKey = Buffer.alloc(33);\n      compressedKey[0] = 0x02; // Prefix cho khóa nén\n      if (webauthnPubkey.length > 0) {\n        // Sao chép dữ liệu nếu có\n        new Uint8Array(compressedKey).set(\n          new Uint8Array(webauthnPubkey.subarray(0, Math.min(webauthnPubkey.length, 32))),\n          1\n        );\n      }\n    }\n    \n    console.log(\"Khóa công khai WebAuthn (nén):\", compressedKey.toString('hex'));\n    console.log(\"Độ dài khóa (bytes):\", compressedKey.length);\n    \n    // Tạo dữ liệu instruction\n    const data = Buffer.concat([\n      new Uint8Array(discriminator),\n      new Uint8Array(compressedKey)\n    ]);\n    \n    // Tạo instruction với đúng accounts theo IDL\n    const instruction = new TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: owner, isSigner: true, isWritable: false },\n      ],\n      programId: programID,\n      data\n    });\n    \n    const tx = new Transaction().add(instruction);\n    return tx;\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction configure webauthn:\", error);\n    throw error;\n  }\n};\n\n/**\n * Tạo transaction cho storePasswordHash\n */\nexport const createStorePasswordHashTx = async (\n  passwordHash: Uint8Array,\n  multisigPDA: web3.PublicKey,\n  ownerPubkey: web3.PublicKey\n) => {\n  const tx = new web3.Transaction();\n  \n  // Sửa lỗi Buffer.from\n  const discriminator = Buffer.from([\n    // Thay thế với giá trị discriminator thực tế\n    125, 106, 39, 42, 99, 108, 43, 50\n  ]);\n  \n  // Sửa lại cách tạo data buffer\n  const data = Buffer.concat([\n    new Uint8Array(discriminator),\n    new Uint8Array(Buffer.from(Array.from(passwordHash)))\n  ]);\n  \n  // Thêm instruction để lưu password hash\n  tx.add(\n    new web3.TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: ownerPubkey, isSigner: true, isWritable: false },\n      ],\n      programId: programID,\n      data: data\n    })\n  );\n  \n  return tx;\n};\n\n/**\n * Tạo transaction xác thực WebAuthn\n */\nexport const createWebAuthnAuthTx = async (\n  multisigPDA: web3.PublicKey,\n  ownerPubkey: web3.PublicKey,\n  webauthnSignature: Uint8Array,\n  authenticatorData: Uint8Array,\n  clientDataJSON: Uint8Array\n): Promise<web3.Transaction> => {\n  const tx = new web3.Transaction();\n  \n  // Thêm discriminator đúng cho verify_webauthn_auth\n  const instructionData = Buffer.concat([\n    new Uint8Array(Buffer.from([234, 182, 165, 23, 186, 223, 208, 119])), // discriminator từ IDL\n    new Uint8Array(Buffer.from(webauthnSignature)),\n    new Uint8Array(Buffer.from(authenticatorData)),\n    new Uint8Array(Buffer.from(clientDataJSON))\n  ]);\n  \n  const instruction = new web3.TransactionInstruction({\n    keys: [\n      { pubkey: multisigPDA, isSigner: false, isWritable: true },\n      { pubkey: ownerPubkey, isSigner: false, isWritable: false }\n    ],\n    programId: programID,\n    data: instructionData\n  });\n  \n  tx.add(instruction);\n  return tx;\n};\n\n// Tạo hàm mới createAddGuardianTx\nexport const createAddGuardianTx = (\n  multisigPDA: PublicKey,\n  guardianPDA: PublicKey,\n  guardianPubkey: PublicKey,\n  guardianName: string,\n  recoveryHash: Uint8Array,\n  isOwner: boolean,\n  webauthnPubkey?: Buffer\n): Transaction => {\n  try {\n    // Discriminator cho add_guardian\n    const discriminator = Buffer.from([167, 189, 170, 27, 74, 240, 201, 241]);\n    \n    // Tạo buffer cho tên guardian\n    const nameBuffer = Buffer.from(guardianName);\n    const nameLenBuffer = Buffer.alloc(4);\n    nameLenBuffer.writeUInt32LE(nameBuffer.length, 0);\n    \n    // Tạo buffer cho các tham số\n    const isOwnerByte = Buffer.from([isOwner ? 1 : 0]);\n    \n    // Tạo buffers cho instruction data\n    const dataBuffers = [\n      discriminator,\n      guardianPubkey.toBuffer(),\n      nameLenBuffer,\n      nameBuffer,\n      Buffer.from(recoveryHash)\n    ];\n    \n    // Thêm isOwner\n    dataBuffers.push(isOwnerByte);\n    \n    // Xử lý webauthn_pubkey (option)\n    if (webauthnPubkey && isOwner) {\n      // Some variant (1)\n      dataBuffers.push(Buffer.from([1]));\n      \n      // Nén khóa công khai nếu cần\n      let compressedKey: Buffer;\n      if (webauthnPubkey.length === 65 && webauthnPubkey[0] === 0x04) {\n        // Khóa không nén, cần nén lại\n        compressedKey = compressPublicKey(webauthnPubkey);\n      } else if (webauthnPubkey.length === 33 && (webauthnPubkey[0] === 0x02 || webauthnPubkey[0] === 0x03)) {\n        // Khóa đã nén, sử dụng trực tiếp\n        compressedKey = webauthnPubkey;\n      } else {\n        throw new Error(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPubkey.length} bytes`);\n      }\n      \n      dataBuffers.push(compressedKey);\n    } else {\n      // None variant (0)\n      dataBuffers.push(Buffer.from([0]));\n    }\n    \n    // Nối tất cả buffer lại với nhau\n    const data = Buffer.concat(dataBuffers.map(buffer => new Uint8Array(buffer)));\n    \n    // Tạo instruction\n    const instruction = new TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: guardianPDA, isSigner: false, isWritable: true },\n        { pubkey: guardianPubkey, isSigner: true, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n      ],\n      programId: programID,\n      data\n    });\n    \n    return new Transaction().add(instruction);\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction add guardian:\", error);\n    throw error;\n  }\n};\n\n// Thêm các hằng số cho curve secp256r1\n// Order của curve secp256r1\nconst SECP256R1_ORDER = new Uint8Array([\n  0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9,\n  0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51,\n]);\n\n// Nửa order của curve secp256r1\nconst SECP256R1_HALF_ORDER = new Uint8Array([\n  0x7f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xde, 0x73, 0x7d, 0x56, 0xd3, 0x8b, 0xcf, 0x42, 0x79, 0xdc,\n  0xe5, 0x61, 0x7e, 0x31, 0x92, 0xa8,\n]);\n\n// Thêm hàm so sánh số lớn\nfunction isGreaterThan(a: Uint8Array | Buffer, b: Uint8Array): boolean {\n  const aBuf = Buffer.isBuffer(a) ? a : Buffer.from(a);\n  if (aBuf.length !== b.length) {\n    return aBuf.length > b.length;\n  }\n  for (let i = 0; i < aBuf.length; i++) {\n    if (aBuf[i] !== b[i]) {\n      return aBuf[i] > b[i];\n    }\n  }\n  return false;\n}\n\n// Sửa lại hàm subtractBigNumbers để xử lý big-endian đúng cách\nfunction subtractBigNumbers(a: Uint8Array, b: Uint8Array | Buffer): Uint8Array {\n  const bBuf = Buffer.isBuffer(b) ? b : Buffer.from(b);\n  const result = new Uint8Array(a.length);\n  let borrow = 0;\n  \n  // Đảm bảo cả a và b đều có đúng 32 bytes\n  if (a.length !== 32 || bBuf.length !== 32) {\n    console.error(`Độ dài không đúng: a=${a.length}, b=${bBuf.length}, phải là 32 bytes`);\n  }\n\n  // Tính từ byte ít quan trọng nhất đến quan trọng nhất (big endian)\n  for (let i = a.length - 1; i >= 0; i--) {\n    let diff = a[i] - bBuf[i] - borrow;\n    if (diff < 0) {\n      diff += 256;\n      borrow = 1;\n    } else {\n      borrow = 0;\n    }\n    result[i] = diff;\n  }\n  \n  // Log giá trị input và output để debug\n  console.log('Input a (hex):', Buffer.from(a).toString('hex'));\n  console.log('Input b (hex):', Buffer.from(bBuf).toString('hex'));\n  console.log('Result (hex):', Buffer.from(result).toString('hex'));\n\n  return result;\n}\n\n// Sửa hàm createSecp256r1Instruction phần đóng gói dữ liệu\nexport const createSecp256r1Instruction = (\n  publicKey: Buffer,\n  signature: Buffer,\n  message: Buffer\n): web3.TransactionInstruction => {\n  try {\n    console.log('Tạo secp256r1 instruction với:');\n    console.log('- Public key length:', publicKey.length);\n    console.log('- Signature length:', signature.length);\n    console.log('- Message length:', message.length);\n    \n    if (!publicKey || !signature || !message) {\n      throw new Error('Public key, signature, hoặc message không được để trống');\n    }\n    \n    if (publicKey.length !== 33) {\n      throw new Error(`Public key phải có độ dài 33 bytes (dạng nén), nhận được ${publicKey.length} bytes`);\n    }\n    \n    if (signature.length !== 64) {\n      throw new Error(`Signature phải có độ dài 64 bytes, nhận được ${signature.length} bytes`);\n    }\n    \n    if (message.length !== 32) {\n      throw new Error(`Message phải có độ dài 32 bytes, nhận được ${message.length} bytes`);\n    }\n    \n    // Chuẩn hóa chữ ký theo chuẩn ECDSA\n    // Chia signature thành r và s\n    const r = signature.slice(0, 32);\n    const s = signature.slice(32, 64);\n    \n    console.log('Signature components:');\n    console.log('- r (hex):', r.toString('hex'));\n    console.log('- s (hex):', s.toString('hex'));\n    \n    // Kiểm tra và chuẩn hóa giá trị s nếu cần\n    if (isGreaterThan(s, SECP256R1_HALF_ORDER)) {\n      console.log('Chuẩn hóa signature: s > HALF_ORDER, thực hiện s = ORDER - s');\n      const newS = subtractBigNumbers(SECP256R1_ORDER, s);\n      \n      // Đảm bảo newS đúng độ dài 32 bytes\n      const newSBuf = Buffer.from(newS);\n      if (newSBuf.length !== 32) {\n        console.error(`newS có độ dài ${newSBuf.length}, không phải 32 bytes!`);\n      }\n      \n      // Tạo signature mới với r giữ nguyên và s chuẩn hóa\n      signature = Buffer.concat([r, Buffer.from(newS)]);\n      console.log('Signature sau khi chuẩn hóa (hex):', signature.toString('hex'));\n      console.log('Độ dài signature sau khi chuẩn hóa:', signature.length);\n    } else {\n      console.log('Signature đã chuẩn hóa, không cần thay đổi');\n    }\n    \n    // Cấu trúc hóa dữ liệu cho instruction theo đúng quy trình\n    const numSignatures = 1;\n    const instructionData = Buffer.alloc(2 + 14 + signature.length + publicKey.length + message.length);\n    \n    // Số lượng signatures (2 bytes)\n    instructionData.writeUInt8(numSignatures, 0);\n    instructionData.writeUInt8(0, 1); // padding\n    \n    // Offset và index cho signature, pubkey và message\n    const sigOffset = 2 + 14; // 2 bytes header + 14 bytes offsets\n    const pubkeyOffset = sigOffset + signature.length;\n    const messageOffset = pubkeyOffset + publicKey.length;\n    \n    // Viết các offset và index (14 bytes total)\n    instructionData.writeUInt16LE(sigOffset, 2);     // signature_offset (2 bytes)\n    instructionData.writeUInt16LE(0, 4);             // signature_instruction_index (2 bytes) - current instruction\n    instructionData.writeUInt16LE(pubkeyOffset, 6);  // public_key_offset (2 bytes)\n    instructionData.writeUInt16LE(0, 8);             // public_key_instruction_index (2 bytes) - current instruction\n    instructionData.writeUInt16LE(messageOffset, 10); // message_offset (2 bytes)\n    instructionData.writeUInt16LE(message.length, 12);// message_size (2 bytes)\n    instructionData.writeUInt16LE(0, 14);            // message_instruction_index (2 bytes) - current instruction\n    \n    // Copy dữ liệu vào các vị trí tương ứng\n    signature.copy(instructionData, sigOffset);      // copy signature\n    publicKey.copy(instructionData, pubkeyOffset);   // copy public key\n    message.copy(instructionData, messageOffset);    // copy message\n    \n    console.log('Secp256r1 instruction data:', {\n      totalSize: instructionData.length,\n      signatureOffset: sigOffset,\n      publicKeyOffset: pubkeyOffset,\n      messageOffset: messageOffset,\n      headerHex: instructionData.slice(0, 16).toString('hex')\n    });\n    \n    // Tạo instruction\n    return new web3.TransactionInstruction({\n      keys: [],\n      programId: SECP256R1_PROGRAM_ID,\n      data: instructionData\n    });\n  } catch (error) {\n    console.error('❌ Lỗi khi tạo secp256r1 instruction:', error);\n    throw error;\n  }\n};\n\n/**\n * Kiểm tra xem chữ ký secp256r1 có hợp lệ không bằng cách mô phỏng transaction\n * @param connection Kết nối đến Solana cluster\n * @param publicKey Khóa công khai (dạng nén) dùng để xác minh\n * @param signature Chữ ký (raw format, 64 bytes) cần xác minh\n * @param message Message đã hash (32 bytes) đã được ký\n * @returns Promise<{isValid: boolean, error?: string}> Kết quả kiểm tra và lỗi nếu có\n */\nexport const testSecp256r1Signature = async (\n  connection: web3.Connection,\n  publicKey: Buffer,\n  signature: Buffer,\n  message: Buffer\n): Promise<{isValid: boolean, error?: string}> => {\n  try {\n    // Tạo instruction secp256r1 để kiểm tra\n    const testInstruction = createSecp256r1Instruction(\n      publicKey,\n      signature,\n      message\n    );\n    \n    // Tạo một feePayer giả lập để dùng cho transaction test\n    const feePayer = web3.Keypair.generate();\n    \n    console.log('Kiểm tra chữ ký secp256r1 với transaction riêng biệt...');\n    console.log('Tạo instruction secp256r1 thành công:', {\n      publicKeyLength: publicKey.length,\n      signatureLength: signature.length,\n      messageLength: message.length\n    });\n    \n    // Tiến hành airdrop SOL cho feePayer trước khi mô phỏng\n    try {\n      const airdropSignature = await connection.requestAirdrop(\n        feePayer.publicKey,\n        web3.LAMPORTS_PER_SOL / 100 // Chỉ cần một lượng nhỏ SOL\n      );\n      \n      // Đợi xác nhận airdrop\n      await connection.confirmTransaction(airdropSignature);\n      console.log('Đã airdrop SOL cho fee payer để mô phỏng');\n      \n      // Xác nhận số dư\n      const balance = await connection.getBalance(feePayer.publicKey);\n      console.log(`Số dư feePayer: ${balance / web3.LAMPORTS_PER_SOL} SOL`);\n      \n      if (balance === 0) {\n        throw new Error('Không thể airdrop SOL');\n      }\n    } catch (airdropError) {\n      console.warn('Lỗi khi airdrop SOL:', airdropError);\n      console.log('Tiếp tục mô phỏng mà không có airdrop...');\n      // Không return ở đây, vẫn tiếp tục mô phỏng\n    }\n    \n    // Tạo transaction riêng chỉ với instruction secp256r1\n    const testTx = new web3.Transaction().add(testInstruction);\n    testTx.feePayer = feePayer.publicKey;\n    \n    // Thiết lập blockhash cho transaction\n    const { blockhash } = await connection.getLatestBlockhash();\n    testTx.recentBlockhash = blockhash;\n    \n    // Ký transaction bằng feePayer\n    testTx.sign(feePayer);\n    \n    try {\n      // Mô phỏng transaction để kiểm tra (không gửi lên blockchain)\n      const simulationResult = await connection.simulateTransaction(testTx);\n      \n      // Kiểm tra kết quả mô phỏng\n      if (simulationResult.value.err) {\n        // Có lỗi, kiểm tra xem có phải lỗi chữ ký không\n        const errorString = JSON.stringify(simulationResult.value.err);\n        \n        console.error('Lỗi khi mô phỏng chữ ký secp256r1:', errorString);\n        \n        // Nếu lỗi chứa các string liên quan đến chữ ký không hợp lệ\n        if (errorString.includes('signature') && \n            (errorString.includes('invalid') || errorString.includes('verification failed'))) {\n          return { isValid: false, error: 'Chữ ký không hợp lệ: ' + errorString };\n        }\n        \n        // Có lỗi khác không liên quan đến chữ ký\n        return { isValid: false, error: 'Lỗi khi mô phỏng transaction: ' + errorString };\n      }\n      \n      // Không có lỗi, chữ ký hợp lệ\n      console.log('Kiểm tra chữ ký secp256r1 thành công!');\n      return { isValid: true };\n    } catch (simError: any) {\n      // Xử lý lỗi mô phỏng\n      console.error('Lỗi khi mô phỏng transaction:', simError);\n      \n      // Kiểm tra nếu lỗi là AccountNotFound\n      if (simError.toString().includes('AccountNotFound')) {\n        console.log('Lỗi AccountNotFound: Đây là lỗi mô phỏng, không phải lỗi chữ ký');\n        console.log('Tiếp tục với giả định chữ ký hợp lệ...');\n        \n        // Trả về kết quả giả định chữ ký hợp lệ, nhưng có ghi chú về lỗi\n        return { \n          isValid: true, \n          error: 'Không thể xác minh hoàn toàn do lỗi AccountNotFound trong mô phỏng'\n        };\n      }\n      \n      // Các lỗi khác\n      return { isValid: false, error: simError.toString() };\n    }\n  } catch (error: any) {\n    console.error('Lỗi khi kiểm tra chữ ký secp256r1:', error);\n    return { isValid: false, error: error.toString() };\n  }\n};\n\n/**\n * Tạo transaction để chuyển tiền\n * @param multisigPDA PDA của ví multisig\n * @param guardianPDA PDA của guardian\n * @param destination Địa chỉ đích để chuyển token\n * @param amountLamports Số lượng lamports để chuyển\n * @param nonce Nonce tránh replay attack\n * @param timestamp Timestamp cho giao dịch\n * @param message Thông điệp gốc (chưa hash)\n * @param payer Người trả phí giao dịch\n */\nexport const createTransferTx = (\n  multisigPDA: PublicKey,\n  guardianPDA: PublicKey,\n  destination: PublicKey,\n  amountLamports: number,\n  nonce: number,\n  timestamp: number,\n  message: Uint8Array,\n  payer: PublicKey\n): Transaction => {\n  try {\n    // Kiểm tra các input\n    if (!(multisigPDA instanceof PublicKey)) {\n      throw new Error(`multisigPDA không phải PublicKey: ${typeof multisigPDA}`);\n    }\n    if (!(guardianPDA instanceof PublicKey)) {\n      throw new Error(`guardianPDA không phải PublicKey: ${typeof guardianPDA}`);\n    }\n    if (!(destination instanceof PublicKey)) {\n      throw new Error(`destination không phải PublicKey: ${typeof destination}`);\n    }\n    if (!(payer instanceof PublicKey)) {\n      throw new Error(`payer không phải PublicKey: ${typeof payer}`);\n    }\n    \n    // Đảm bảo các giá trị số hợp lệ\n    if (isNaN(amountLamports) || amountLamports <= 0) {\n      throw new Error(`amountLamports không hợp lệ: ${amountLamports}`);\n    }\n    if (isNaN(nonce) || nonce < 0) {\n      throw new Error(`nonce không hợp lệ: ${nonce}`);\n    }\n    if (isNaN(timestamp) || timestamp <= 0) {\n      throw new Error(`timestamp không hợp lệ: ${timestamp}`);\n    }\n    \n    // Log thông tin debug để kiểm tra\n    console.log('Tạo transaction chuyển tiền với thông tin:');\n    console.log('- multisigPDA:', multisigPDA.toString());\n    console.log('- guardianPDA:', guardianPDA.toString());\n    console.log('- destination:', destination.toString());\n    console.log('- amountLamports:', amountLamports);\n    console.log('- nonce:', nonce);\n    console.log('- timestamp:', timestamp);\n    console.log('- message length:', message.length);\n    console.log('- payer:', payer.toString());\n    \n    // Discriminator cho verify_and_execute\n    const discriminator = Buffer.from([80, 118, 102, 72, 125, 57, 218, 137]);\n    \n    // Tham số cho 'action' - chuỗi \"transfer\"\n    const action = \"transfer\";\n    const actionBuffer = Buffer.from(action);\n    const actionLenBuffer = Buffer.alloc(4);\n    actionLenBuffer.writeUInt32LE(actionBuffer.length, 0);\n    \n    // Encode ActionParams\n    const amountBuffer = Buffer.alloc(9); // 1 byte cho Option + 8 bytes cho u64\n    amountBuffer.writeUInt8(1, 0); // 1 = Some\n    const amountBigInt = BigInt(amountLamports);\n    for (let i = 0; i < 8; i++) {\n      amountBuffer.writeUInt8(Number((amountBigInt >> BigInt(8 * i)) & BigInt(0xFF)), i + 1);\n    }\n    \n    // Encode destination\n    const destinationBuffer = Buffer.alloc(33); // 1 byte cho Option + 32 bytes cho PublicKey\n    destinationBuffer.writeUInt8(1, 0); // 1 = Some\n    Buffer.from(destination.toBuffer()).copy(destinationBuffer, 1);\n    \n    // Encode token_mint (None)\n    const tokenMintBuffer = Buffer.alloc(1);\n    tokenMintBuffer.writeUInt8(0, 0); // 0 = None\n    \n    // Encode nonce (u64, little-endian)\n    const nonceBuffer = Buffer.alloc(8);\n    const nonceBigInt = BigInt(nonce);\n    for (let i = 0; i < 8; i++) {\n      nonceBuffer.writeUInt8(Number((nonceBigInt >> BigInt(8 * i)) & BigInt(0xFF)), i);\n    }\n    \n    // Encode timestamp (i64, little-endian)\n    const timestampBuffer = Buffer.alloc(8);\n    const timestampBigInt = BigInt(timestamp);\n    for (let i = 0; i < 8; i++) {\n      timestampBuffer.writeUInt8(Number((timestampBigInt >> BigInt(8 * i)) & BigInt(0xFF)), i);\n    }\n    \n    // Encode message (vec<u8>)\n    const messageLenBuffer = Buffer.alloc(4);\n    messageLenBuffer.writeUInt32LE(message.length, 0);\n    const messageBuffer = Buffer.from(message);\n    \n    // Nối tất cả buffer lại với nhau\n    const data = Buffer.concat([\n      discriminator,\n      actionLenBuffer,\n      actionBuffer,\n      amountBuffer,\n      destinationBuffer,\n      tokenMintBuffer,\n      nonceBuffer,\n      timestampBuffer,\n      messageLenBuffer,\n      messageBuffer\n    ]);\n    \n    // Kiểm tra địa chỉ của instruction sysvar\n    const sysvarInstructionPubkey = SYSVAR_INSTRUCTIONS_PUBKEY;\n    const sysvarClockPubkey = SYSVAR_CLOCK_PUBKEY;\n    \n    // Tạo instruction verify_and_execute\n    const ix = new TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: guardianPDA, isSigner: false, isWritable: false },\n        { pubkey: sysvarClockPubkey, isSigner: false, isWritable: false },\n        { pubkey: sysvarInstructionPubkey, isSigner: false, isWritable: false },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: destination, isSigner: false, isWritable: true }\n      ],\n      programId: programID,\n      data\n    });\n    \n    // Tạo transaction mới\n    return new Transaction().add(ix);\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction chuyển tiền:\", error);\n    throw error;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}