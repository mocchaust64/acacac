{"ast":null,"code":"import { bufferToHex } from './bufferUtils';\nimport * as CBOR from 'cbor-web';\nimport { PublicKey } from '@solana/web3.js';\nimport { processCredentialIdForPDA } from './helpers';\n\n/**\n * Tạo WebAuthn credential mới\n */\nexport const createWebAuthnCredential = async (walletAddress, walletName) => {\n  try {\n    if (!isWebAuthnSupported()) {\n      throw new Error('WebAuthn không được hỗ trợ trên trình duyệt này');\n    }\n\n    // Tạo challenge ngẫu nhiên\n    const challenge = new Uint8Array(32);\n    crypto.getRandomValues(challenge);\n\n    // Tạo userID ngẫu nhiên cho mỗi ví để tránh ghi đè credentials\n    const userId = new Uint8Array(16);\n    crypto.getRandomValues(userId);\n\n    // Đảm bảo có tên ví (quan trọng cho hiển thị trên hộp thoại trình duyệt)\n    const walletDisplayName = walletName || `Moon Wallet ${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`;\n    console.log(`Tạo credential với tên: \"${walletDisplayName}\"`);\n\n    // Tạo options cho credential creation\n    const options = {\n      challenge: challenge,\n      rp: {\n        name: 'Moon Wallet',\n        id: window.location.hostname\n      },\n      user: {\n        id: userId,\n        name: walletDisplayName,\n        // Sử dụng walletDisplayName cho cả name\n        displayName: walletDisplayName // Và displayName\n      },\n      pubKeyCredParams: [{\n        type: 'public-key',\n        alg: -7\n      },\n      // ES256\n      {\n        type: 'public-key',\n        alg: -257\n      } // RS256\n      ],\n      authenticatorSelection: {\n        authenticatorAttachment: 'platform',\n        userVerification: 'preferred',\n        requireResidentKey: true // ĐẶT thành TRUE để ép buộc lưu tên\n      },\n      timeout: 60000,\n      attestation: 'direct' // Thay đổi từ 'none' sang 'direct' để có thêm thông tin\n    };\n    console.log(\"Đang yêu cầu tạo credential với options:\", options);\n    const credential = await navigator.credentials.create({\n      publicKey: options\n    });\n    if (!credential) {\n      throw new Error('Không thể tạo khóa WebAuthn');\n    }\n    console.log(\"Credential đã được tạo:\", credential);\n    const response = credential.response;\n\n    // Phân tích attestationObject để lấy public key\n    const attestationBuffer = new Uint8Array(response.attestationObject);\n    const attestationObject = CBOR.decode(attestationBuffer.buffer);\n\n    // Lấy thông tin credentialId\n    const credentialId = bufferToHex(credential.rawId);\n    console.log(\"Raw credential ID buffer:\", new Uint8Array(credential.rawId));\n    console.log(\"Credentials raw ID as hex:\", credentialId);\n\n    // Phân tích authenticatorData để lấy public key\n    const authData = attestationObject.authData;\n    const publicKeyBytes = extractPublicKeyFromAuthData(authData);\n    const publicKey = bufferToHex(publicKeyBytes);\n\n    // Lưu thông tin credential vào indexedDB/localStorage để sử dụng sau này\n    saveCredentialInfo(walletAddress, credentialId, publicKey, userId, walletDisplayName);\n    return {\n      credentialId,\n      publicKey,\n      rawId: new Uint8Array(credential.rawId)\n    };\n  } catch (error) {\n    console.error('Lỗi khi tạo WebAuthn credential:', error);\n    throw error;\n  }\n};\n\n/**\n * Trích xuất public key từ authenticator data\n */\nfunction extractPublicKeyFromAuthData(authData) {\n  // Theo WebAuthn spec, bố cục của authenticator data:\n  // [32 bytes RP ID hash, 1 byte flags, 4 bytes counter, variable length AAGUID, variable length credential ID, variable length COSE public key]\n\n  // Bỏ qua 32 bytes cho RP ID hash + 1 byte flags + 4 bytes counter = 37 bytes\n  let offset = 37;\n\n  // Bỏ qua AAGUID (16 bytes)\n  offset += 16;\n\n  // Đọc độ dài credential ID (2 bytes)\n  const credentialIdLength = authData[offset] << 8 | authData[offset + 1];\n  offset += 2;\n\n  // Bỏ qua credential ID\n  offset += credentialIdLength;\n\n  // Đọc COSE public key\n  const cosePublicKey = authData.slice(offset);\n  try {\n    // Giải mã COSE public key (sử dụng thư viện CBOR nếu có)\n    const publicKeyObj = CBOR.decode(cosePublicKey);\n\n    // Lấy coordinaates x và y từ -2 và -3 (theo COSE Web Key)\n    const x = publicKeyObj.get(-2);\n    const y = publicKeyObj.get(-3);\n\n    // Tạo uncompressed EC public key (0x04 || x || y)\n    const uncompressedKey = new Uint8Array(65);\n    uncompressedKey[0] = 0x04; // Uncompressed point format\n    uncompressedKey.set(new Uint8Array(x), 1);\n    uncompressedKey.set(new Uint8Array(y), 33);\n    return uncompressedKey;\n  } catch (e) {\n    console.error(\"Lỗi khi trích xuất public key:\", e);\n\n    // Trả về dummy key nếu không thể trích xuất\n    const dummyKey = new Uint8Array(65);\n    dummyKey[0] = 0x04;\n    const randomX = new Uint8Array(32);\n    const randomY = new Uint8Array(32);\n    window.crypto.getRandomValues(randomX);\n    window.crypto.getRandomValues(randomY);\n    dummyKey.set(randomX, 1);\n    dummyKey.set(randomY, 33);\n    return dummyKey;\n  }\n}\n\n/**\n * Sử dụng WebAuthn credential đã có\n */\nexport const getWebAuthnCredential = async (credentialId, challenge) => {\n  if (!isWebAuthnSupported()) {\n    throw new Error('WebAuthn không được hỗ trợ trên trình duyệt này');\n  }\n\n  // Sử dụng challenge được cung cấp hoặc tạo mới nếu không có\n  const finalChallenge = challenge || crypto.getRandomValues(new Uint8Array(32));\n\n  // Tạo options cho get assertion\n  const options = {\n    challenge: finalChallenge,\n    allowCredentials: [{\n      id: credentialId,\n      type: 'public-key'\n    }],\n    userVerification: 'preferred',\n    timeout: 60000\n  };\n  try {\n    const assertion = await navigator.credentials.get({\n      publicKey: options\n    });\n    const response = assertion.response;\n    return {\n      signature: new Uint8Array(response.signature),\n      authenticatorData: new Uint8Array(response.authenticatorData),\n      clientDataJSON: new Uint8Array(response.clientDataJSON)\n    };\n  } catch (error) {\n    console.error('Lỗi khi xác thực WebAuthn:', error);\n    throw error;\n  }\n};\n\n/**\n * Kiểm tra xem WebAuthn có được hỗ trợ không\n */\nexport const isWebAuthnSupported = () => {\n  return window.PublicKeyCredential !== undefined && typeof window.PublicKeyCredential === 'function';\n};\n\n// Chạy thử một số tùy chọn để kiểm tra khả năng tương thích\nexport const checkWebAuthnCompatibility = async () => {\n  if (!isWebAuthnSupported()) {\n    return 'WebAuthn không được hỗ trợ trên trình duyệt này';\n  }\n  try {\n    // Kiểm tra xem trình duyệt có hỗ trợ thuộc tính \"isUserVerifyingPlatformAuthenticatorAvailable\"\n    if (PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable) {\n      const available = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n      if (!available) {\n        return 'Thiết bị này không có xác thực sinh trắc học được hỗ trợ';\n      }\n    }\n    return 'WebAuthn được hỗ trợ đầy đủ';\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    return `Lỗi khi kiểm tra WebAuthn: ${errorMessage}`;\n  }\n};\n\n/**\n * Xác minh chữ ký WebAuthn trong frontend\n */\nexport const verifyWebAuthnSignature = async (pubkey, signature, authenticatorData, clientDataJSON) => {\n  try {\n    // Kiểm tra các tham số đầu vào\n    if (!pubkey || !signature || !authenticatorData || !clientDataJSON) {\n      console.error('Thiếu tham số cần thiết cho xác minh WebAuthn');\n      return false;\n    }\n    console.log(\"Public key length:\", pubkey.length);\n    console.log(\"Pubkey:\", pubkey.toString('hex'));\n\n    // Kiểm tra độ dài khóa\n    if (pubkey.length !== 65) {\n      console.warn(`Khóa WebAuthn không đúng độ dài: ${pubkey.length} (cần 65 byte)`);\n\n      // Tạo khóa mới với độ dài đúng\n      const newPubkey = Buffer.alloc(65);\n      copyBuffer(pubkey, newPubkey, 0, 0, Math.min(pubkey.length, 65));\n\n      // Nếu byte đầu tiên không phải 0x04, sửa lại\n      if (newPubkey[0] !== 0x04) {\n        newPubkey[0] = 0x04;\n      }\n      pubkey = newPubkey;\n      console.log('Pubkey sau khi sửa độ dài:', pubkey.toString('hex'));\n    }\n\n    // Kiểm tra định dạng khóa (phải bắt đầu bằng 0x04)\n    if (pubkey[0] !== 0x04) {\n      console.warn(`Khóa WebAuthn không bắt đầu bằng 0x04: ${pubkey[0].toString(16)}`);\n      // Tạo khóa mới với byte đầu tiên là 0x04\n      const newPubkey = Buffer.alloc(65);\n      newPubkey[0] = 0x04;\n      copyBuffer(pubkey, newPubkey, 1, 1, 65);\n      pubkey = newPubkey;\n      console.log('Pubkey sau khi sửa byte đầu:', pubkey.toString('hex'));\n    }\n\n    // 1. Parse clientDataJSON\n    const clientDataObj = JSON.parse(new TextDecoder().decode(clientDataJSON));\n    console.log(\"Client data:\", clientDataObj);\n\n    // 2. Lấy hash của clientDataJSON\n    const clientDataHash = await crypto.subtle.digest('SHA-256', clientDataJSON);\n\n    // 3. Kết hợp dữ liệu để xác minh\n    const authData = new Uint8Array(authenticatorData);\n    const hashData = new Uint8Array(clientDataHash);\n    const verificationData = new Uint8Array(authData.length + hashData.length);\n    verificationData.set(authData, 0);\n    verificationData.set(hashData, authData.length);\n    console.log(\"Dữ liệu xác minh:\", Buffer.from(verificationData).toString('hex'));\n    console.log(\"Pubkey cuối cùng:\", pubkey.toString('hex'));\n    console.log(\"Signature:\", Buffer.from(signature).toString('hex'));\n    console.log(\"Signature length:\", signature.length);\n    try {\n      // 4. Chuyển đổi khóa công khai sang định dạng SPKI\n      const spkiKey = convertRawToSPKI(pubkey);\n\n      // 5. Import khóa công khai\n      const cryptoKey = await crypto.subtle.importKey('spki', spkiKey, {\n        name: 'ECDSA',\n        namedCurve: 'P-256'\n      }, false, ['verify']);\n\n      // 6. Xác minh chữ ký\n      const result = await crypto.subtle.verify({\n        name: 'ECDSA',\n        hash: 'SHA-256'\n      }, cryptoKey, signature, verificationData);\n      console.log('Kết quả xác minh:', result);\n      return result;\n    } catch (e) {\n      console.error(\"Lỗi khi xác thực chữ ký:\", e);\n\n      // Thử với cách khác nếu cách đầu tiên thất bại\n      try {\n        console.log('Thử phương pháp xác minh thay thế...');\n\n        // Chuyển đổi chữ ký từ DER sang raw nếu cần\n        let rawSignature = signature;\n        if (signature.length > 64 && signature[0] === 0x30) {\n          console.log('Phát hiện chữ ký DER, đang chuyển đổi...');\n          const derSignature = Buffer.from(signature);\n          const convertedSignature = derToRaw(derSignature);\n          rawSignature = convertedSignature;\n          console.log('Chữ ký sau khi chuyển đổi:', Buffer.from(rawSignature).toString('hex'));\n        }\n\n        // Import khóa và xác minh lại\n        const spkiKey = convertRawToSPKI(pubkey);\n        const cryptoKey = await crypto.subtle.importKey('spki', spkiKey, {\n          name: 'ECDSA',\n          namedCurve: 'P-256'\n        }, false, ['verify']);\n        const result = await crypto.subtle.verify({\n          name: 'ECDSA',\n          hash: 'SHA-256'\n        }, cryptoKey, rawSignature, verificationData);\n        console.log('Kết quả xác minh thay thế:', result);\n        return result;\n      } catch (alternativeError) {\n        console.error('Lỗi khi thử phương pháp thay thế:', alternativeError);\n        return false;\n      }\n    }\n  } catch (error) {\n    console.error('Lỗi khi xác minh chữ ký WebAuthn:', error);\n    return false;\n  }\n};\n\n// Hàm tiện ích để chuyển đổi Buffer sang Uint8Array phù hợp với yêu cầu\nfunction bufferToUint8Array(buffer) {\n  // Tạo một Uint8Array mới từ Buffer để tránh các vấn đề về tương thích\n  return new Uint8Array(buffer);\n}\n\n// Sửa lại hàm copy để tránh lỗi về type\nfunction copyBuffer(source, target, targetStart = 0, sourceStart = 0, sourceEnd = source.length) {\n  // Tạo view mới từ source buffer\n  const sourceView = new Uint8Array(source.buffer, source.byteOffset + sourceStart, Math.min(sourceEnd, source.length) - sourceStart);\n  // Tạo view mới từ target buffer\n  const targetView = new Uint8Array(target.buffer, target.byteOffset + targetStart, target.length - targetStart);\n  // Copy giữa các Uint8Array\n  targetView.set(sourceView.slice(0, Math.min(sourceView.length, targetView.length)));\n}\n\n// Hàm chuyển đổi khóa từ định dạng raw sang SPKI\nconst convertRawToSPKI = rawKey => {\n  try {\n    // Đảm bảo khóa bắt đầu bằng 0x04\n    if (rawKey[0] !== 0x04) {\n      console.warn('Khóa không bắt đầu bằng 0x04, đang sửa...');\n      // Tạo khóa mới với byte đầu tiên là 0x04\n      const newRawKey = Buffer.alloc(65);\n      newRawKey[0] = 0x04;\n      // Sao chép phần còn lại của khóa\n      if (rawKey.length >= 64) {\n        copyBuffer(rawKey, newRawKey, 1, 1, 65);\n      } else {\n        copyBuffer(rawKey, newRawKey, 1, 0, Math.min(rawKey.length, 64));\n      }\n      rawKey = newRawKey;\n    }\n\n    // Tạo SPKI header\n    const spkiHeader = Buffer.from('3059301306072a8648ce3d020106082a8648ce3d030107034200', 'hex');\n\n    // Nối header với khóa (bỏ byte đầu tiên 0x04)\n    const rawKeySlice = new Uint8Array(rawKey.buffer, rawKey.byteOffset + 1, rawKey.length - 1);\n    const spkiBuffer = new Uint8Array(spkiHeader.length + rawKeySlice.length);\n    spkiBuffer.set(new Uint8Array(spkiHeader), 0);\n    spkiBuffer.set(rawKeySlice, spkiHeader.length);\n\n    // Trả về ArrayBuffer\n    return spkiBuffer.buffer.slice(0); // .slice(0) đảm bảo trả về ArrayBuffer thay vì ArrayBufferLike\n  } catch (error) {\n    console.error('Lỗi khi chuyển đổi khóa:', error);\n    throw error;\n  }\n};\n\n// Hàm chuyển đổi chữ ký từ DER sang raw\nconst derToRaw = signature => {\n  try {\n    // DER format: 30 + len + 02 + r_len + r + 02 + s_len + s\n    let offset = 2; // Skip 30 + len\n\n    // Read r\n    if (signature[offset] !== 0x02) {\n      throw new Error('Định dạng DER không hợp lệ: không tìm thấy marker r');\n    }\n    offset++; // Skip 02\n\n    const rLen = signature[offset++];\n    let r = signature.slice(offset, offset + rLen);\n    offset += rLen;\n\n    // Read s\n    if (signature[offset] !== 0x02) {\n      throw new Error('Định dạng DER không hợp lệ: không tìm thấy marker s');\n    }\n    offset++; // Skip 02\n\n    const sLen = signature[offset++];\n    let s = signature.slice(offset, offset + sLen);\n\n    // Pad r and s to 32 bytes\n    let rPadded, sPadded;\n    if (r.length < 32) {\n      const padding = Buffer.alloc(32 - r.length, 0);\n      rPadded = new Uint8Array(32);\n      rPadded.set(new Uint8Array(padding), 0);\n      rPadded.set(new Uint8Array(r), padding.length);\n    } else if (r.length > 32) {\n      rPadded = new Uint8Array(r.buffer, r.byteOffset + r.length - 32, 32);\n    } else {\n      rPadded = new Uint8Array(r);\n    }\n    if (s.length < 32) {\n      const padding = Buffer.alloc(32 - s.length, 0);\n      sPadded = new Uint8Array(32);\n      sPadded.set(new Uint8Array(padding), 0);\n      sPadded.set(new Uint8Array(s), padding.length);\n    } else if (s.length > 32) {\n      sPadded = new Uint8Array(s.buffer, s.byteOffset + s.length - 32, 32);\n    } else {\n      sPadded = new Uint8Array(s);\n    }\n\n    // Concatenate r and s\n    const result = new Uint8Array(64);\n    result.set(rPadded, 0);\n    result.set(sPadded, 32);\n    return result;\n  } catch (error) {\n    console.error('Lỗi khi chuyển đổi chữ ký DER sang raw:', error);\n    throw error;\n  }\n};\n\n/**\n * Kiểm tra xem public key có đúng định dạng không\n */\nexport const validatePublicKey = publicKeyHex => {\n  try {\n    const pubkey = Buffer.from(publicKeyHex, 'hex');\n    // Public key không nén phải là 65 bytes (1 byte header + 32 bytes x + 32 bytes y)\n    if (pubkey.length !== 65) {\n      console.error(`Public key không đúng độ dài: ${pubkey.length} bytes (mong đợi 65 bytes)`);\n      return false;\n    }\n\n    // Byte đầu tiên phải là 0x04 (định dạng không nén)\n    if (pubkey[0] !== 0x04) {\n      console.error(`Public key không phải định dạng không nén: byte đầu tiên là ${pubkey[0].toString(16)} (mong đợi 0x04)`);\n      return false;\n    }\n    console.log(\"Public key hợp lệ\");\n    return true;\n  } catch (error) {\n    console.error(\"Lỗi khi xác thực public key:\", error);\n    return false;\n  }\n};\n\n/**\n * Lấy WebAuthn assertion từ credential đã có\n */\nexport const getWebAuthnAssertion = async (credentialId, message, allowEmpty = false) => {\n  if (!isWebAuthnSupported()) {\n    throw new Error('WebAuthn không được hỗ trợ trên trình duyệt này');\n  }\n\n  // Tạo challenge từ message hoặc ngẫu nhiên nếu không có message\n  let challenge;\n  if (message) {\n    // Nếu có message, sử dụng hash của message làm challenge\n    const msgBytes = new TextEncoder().encode(message);\n    const msgHash = await crypto.subtle.digest('SHA-256', msgBytes);\n    challenge = new Uint8Array(msgHash);\n    console.log(\"Sử dụng message để tạo challenge:\", message);\n  } else {\n    // Nếu không, tạo challenge ngẫu nhiên\n    challenge = new Uint8Array(32);\n    crypto.getRandomValues(challenge);\n  }\n  console.log(\"Challenge:\", Buffer.from(challenge).toString('hex'));\n\n  // Tạo options cho get assertion\n  const options = {\n    challenge: challenge,\n    rpId: window.location.hostname,\n    timeout: 60000,\n    // Thay đổi userVerification từ 'preferred' thành 'discouraged' để ưu tiên hiển thị danh sách credentials\n    userVerification: 'discouraged'\n  };\n\n  // Xử lý credentialId - chuyển từ hex sang buffer\n  let credentialIdBuffer;\n  try {\n    // Thử chuyển đổi từ hex trước\n    credentialIdBuffer = Buffer.from(credentialId, 'hex');\n  } catch (error) {\n    console.error(\"Lỗi khi parse credentialId:\", error);\n    // Sử dụng chuỗi UTF-8 nếu không phải là hex\n    credentialIdBuffer = Buffer.from(credentialId, 'utf-8');\n  }\n\n  // Nếu có credentialId cụ thể và không cho phép empty, chỉ sử dụng credential đó\n  if (credentialId && !allowEmpty) {\n    options.allowCredentials = [{\n      id: credentialIdBuffer,\n      type: 'public-key',\n      // Thêm transports nếu có thể để cải thiện trải nghiệm\n      transports: ['internal', 'hybrid']\n    }];\n  } else {\n    // Nếu allowEmpty = true hoặc không có credentialId, tạo danh sách tất cả credentials đã lưu\n    try {\n      const credentialsListStr = localStorage.getItem('webauthnCredentials');\n      if (credentialsListStr) {\n        const credentialsList = JSON.parse(credentialsListStr);\n        if (Array.isArray(credentialsList) && credentialsList.length > 0) {\n          // Giới hạn số lượng credentials không vượt quá 64 (giới hạn của WebAuthn)\n          const limitedCredentialsList = credentialsList.slice(0, 64);\n          options.allowCredentials = limitedCredentialsList.map(cred => ({\n            id: Buffer.from(cred.credentialId, 'hex'),\n            type: 'public-key',\n            // Thêm transports để cải thiện trải nghiệm\n            transports: ['internal', 'hybrid']\n          }));\n          console.log(`Hiển thị danh sách ${limitedCredentialsList.length} credentials (giới hạn 64) từ tổng số ${credentialsList.length} credentials đã lưu`);\n\n          // Nếu phải giới hạn, hiển thị thông báo\n          if (credentialsList.length > 64) {\n            console.warn(`Đã giới hạn danh sách credentials xuống 64 từ tổng số ${credentialsList.length}`);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Lỗi khi đọc danh sách credentials:\", error);\n    }\n  }\n  try {\n    console.log(\"Đang hiển thị hộp thoại xác thực WebAuthn...\");\n    console.log(\"Vui lòng chọn credential từ danh sách hoặc xác thực bằng sinh trắc học\");\n    const assertion = await navigator.credentials.get({\n      publicKey: options,\n      // Thêm mediation để khuyến khích hiển thị danh sách\n      mediation: 'optional'\n    });\n    const response = assertion.response;\n    console.log(\"Đã nhận được chữ ký WebAuthn:\", response);\n    return {\n      signature: new Uint8Array(response.signature),\n      authenticatorData: new Uint8Array(response.authenticatorData),\n      clientDataJSON: new Uint8Array(response.clientDataJSON)\n    };\n  } catch (error) {\n    console.error('Lỗi khi xác thực WebAuthn:', error);\n    throw error;\n  }\n};\n\n/**\n * Lưu thông tin credential vào localStorage\n */\nfunction saveCredentialInfo(walletAddress, credentialId, publicKey, userId, displayName) {\n  try {\n    // Chuẩn bị thông tin credential để lưu\n    const credentialInfo = {\n      walletAddress,\n      credentialId,\n      publicKey,\n      userId: Array.from(userId),\n      // Chuyển Uint8Array thành Array để có thể serialize\n      displayName,\n      createdAt: new Date().toISOString()\n    };\n\n    // Lưu vào danh sách credentials\n    let credentialsList = [];\n    try {\n      const credentialsListStr = localStorage.getItem('webauthnCredentials');\n      if (credentialsListStr) {\n        credentialsList = JSON.parse(credentialsListStr);\n      }\n    } catch (storageError) {\n      console.warn(\"Không thể đọc credentials từ localStorage:\", storageError);\n      // Tiếp tục với mảng rỗng\n    }\n\n    // Thêm credential mới vào danh sách\n    credentialsList.push(credentialInfo);\n    try {\n      localStorage.setItem('webauthnCredentials', JSON.stringify(credentialsList));\n      console.log(\"Đã lưu thông tin credential mới:\", credentialInfo);\n    } catch (saveError) {\n      console.error(\"Không thể lưu credentials vào localStorage:\", saveError);\n      // Không ngăn luồng hoạt động ngay cả khi không thể lưu\n    }\n  } catch (error) {\n    console.error(\"Lỗi khi xử lý thông tin credential:\", error);\n  }\n}\n;\n\n/**\n * Xác thực để đăng nhập bằng WebAuthn với credential ID đã biết\n */\nexport const getWebAuthnAssertionForLogin = async (credentialIdBase64, allowEmpty = false) => {\n  try {\n    if (!isWebAuthnSupported()) {\n      throw new Error('WebAuthn không được hỗ trợ trên trình duyệt này');\n    }\n    const challenge = new Uint8Array(32);\n    crypto.getRandomValues(challenge);\n\n    // Tạo options cho get assertion\n    const options = {\n      challenge: challenge,\n      timeout: 60000,\n      userVerification: 'preferred'\n    };\n\n    // Nếu có credential ID, thêm vào allowCredentials\n    if (credentialIdBase64) {\n      const credentialIdBuffer = new Uint8Array(Buffer.from(credentialIdBase64, 'base64'));\n      console.log(\"Đang đăng nhập với credential ID:\", credentialIdBase64);\n      options.allowCredentials = [{\n        id: credentialIdBuffer,\n        type: 'public-key'\n      }];\n    } else if (!allowEmpty) {\n      throw new Error('Credential ID không được cung cấp');\n    }\n\n    // Nếu không có credential ID và allowEmpty = true, \n    // có thể trình duyệt sẽ hiển thị tất cả credentials có sẵn\n\n    console.log(\"Đang yêu cầu xác thực WebAuthn với options:\", options);\n    const assertion = await navigator.credentials.get({\n      publicKey: options\n    });\n    if (!assertion) {\n      throw new Error('Không thể lấy thông tin xác thực WebAuthn');\n    }\n    console.log(\"Xác thực WebAuthn thành công:\", assertion);\n    return {\n      success: true,\n      rawId: new Uint8Array(assertion.rawId)\n    };\n  } catch (error) {\n    console.error('Lỗi khi xác thực WebAuthn:', error);\n    return {\n      success: false,\n      error: error.message || 'Không thể xác thực'\n    };\n  }\n};\n\n/**\n * Lấy thông tin Multisig PDA dựa trên credential ID\n */\nexport const calculateMultisigAddress = (programId, credentialId) => {\n  // Sử dụng hàm processCredentialIdForPDA từ helpers.ts để đảm bảo tính nhất quán\n  const seedBuffer = processCredentialIdForPDA(credentialId);\n  return PublicKey.findProgramAddressSync([Buffer.from(\"multisig\"), seedBuffer], programId);\n};","map":{"version":3,"names":["bufferToHex","CBOR","PublicKey","processCredentialIdForPDA","createWebAuthnCredential","walletAddress","walletName","isWebAuthnSupported","Error","challenge","Uint8Array","crypto","getRandomValues","userId","walletDisplayName","slice","console","log","options","rp","name","id","window","location","hostname","user","displayName","pubKeyCredParams","type","alg","authenticatorSelection","authenticatorAttachment","userVerification","requireResidentKey","timeout","attestation","credential","navigator","credentials","create","publicKey","response","attestationBuffer","attestationObject","decode","buffer","credentialId","rawId","authData","publicKeyBytes","extractPublicKeyFromAuthData","saveCredentialInfo","error","offset","credentialIdLength","cosePublicKey","publicKeyObj","x","get","y","uncompressedKey","set","e","dummyKey","randomX","randomY","getWebAuthnCredential","finalChallenge","allowCredentials","assertion","signature","authenticatorData","clientDataJSON","PublicKeyCredential","undefined","checkWebAuthnCompatibility","isUserVerifyingPlatformAuthenticatorAvailable","available","errorMessage","message","String","verifyWebAuthnSignature","pubkey","length","toString","warn","newPubkey","Buffer","alloc","copyBuffer","Math","min","clientDataObj","JSON","parse","TextDecoder","clientDataHash","subtle","digest","hashData","verificationData","from","spkiKey","convertRawToSPKI","cryptoKey","importKey","namedCurve","result","verify","hash","rawSignature","derSignature","convertedSignature","derToRaw","alternativeError","bufferToUint8Array","source","target","targetStart","sourceStart","sourceEnd","sourceView","byteOffset","targetView","rawKey","newRawKey","spkiHeader","rawKeySlice","spkiBuffer","rLen","r","sLen","s","rPadded","sPadded","padding","validatePublicKey","publicKeyHex","getWebAuthnAssertion","allowEmpty","msgBytes","TextEncoder","encode","msgHash","rpId","credentialIdBuffer","transports","credentialsListStr","localStorage","getItem","credentialsList","Array","isArray","limitedCredentialsList","map","cred","mediation","credentialInfo","createdAt","Date","toISOString","storageError","push","setItem","stringify","saveError","getWebAuthnAssertionForLogin","credentialIdBase64","success","calculateMultisigAddress","programId","seedBuffer","findProgramAddressSync"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/frontend_test/src/utils/webauthnUtils.ts"],"sourcesContent":["import { bufferToHex } from './bufferUtils';\nimport * as CBOR from 'cbor-web';\nimport { PublicKey } from '@solana/web3.js';\nimport { processCredentialIdForPDA } from './helpers';\n\n/**\n * Tạo WebAuthn credential mới\n */\nexport const createWebAuthnCredential = async (\n  walletAddress: string,\n  walletName?: string\n): Promise<{credentialId: string, publicKey: string, rawId: Uint8Array}> => {\n  try {\n    if (!isWebAuthnSupported()) {\n      throw new Error('WebAuthn không được hỗ trợ trên trình duyệt này');\n    }\n\n    // Tạo challenge ngẫu nhiên\n    const challenge = new Uint8Array(32);\n    crypto.getRandomValues(challenge);\n    \n    // Tạo userID ngẫu nhiên cho mỗi ví để tránh ghi đè credentials\n    const userId = new Uint8Array(16);\n    crypto.getRandomValues(userId);\n    \n    // Đảm bảo có tên ví (quan trọng cho hiển thị trên hộp thoại trình duyệt)\n    const walletDisplayName = walletName || `Moon Wallet ${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`;\n    \n    console.log(`Tạo credential với tên: \"${walletDisplayName}\"`);\n    \n    // Tạo options cho credential creation\n    const options: PublicKeyCredentialCreationOptions = {\n      challenge: challenge,\n      rp: {\n        name: 'Moon Wallet',\n        id: window.location.hostname\n      },\n      user: {\n        id: userId,\n        name: walletDisplayName, // Sử dụng walletDisplayName cho cả name\n        displayName: walletDisplayName // Và displayName\n      },\n      pubKeyCredParams: [\n        { type: 'public-key', alg: -7 }, // ES256\n        { type: 'public-key', alg: -257 } // RS256\n      ],\n      authenticatorSelection: {\n        authenticatorAttachment: 'platform',\n        userVerification: 'preferred', \n        requireResidentKey: true // ĐẶT thành TRUE để ép buộc lưu tên\n      },\n      timeout: 60000,\n      attestation: 'direct' // Thay đổi từ 'none' sang 'direct' để có thêm thông tin\n    };\n\n    console.log(\"Đang yêu cầu tạo credential với options:\", options);\n    \n    const credential = await navigator.credentials.create({\n      publicKey: options\n    }) as PublicKeyCredential;\n\n    if (!credential) {\n      throw new Error('Không thể tạo khóa WebAuthn');\n    }\n\n    console.log(\"Credential đã được tạo:\", credential);\n    \n    const response = credential.response as AuthenticatorAttestationResponse;\n    \n    // Phân tích attestationObject để lấy public key\n    const attestationBuffer = new Uint8Array(response.attestationObject);\n    const attestationObject = CBOR.decode(attestationBuffer.buffer);\n    \n    // Lấy thông tin credentialId\n    const credentialId = bufferToHex(credential.rawId);\n    console.log(\"Raw credential ID buffer:\", new Uint8Array(credential.rawId));\n    console.log(\"Credentials raw ID as hex:\", credentialId);\n    \n    // Phân tích authenticatorData để lấy public key\n    const authData = attestationObject.authData;\n    const publicKeyBytes = extractPublicKeyFromAuthData(authData);\n    const publicKey = bufferToHex(publicKeyBytes);\n    \n    // Lưu thông tin credential vào indexedDB/localStorage để sử dụng sau này\n    saveCredentialInfo(walletAddress, credentialId, publicKey, userId, walletDisplayName);\n    \n    return {\n      credentialId,\n      publicKey,\n      rawId: new Uint8Array(credential.rawId)\n    };\n  } catch (error) {\n    console.error('Lỗi khi tạo WebAuthn credential:', error);\n    throw error;\n  }\n};\n\n/**\n * Trích xuất public key từ authenticator data\n */\nfunction extractPublicKeyFromAuthData(authData: Uint8Array): Uint8Array {\n  // Theo WebAuthn spec, bố cục của authenticator data:\n  // [32 bytes RP ID hash, 1 byte flags, 4 bytes counter, variable length AAGUID, variable length credential ID, variable length COSE public key]\n  \n  // Bỏ qua 32 bytes cho RP ID hash + 1 byte flags + 4 bytes counter = 37 bytes\n  let offset = 37;\n  \n  // Bỏ qua AAGUID (16 bytes)\n  offset += 16;\n  \n  // Đọc độ dài credential ID (2 bytes)\n  const credentialIdLength = (authData[offset] << 8) | authData[offset + 1];\n  offset += 2;\n  \n  // Bỏ qua credential ID\n  offset += credentialIdLength;\n  \n  // Đọc COSE public key\n  const cosePublicKey = authData.slice(offset);\n  \n  try {\n    // Giải mã COSE public key (sử dụng thư viện CBOR nếu có)\n    const publicKeyObj = CBOR.decode(cosePublicKey);\n    \n    // Lấy coordinaates x và y từ -2 và -3 (theo COSE Web Key)\n    const x = publicKeyObj.get(-2);\n    const y = publicKeyObj.get(-3);\n    \n    // Tạo uncompressed EC public key (0x04 || x || y)\n    const uncompressedKey = new Uint8Array(65);\n    uncompressedKey[0] = 0x04; // Uncompressed point format\n    uncompressedKey.set(new Uint8Array(x), 1);\n    uncompressedKey.set(new Uint8Array(y), 33);\n    \n    return uncompressedKey;\n  } catch (e) {\n    console.error(\"Lỗi khi trích xuất public key:\", e);\n    \n    // Trả về dummy key nếu không thể trích xuất\n    const dummyKey = new Uint8Array(65);\n    dummyKey[0] = 0x04;\n    const randomX = new Uint8Array(32);\n    const randomY = new Uint8Array(32);\n    window.crypto.getRandomValues(randomX);\n    window.crypto.getRandomValues(randomY);\n    dummyKey.set(randomX, 1);\n    dummyKey.set(randomY, 33);\n    \n    return dummyKey;\n  }\n}\n\n/**\n * Sử dụng WebAuthn credential đã có\n */\nexport const getWebAuthnCredential = async (\n  credentialId: Buffer,\n  challenge?: Uint8Array\n): Promise<{ \n  signature: Uint8Array; \n  authenticatorData: Uint8Array;\n  clientDataJSON: Uint8Array;\n}> => {\n  if (!isWebAuthnSupported()) {\n    throw new Error('WebAuthn không được hỗ trợ trên trình duyệt này');\n  }\n\n  // Sử dụng challenge được cung cấp hoặc tạo mới nếu không có\n  const finalChallenge = challenge || crypto.getRandomValues(new Uint8Array(32));\n  \n  // Tạo options cho get assertion\n  const options: PublicKeyCredentialRequestOptions = {\n    challenge: finalChallenge,\n    allowCredentials: [{\n      id: credentialId,\n      type: 'public-key',\n    }],\n    userVerification: 'preferred',\n    timeout: 60000\n  };\n\n  try {\n    const assertion = await navigator.credentials.get({\n      publicKey: options\n    }) as PublicKeyCredential;\n\n    const response = assertion.response as AuthenticatorAssertionResponse;\n    \n    return {\n      signature: new Uint8Array(response.signature),\n      authenticatorData: new Uint8Array(response.authenticatorData),\n      clientDataJSON: new Uint8Array(response.clientDataJSON)\n    };\n  } catch (error) {\n    console.error('Lỗi khi xác thực WebAuthn:', error);\n    throw error;\n  }\n};\n\n/**\n * Kiểm tra xem WebAuthn có được hỗ trợ không\n */\nexport const isWebAuthnSupported = (): boolean => {\n  return window.PublicKeyCredential !== undefined && \n         typeof window.PublicKeyCredential === 'function';\n};\n\n// Chạy thử một số tùy chọn để kiểm tra khả năng tương thích\nexport const checkWebAuthnCompatibility = async (): Promise<string> => {\n  if (!isWebAuthnSupported()) {\n    return 'WebAuthn không được hỗ trợ trên trình duyệt này';\n  }\n  \n  try {\n    // Kiểm tra xem trình duyệt có hỗ trợ thuộc tính \"isUserVerifyingPlatformAuthenticatorAvailable\"\n    if (PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable) {\n      const available = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n      if (!available) {\n        return 'Thiết bị này không có xác thực sinh trắc học được hỗ trợ';\n      }\n    }\n    \n    return 'WebAuthn được hỗ trợ đầy đủ';\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    return `Lỗi khi kiểm tra WebAuthn: ${errorMessage}`;\n  }\n};\n\n/**\n * Xác minh chữ ký WebAuthn trong frontend\n */\nexport const verifyWebAuthnSignature = async (\n  pubkey: Buffer,\n  signature: Uint8Array,\n  authenticatorData: Uint8Array,\n  clientDataJSON: Uint8Array\n): Promise<boolean> => {\n  try {\n    // Kiểm tra các tham số đầu vào\n    if (!pubkey || !signature || !authenticatorData || !clientDataJSON) {\n      console.error('Thiếu tham số cần thiết cho xác minh WebAuthn');\n      return false;\n    }\n    \n    console.log(\"Public key length:\", pubkey.length);\n    console.log(\"Pubkey:\", pubkey.toString('hex'));\n    \n    // Kiểm tra độ dài khóa\n    if (pubkey.length !== 65) {\n      console.warn(`Khóa WebAuthn không đúng độ dài: ${pubkey.length} (cần 65 byte)`);\n      \n      // Tạo khóa mới với độ dài đúng\n      const newPubkey = Buffer.alloc(65);\n      copyBuffer(pubkey, newPubkey, 0, 0, Math.min(pubkey.length, 65));\n      \n      // Nếu byte đầu tiên không phải 0x04, sửa lại\n      if (newPubkey[0] !== 0x04) {\n        newPubkey[0] = 0x04;\n      }\n      \n      pubkey = newPubkey;\n      console.log('Pubkey sau khi sửa độ dài:', pubkey.toString('hex'));\n    }\n    \n    // Kiểm tra định dạng khóa (phải bắt đầu bằng 0x04)\n    if (pubkey[0] !== 0x04) {\n      console.warn(`Khóa WebAuthn không bắt đầu bằng 0x04: ${pubkey[0].toString(16)}`);\n      // Tạo khóa mới với byte đầu tiên là 0x04\n      const newPubkey = Buffer.alloc(65);\n      newPubkey[0] = 0x04;\n      copyBuffer(pubkey, newPubkey, 1, 1, 65);\n      pubkey = newPubkey;\n      console.log('Pubkey sau khi sửa byte đầu:', pubkey.toString('hex'));\n    }\n    \n    // 1. Parse clientDataJSON\n    const clientDataObj = JSON.parse(new TextDecoder().decode(clientDataJSON));\n    console.log(\"Client data:\", clientDataObj);\n    \n    // 2. Lấy hash của clientDataJSON\n    const clientDataHash = await crypto.subtle.digest('SHA-256', clientDataJSON);\n    \n    // 3. Kết hợp dữ liệu để xác minh\n    const authData = new Uint8Array(authenticatorData);\n    const hashData = new Uint8Array(clientDataHash);\n    const verificationData = new Uint8Array(authData.length + hashData.length);\n    verificationData.set(authData, 0);\n    verificationData.set(hashData, authData.length);\n    \n    console.log(\"Dữ liệu xác minh:\", Buffer.from(verificationData).toString('hex'));\n    console.log(\"Pubkey cuối cùng:\", pubkey.toString('hex'));\n    console.log(\"Signature:\", Buffer.from(signature).toString('hex'));\n    console.log(\"Signature length:\", signature.length);\n    \n    try {\n      // 4. Chuyển đổi khóa công khai sang định dạng SPKI\n      const spkiKey = convertRawToSPKI(pubkey);\n      \n      // 5. Import khóa công khai\n      const cryptoKey = await crypto.subtle.importKey(\n        'spki',\n        spkiKey,\n        {\n          name: 'ECDSA',\n          namedCurve: 'P-256'\n        },\n        false,\n        ['verify']\n      );\n      \n      // 6. Xác minh chữ ký\n      const result = await crypto.subtle.verify(\n        {\n          name: 'ECDSA',\n          hash: 'SHA-256'\n        },\n        cryptoKey,\n        signature,\n        verificationData\n      );\n      \n      console.log('Kết quả xác minh:', result);\n      return result;\n    } catch (e) {\n      console.error(\"Lỗi khi xác thực chữ ký:\", e);\n      \n      // Thử với cách khác nếu cách đầu tiên thất bại\n      try {\n        console.log('Thử phương pháp xác minh thay thế...');\n        \n        // Chuyển đổi chữ ký từ DER sang raw nếu cần\n        let rawSignature = signature;\n        if (signature.length > 64 && signature[0] === 0x30) {\n          console.log('Phát hiện chữ ký DER, đang chuyển đổi...');\n          const derSignature = Buffer.from(signature);\n          const convertedSignature = derToRaw(derSignature);\n          rawSignature = convertedSignature;\n          console.log('Chữ ký sau khi chuyển đổi:', Buffer.from(rawSignature).toString('hex'));\n        }\n        \n        // Import khóa và xác minh lại\n        const spkiKey = convertRawToSPKI(pubkey);\n        const cryptoKey = await crypto.subtle.importKey(\n          'spki',\n          spkiKey,\n          {\n            name: 'ECDSA',\n            namedCurve: 'P-256'\n          },\n          false,\n          ['verify']\n        );\n        \n        const result = await crypto.subtle.verify(\n          {\n            name: 'ECDSA',\n            hash: 'SHA-256'\n          },\n          cryptoKey,\n          rawSignature,\n          verificationData\n        );\n        \n        console.log('Kết quả xác minh thay thế:', result);\n        return result;\n      } catch (alternativeError) {\n        console.error('Lỗi khi thử phương pháp thay thế:', alternativeError);\n        return false;\n      }\n    }\n  } catch (error) {\n    console.error('Lỗi khi xác minh chữ ký WebAuthn:', error);\n    return false;\n  }\n};\n\n// Hàm tiện ích để chuyển đổi Buffer sang Uint8Array phù hợp với yêu cầu\nfunction bufferToUint8Array(buffer: Buffer): Uint8Array {\n  // Tạo một Uint8Array mới từ Buffer để tránh các vấn đề về tương thích\n  return new Uint8Array(buffer);\n}\n\n// Sửa lại hàm copy để tránh lỗi về type\nfunction copyBuffer(source: Buffer, target: Buffer, targetStart = 0, sourceStart = 0, sourceEnd = source.length): void {\n  // Tạo view mới từ source buffer\n  const sourceView = new Uint8Array(source.buffer, source.byteOffset + sourceStart, Math.min(sourceEnd, source.length) - sourceStart);\n  // Tạo view mới từ target buffer\n  const targetView = new Uint8Array(target.buffer, target.byteOffset + targetStart, target.length - targetStart);\n  // Copy giữa các Uint8Array\n  targetView.set(sourceView.slice(0, Math.min(sourceView.length, targetView.length)));\n}\n\n// Hàm chuyển đổi khóa từ định dạng raw sang SPKI\nconst convertRawToSPKI = (rawKey: Buffer): ArrayBuffer => {\n  try {\n    // Đảm bảo khóa bắt đầu bằng 0x04\n    if (rawKey[0] !== 0x04) {\n      console.warn('Khóa không bắt đầu bằng 0x04, đang sửa...');\n      // Tạo khóa mới với byte đầu tiên là 0x04\n      const newRawKey = Buffer.alloc(65);\n      newRawKey[0] = 0x04;\n      // Sao chép phần còn lại của khóa\n      if (rawKey.length >= 64) {\n        copyBuffer(rawKey, newRawKey, 1, 1, 65);\n      } else {\n        copyBuffer(rawKey, newRawKey, 1, 0, Math.min(rawKey.length, 64));\n      }\n      rawKey = newRawKey;\n    }\n    \n    // Tạo SPKI header\n    const spkiHeader = Buffer.from('3059301306072a8648ce3d020106082a8648ce3d030107034200', 'hex');\n    \n    // Nối header với khóa (bỏ byte đầu tiên 0x04)\n    const rawKeySlice = new Uint8Array(rawKey.buffer, rawKey.byteOffset + 1, rawKey.length - 1);\n    const spkiBuffer = new Uint8Array(spkiHeader.length + rawKeySlice.length);\n    spkiBuffer.set(new Uint8Array(spkiHeader), 0);\n    spkiBuffer.set(rawKeySlice, spkiHeader.length);\n    \n    // Trả về ArrayBuffer\n    return spkiBuffer.buffer.slice(0); // .slice(0) đảm bảo trả về ArrayBuffer thay vì ArrayBufferLike\n  } catch (error) {\n    console.error('Lỗi khi chuyển đổi khóa:', error);\n    throw error;\n  }\n};\n\n// Hàm chuyển đổi chữ ký từ DER sang raw\nconst derToRaw = (signature: Buffer): Uint8Array => {\n  try {\n    // DER format: 30 + len + 02 + r_len + r + 02 + s_len + s\n    let offset = 2; // Skip 30 + len\n    \n    // Read r\n    if (signature[offset] !== 0x02) {\n      throw new Error('Định dạng DER không hợp lệ: không tìm thấy marker r');\n    }\n    offset++; // Skip 02\n    \n    const rLen = signature[offset++];\n    let r = signature.slice(offset, offset + rLen);\n    offset += rLen;\n    \n    // Read s\n    if (signature[offset] !== 0x02) {\n      throw new Error('Định dạng DER không hợp lệ: không tìm thấy marker s');\n    }\n    offset++; // Skip 02\n    \n    const sLen = signature[offset++];\n    let s = signature.slice(offset, offset + sLen);\n    \n    // Pad r and s to 32 bytes\n    let rPadded, sPadded;\n    \n    if (r.length < 32) {\n      const padding = Buffer.alloc(32 - r.length, 0);\n      rPadded = new Uint8Array(32);\n      rPadded.set(new Uint8Array(padding), 0);\n      rPadded.set(new Uint8Array(r), padding.length);\n    } else if (r.length > 32) {\n      rPadded = new Uint8Array(r.buffer, r.byteOffset + r.length - 32, 32);\n    } else {\n      rPadded = new Uint8Array(r);\n    }\n    \n    if (s.length < 32) {\n      const padding = Buffer.alloc(32 - s.length, 0);\n      sPadded = new Uint8Array(32);\n      sPadded.set(new Uint8Array(padding), 0);\n      sPadded.set(new Uint8Array(s), padding.length);\n    } else if (s.length > 32) {\n      sPadded = new Uint8Array(s.buffer, s.byteOffset + s.length - 32, 32);\n    } else {\n      sPadded = new Uint8Array(s);\n    }\n    \n    // Concatenate r and s\n    const result = new Uint8Array(64);\n    result.set(rPadded, 0);\n    result.set(sPadded, 32);\n    \n    return result;\n  } catch (error) {\n    console.error('Lỗi khi chuyển đổi chữ ký DER sang raw:', error);\n    throw error;\n  }\n};\n\n/**\n * Kiểm tra xem public key có đúng định dạng không\n */\nexport const validatePublicKey = (publicKeyHex: string): boolean => {\n  try {\n    const pubkey = Buffer.from(publicKeyHex, 'hex');\n    // Public key không nén phải là 65 bytes (1 byte header + 32 bytes x + 32 bytes y)\n    if (pubkey.length !== 65) {\n      console.error(`Public key không đúng độ dài: ${pubkey.length} bytes (mong đợi 65 bytes)`);\n      return false;\n    }\n    \n    // Byte đầu tiên phải là 0x04 (định dạng không nén)\n    if (pubkey[0] !== 0x04) {\n      console.error(`Public key không phải định dạng không nén: byte đầu tiên là ${pubkey[0].toString(16)} (mong đợi 0x04)`);\n      return false;\n    }\n    \n    console.log(\"Public key hợp lệ\");\n    return true;\n  } catch (error) {\n    console.error(\"Lỗi khi xác thực public key:\", error);\n    return false;\n  }\n};\n\n/**\n * Lấy WebAuthn assertion từ credential đã có\n */\nexport const getWebAuthnAssertion = async (credentialId: string, message?: string, allowEmpty: boolean = false): Promise<{ \n  signature: Uint8Array; \n  authenticatorData: Uint8Array;\n  clientDataJSON: Uint8Array;\n}> => {\n  if (!isWebAuthnSupported()) {\n    throw new Error('WebAuthn không được hỗ trợ trên trình duyệt này');\n  }\n\n  // Tạo challenge từ message hoặc ngẫu nhiên nếu không có message\n  let challenge: Uint8Array;\n  if (message) {\n    // Nếu có message, sử dụng hash của message làm challenge\n    const msgBytes = new TextEncoder().encode(message);\n    const msgHash = await crypto.subtle.digest('SHA-256', msgBytes);\n    challenge = new Uint8Array(msgHash);\n    console.log(\"Sử dụng message để tạo challenge:\", message);\n  } else {\n    // Nếu không, tạo challenge ngẫu nhiên\n    challenge = new Uint8Array(32);\n    crypto.getRandomValues(challenge);\n  }\n  \n  console.log(\"Challenge:\", Buffer.from(challenge).toString('hex'));\n  \n  // Tạo options cho get assertion\n  const options: PublicKeyCredentialRequestOptions = {\n    challenge: challenge,\n    rpId: window.location.hostname,\n    timeout: 60000,\n    // Thay đổi userVerification từ 'preferred' thành 'discouraged' để ưu tiên hiển thị danh sách credentials\n    userVerification: 'discouraged'\n  };\n  \n  // Xử lý credentialId - chuyển từ hex sang buffer\n  let credentialIdBuffer: Buffer;\n  try {\n    // Thử chuyển đổi từ hex trước\n    credentialIdBuffer = Buffer.from(credentialId, 'hex');\n  } catch (error) {\n    console.error(\"Lỗi khi parse credentialId:\", error);\n    // Sử dụng chuỗi UTF-8 nếu không phải là hex\n    credentialIdBuffer = Buffer.from(credentialId, 'utf-8');\n  }\n  \n  // Nếu có credentialId cụ thể và không cho phép empty, chỉ sử dụng credential đó\n  if (credentialId && !allowEmpty) {\n    options.allowCredentials = [{\n      id: credentialIdBuffer,\n      type: 'public-key',\n      // Thêm transports nếu có thể để cải thiện trải nghiệm\n      transports: ['internal', 'hybrid']\n    }];\n  } else {\n    // Nếu allowEmpty = true hoặc không có credentialId, tạo danh sách tất cả credentials đã lưu\n    try {\n      const credentialsListStr = localStorage.getItem('webauthnCredentials');\n      if (credentialsListStr) {\n        const credentialsList = JSON.parse(credentialsListStr);\n        if (Array.isArray(credentialsList) && credentialsList.length > 0) {\n          // Giới hạn số lượng credentials không vượt quá 64 (giới hạn của WebAuthn)\n          const limitedCredentialsList = credentialsList.slice(0, 64);\n          \n          options.allowCredentials = limitedCredentialsList.map(cred => ({\n            id: Buffer.from(cred.credentialId, 'hex'),\n            type: 'public-key' as PublicKeyCredentialType,\n            // Thêm transports để cải thiện trải nghiệm\n            transports: ['internal', 'hybrid']\n          }));\n          \n          console.log(`Hiển thị danh sách ${limitedCredentialsList.length} credentials (giới hạn 64) từ tổng số ${credentialsList.length} credentials đã lưu`);\n          \n          // Nếu phải giới hạn, hiển thị thông báo\n          if (credentialsList.length > 64) {\n            console.warn(`Đã giới hạn danh sách credentials xuống 64 từ tổng số ${credentialsList.length}`);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Lỗi khi đọc danh sách credentials:\", error);\n    }\n  }\n\n  try {\n    console.log(\"Đang hiển thị hộp thoại xác thực WebAuthn...\");\n    console.log(\"Vui lòng chọn credential từ danh sách hoặc xác thực bằng sinh trắc học\");\n    \n    const assertion = await navigator.credentials.get({\n      publicKey: options,\n      // Thêm mediation để khuyến khích hiển thị danh sách\n      mediation: 'optional'\n    }) as PublicKeyCredential;\n\n    const response = assertion.response as AuthenticatorAssertionResponse;\n    \n    console.log(\"Đã nhận được chữ ký WebAuthn:\", response);\n    \n    return {\n      signature: new Uint8Array(response.signature),\n      authenticatorData: new Uint8Array(response.authenticatorData),\n      clientDataJSON: new Uint8Array(response.clientDataJSON)\n    };\n  } catch (error) {\n    console.error('Lỗi khi xác thực WebAuthn:', error);\n    throw error;\n  }\n};\n\n/**\n * Lưu thông tin credential vào localStorage\n */\nfunction saveCredentialInfo(\n  walletAddress: string,\n  credentialId: string,\n  publicKey: string,\n  userId: Uint8Array,\n  displayName: string\n): void {\n  try {\n    // Chuẩn bị thông tin credential để lưu\n    const credentialInfo = {\n      walletAddress,\n      credentialId,\n      publicKey,\n      userId: Array.from(userId), // Chuyển Uint8Array thành Array để có thể serialize\n      displayName,\n      createdAt: new Date().toISOString()\n    };\n    \n    // Lưu vào danh sách credentials\n    let credentialsList = [];\n    try {\n      const credentialsListStr = localStorage.getItem('webauthnCredentials');\n      if (credentialsListStr) {\n        credentialsList = JSON.parse(credentialsListStr);\n      }\n    } catch (storageError) {\n      console.warn(\"Không thể đọc credentials từ localStorage:\", storageError);\n      // Tiếp tục với mảng rỗng\n    }\n    \n    // Thêm credential mới vào danh sách\n    credentialsList.push(credentialInfo);\n    \n    try {\n      localStorage.setItem('webauthnCredentials', JSON.stringify(credentialsList));\n      console.log(\"Đã lưu thông tin credential mới:\", credentialInfo);\n    } catch (saveError) {\n      console.error(\"Không thể lưu credentials vào localStorage:\", saveError);\n      // Không ngăn luồng hoạt động ngay cả khi không thể lưu\n    }\n  } catch (error) {\n    console.error(\"Lỗi khi xử lý thông tin credential:\", error);\n  }\n};\n\n/**\n * Xác thực để đăng nhập bằng WebAuthn với credential ID đã biết\n */\nexport const getWebAuthnAssertionForLogin = async (\n  credentialIdBase64: string,\n  allowEmpty: boolean = false\n): Promise<{\n  success: boolean;\n  rawId?: Uint8Array;\n  error?: string;\n}> => {\n  try {\n    if (!isWebAuthnSupported()) {\n      throw new Error('WebAuthn không được hỗ trợ trên trình duyệt này');\n    }\n\n    const challenge = new Uint8Array(32);\n    crypto.getRandomValues(challenge);\n\n    // Tạo options cho get assertion\n    const options: PublicKeyCredentialRequestOptions = {\n      challenge: challenge,\n      timeout: 60000,\n      userVerification: 'preferred',\n    };\n\n    // Nếu có credential ID, thêm vào allowCredentials\n    if (credentialIdBase64) {\n      const credentialIdBuffer = new Uint8Array(Buffer.from(credentialIdBase64, 'base64'));\n      console.log(\"Đang đăng nhập với credential ID:\", credentialIdBase64);\n      options.allowCredentials = [{\n        id: credentialIdBuffer,\n        type: 'public-key',\n      }];\n    } else if (!allowEmpty) {\n      throw new Error('Credential ID không được cung cấp');\n    }\n\n    // Nếu không có credential ID và allowEmpty = true, \n    // có thể trình duyệt sẽ hiển thị tất cả credentials có sẵn\n\n    console.log(\"Đang yêu cầu xác thực WebAuthn với options:\", options);\n    \n    const assertion = await navigator.credentials.get({\n      publicKey: options\n    }) as PublicKeyCredential;\n\n    if (!assertion) {\n      throw new Error('Không thể lấy thông tin xác thực WebAuthn');\n    }\n\n    console.log(\"Xác thực WebAuthn thành công:\", assertion);\n    \n    return {\n      success: true,\n      rawId: new Uint8Array(assertion.rawId)\n    };\n  } catch (error: any) {\n    console.error('Lỗi khi xác thực WebAuthn:', error);\n    return {\n      success: false,\n      error: error.message || 'Không thể xác thực'\n    };\n  }\n};\n\n/**\n * Lấy thông tin Multisig PDA dựa trên credential ID\n */\nexport const calculateMultisigAddress = (\n  programId: PublicKey, \n  credentialId: string\n): [PublicKey, number] => {\n  // Sử dụng hàm processCredentialIdForPDA từ helpers.ts để đảm bảo tính nhất quán\n  const seedBuffer = processCredentialIdForPDA(credentialId);\n  \n  return PublicKey.findProgramAddressSync(\n    [\n      Buffer.from(\"multisig\"),\n      seedBuffer\n    ],\n    programId\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}