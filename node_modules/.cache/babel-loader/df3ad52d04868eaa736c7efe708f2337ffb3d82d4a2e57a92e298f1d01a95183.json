{"ast":null,"code":"var _jsxFileName = \"/Users/tai/Documents/MoonWallet/moonwallet/acacac/src/App.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport { Connection, PublicKey, Keypair, Transaction, SystemProgram, TransactionInstruction, LAMPORTS_PER_SOL, sendAndConfirmTransaction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport './App.css';\nimport { createWebAuthnCredential, getWebAuthnAssertionForLogin, calculateMultisigAddress } from './utils/webauthnUtils';\nimport { processCredentialIdForPDA, getMultisigPDA, getGuardianPDA } from './utils/credentialUtils';\nimport { saveInvitation, getInvitation, getGuardianData, updateGuardianStatus, getPendingInvites, deleteGuardianData } from './firebase/guardianService';\nimport { getWalletByCredentialId } from './firebase/webAuthnService';\nimport Transfer from './components/Transfer';\n\n// Lấy các biến môi trường hoặc sử dụng giá trị mặc định\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst RPC_ENDPOINT = process.env.REACT_APP_RPC_ENDPOINT || 'http://127.0.0.1:8899'; // Localhost validator\nconst PROGRAM_ID_STRING = process.env.REACT_APP_PROGRAM_ID || 'DeN1rBfabZezHPvrq9q7BbzUbZkrjnHE1kQDrPK8kWQ3'; // Program ID mới triển khai\n\n// Địa chỉ Program ID từ smart contract\nexport const PROGRAM_ID = new PublicKey(PROGRAM_ID_STRING);\n\n// Log biến môi trường để debug\nconsole.log(\"Biến môi trường RPC_ENDPOINT:\", process.env.REACT_APP_RPC_ENDPOINT);\nconsole.log(\"Biến môi trường PROGRAM_ID:\", process.env.REACT_APP_PROGRAM_ID);\nconsole.log(\"Biến môi trường FEE_PAYER_SECRET_KEY tồn tại:\", !!process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\nif (process.env.REACT_APP_FEE_PAYER_SECRET_KEY) {\n  console.log(\"Độ dài FEE_PAYER_SECRET_KEY:\", process.env.REACT_APP_FEE_PAYER_SECRET_KEY.split(',').length);\n}\n\n// Tùy chọn kết nối\nconst connectionOptions = {\n  commitment: 'confirmed',\n  confirmTransactionInitialTimeout: 60000,\n  disableRetryOnRateLimit: false,\n  fetch: fetch\n};\n\n// Connection với validator\nconst connection = new Connection(RPC_ENDPOINT, connectionOptions);\n\n// Schema cho các struct của chương trình\nclass ActionParams {\n  constructor(props) {\n    this.amount = void 0;\n    this.destination = void 0;\n    this.tokenMint = void 0;\n    this.amount = props.amount;\n    this.destination = props.destination;\n    this.tokenMint = props.tokenMint;\n  }\n}\n\n// Ví tạm thời đã được tạo và nhận SOL trước đó\nconst TEMP_WALLET_PUBKEY = '9Q8iZnAvCQP3uaDTuYbrvYSRDWB7Kk19u4TS1MDRSStJ';\n\n// Hàm chuyển đổi Buffer sang Uint8Array\nfunction bufferToUint8Array(buffer) {\n  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n}\n\n// Hàm concat cho Uint8Array\nfunction concatUint8Arrays(...arrays) {\n  // Tính tổng độ dài\n  const totalLength = arrays.reduce((acc, arr) => acc + arr.length, 0);\n\n  // Tạo mảng mới với tổng độ dài\n  const result = new Uint8Array(totalLength);\n\n  // Copy dữ liệu vào mảng mới\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\n\n// Hàm chuyển đổi từ BigInt (u64) sang bytes theo thứ tự little-endian\nconst bigIntToLeBytes = (value, bytesLength = 8) => {\n  const result = new Uint8Array(bytesLength);\n  for (let i = 0; i < bytesLength; i++) {\n    result[i] = Number(value >> BigInt(8 * i) & BigInt(0xff));\n  }\n  return result;\n};\n\n// Helper function để tính toán MultisigPDA một cách nhất quán\nconst calculateMultisigPDA = async (programId, credentialId) => {\n  // Sử dụng hàm processCredentialIdForPDA từ helpers.ts để xử lý credential ID\n  // đảm bảo nhất quán với smart contract\n  const seedBuffer = processCredentialIdForPDA(credentialId);\n  console.log(\"Xử lý credential ID:\", credentialId);\n  console.log(\"Seed buffer để tính PDA:\", Buffer.from(seedBuffer).toString('hex'));\n  return PublicKey.findProgramAddressSync([Buffer.from(\"multisig\"), seedBuffer], programId);\n};\n\n// Hàm nén khóa công khai từ dạng uncompressed (65 bytes) sang compressed (33 bytes)\nconst compressPublicKey = uncompressedKey => {\n  // Đảm bảo khóa bắt đầu với byte 0x04 (không nén)\n  if (uncompressedKey[0] !== 0x04 || uncompressedKey.length !== 65) {\n    console.warn('Khóa không đúng định dạng không nén ECDSA, tạo khóa ngẫu nhiên');\n    // Tạo khóa random nếu không đúng định dạng\n    const randomKey = Buffer.alloc(33);\n    randomKey[0] = 0x02; // compressed, y is even\n\n    // Tạo dữ liệu ngẫu nhiên cho 32 bytes còn lại\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n\n    // Sao chép vào buffer\n    for (let i = 0; i < 32; i++) {\n      randomKey[i + 1] = randomBytes[i];\n    }\n    return randomKey;\n  }\n\n  // Lấy tọa độ x và y\n  const x = new Uint8Array(uncompressedKey.slice(1, 33));\n  const y = new Uint8Array(uncompressedKey.slice(33, 65));\n\n  // Tính prefix: 0x02 nếu y chẵn, 0x03 nếu y lẻ\n  const prefix = (y[31] & 1) === 0 ? 0x02 : 0x03;\n\n  // Tạo khóa nén: prefix (1 byte) + x (32 bytes)\n  const compressedKey = Buffer.alloc(33);\n  compressedKey[0] = prefix;\n\n  // Copy x vào compressedKey từ vị trí 1\n  for (let i = 0; i < 32; i++) {\n    compressedKey[i + 1] = x[i];\n  }\n  return compressedKey;\n};\n\n// Hàm hash recovery phrase tại frontend\nconst hashRecoveryPhrase = async phrase => {\n  // Chuyển recovery phrase thành bytes\n  const phraseBytes = new TextEncoder().encode(phrase);\n\n  // Tạo buffer 32 bytes để lưu dữ liệu\n  const inputBytes = new Uint8Array(32);\n\n  // Sao chép dữ liệu từ phrase, đảm bảo không vượt quá 32 bytes\n  inputBytes.set(phraseBytes.slice(0, Math.min(phraseBytes.length, 32)));\n\n  // Hash bằng SHA-256\n  const hashBuffer = await crypto.subtle.digest('SHA-256', inputBytes);\n\n  // Chuyển kết quả thành Uint8Array\n  return new Uint8Array(hashBuffer);\n};\n\n// Chuyển đổi secret key từ chuỗi trong .env thành mảng số\nconst convertSecretKeyStringToUint8Array = secretKeyString => {\n  if (!secretKeyString) {\n    throw new Error('Fee payer secret key không được định nghĩa trong biến môi trường');\n  }\n\n  // Chuyển đổi chuỗi \"1,2,3,...\" thành mảng số\n  const numbers = secretKeyString.split(',').map(s => parseInt(s.trim(), 10));\n\n  // Kiểm tra kích thước hợp lệ (64 bytes cho ed25519)\n  if (numbers.length !== 64 && numbers.length !== 65) {\n    throw new Error(`Secret key phải có 64 hoặc 65 bytes, nhưng có ${numbers.length} bytes`);\n  }\n\n  // Nếu có 65 bytes, bỏ qua byte cuối cùng (thường là checksum)\n  const bytes = numbers.length === 65 ? numbers.slice(0, 64) : numbers;\n  return new Uint8Array(bytes);\n};\n\n// Add this function near the top with other utility functions\nconst hashCredentialId = async credentialId => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(credentialId);\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  return new Uint8Array(hashBuffer);\n};\nfunction App() {\n  _s();\n  const [walletKeypair, setWalletKeypair] = useState(null);\n  const [walletBalance, setWalletBalance] = useState(0);\n  const [multisigAddress, setMultisigAddress] = useState(null);\n  const [threshold, setThreshold] = useState(1);\n  const [guardianName, setGuardianName] = useState('Owner');\n  const [recoveryPhrase, setRecoveryPhrase] = useState('');\n  const [transactionStatus, setTransactionStatus] = useState('');\n  const [guardianPDA, setGuardianPDA] = useState(null);\n  const [isLoadingBalance, setIsLoadingBalance] = useState(false);\n  const [credentialId, setCredentialId] = useState('');\n  const [webauthnPubkey, setWebauthnPubkey] = useState('');\n  const [walletName, setWalletName] = useState('My Moon Wallet');\n  const [isUsingTempWallet, setIsUsingTempWallet] = useState(false);\n  // Thêm state cho new guardian\n  const [newGuardianName, setNewGuardianName] = useState('');\n  const [newRecoveryPhrase, setNewRecoveryPhrase] = useState('');\n  const [existingGuardians, setExistingGuardians] = useState([]); // Lưu các guardian ID đã tồn tại\n  const [showAddGuardianForm, setShowAddGuardianForm] = useState(false);\n  // Thêm state cho fee payer của dự án\n  const [projectFeePayerKeypair, setProjectFeePayerKeypair] = useState(null);\n  const [usingProjectFeePayer, setUsingProjectFeePayer] = useState(true);\n  const [feePayerBalance, setFeePayerBalance] = useState(0);\n  const [isLoadingFeePayerBalance, setIsLoadingFeePayerBalance] = useState(false);\n  // Thêm state cho số dư PDA\n  const [pdaBalance, setPdaBalance] = useState(0);\n  const [isLoadingPdaBalance, setIsLoadingPdaBalance] = useState(false);\n  // Thêm state cho việc chọn guardian ID\n  const [selectedGuardianId, setSelectedGuardianId] = useState(1);\n  // State cho form nạp tiền\n  const [depositAmount, setDepositAmount] = useState(0.1);\n  // State cho form rút tiền\n  const [withdrawAmount, setWithdrawAmount] = useState(0.05);\n  const [recipientAddress, setRecipientAddress] = useState('');\n  // State cho form đăng nhập ví\n  const [loginCredentialId, setLoginCredentialId] = useState('');\n  const [isLoggingIn, setIsLoggingIn] = useState(false);\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [showLoginForm, setShowLoginForm] = useState(false);\n\n  // Thêm state cho chức năng tạo invitation\n  const [inviteLink, setInviteLink] = useState('');\n  const [inviteCode, setInviteCode] = useState('');\n  const [showQRCode, setShowQRCode] = useState(false);\n  const [showInviteInput, setShowInviteInput] = useState(false);\n  const [pendingInvites, setPendingInvites] = useState([]);\n  const [showTransfer, setShowTransfer] = useState(false);\n\n  // Tạo keypair mới khi component được mount\n  useEffect(() => {\n    // Tạo keypair ngẫu nhiên mới cho user\n    const newKeypair = Keypair.generate();\n    setWalletKeypair(newKeypair);\n\n    // Tạo keypair cố định cho dự án để trả phí\n    // Trong môi trường thực tế, bạn có thể lấy keypair này từ server hoặc một nguồn an toàn\n    const projectPayerPrivateKey = convertSecretKeyStringToUint8Array(process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\n\n    // Sử dụng keypair cố định cho fee payer\n    const feePayerKeypair = Keypair.fromSecretKey(projectPayerPrivateKey);\n    setProjectFeePayerKeypair(feePayerKeypair);\n\n    // Load balance cho fee payer\n    loadFeePayerBalance(feePayerKeypair);\n\n    // Không tính PDA ngay vì chưa có credential ID\n    // findMultisigAddress sẽ được gọi sau khi người dùng tạo WebAuthn credential\n  }, []);\n\n  // Thêm hàm để load balance của fee payer\n  const loadFeePayerBalance = async keypair => {\n    try {\n      setIsLoadingFeePayerBalance(true);\n      const balance = await connection.getBalance(keypair.publicKey);\n      console.log(`Fee payer balance: ${balance / 1000000000} SOL`);\n\n      // Nếu balance quá thấp, có thể gửi thông báo cảnh báo\n      if (balance < 100000000) {\n        // dưới 0.1 SOL\n        console.warn(\"Fee payer balance thấp, cần nạp thêm SOL\");\n      }\n      setFeePayerBalance(balance / 1000000000);\n    } catch (error) {\n      console.error(\"Lỗi khi load balance của fee payer:\", error);\n    } finally {\n      setIsLoadingFeePayerBalance(false);\n    }\n  };\n\n  // Sử dụng ví tạm thời đã có SOL\n  const useTempWallet = async () => {\n    try {\n      setTransactionStatus('Đang tải ví tạm thời với SOL...');\n\n      // Sử dụng cùng secret key của fee payer\n      const tempWalletPrivateKey = convertSecretKeyStringToUint8Array(process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\n\n      // Tạo Keypair từ private key\n      const keypair = Keypair.fromSecretKey(tempWalletPrivateKey);\n      setWalletKeypair(keypair);\n      setIsUsingTempWallet(true);\n\n      // Tính PDA mới dựa trên keypair mới\n      findMultisigAddress();\n\n      // Tải balance của ví tạm thời\n      await loadBalance(keypair);\n      setTransactionStatus(`Đã chuyển sang ví tạm thời: ${keypair.publicKey.toString()}. Ví này đã có sẵn SOL để giao dịch.`);\n    } catch (error) {\n      console.error('Lỗi khi tải ví tạm thời:', error);\n      setTransactionStatus(`Lỗi khi tải ví tạm thời: ${error.message}`);\n    }\n  };\n\n  // Tải balance với xử lý lỗi tốt hơn\n  const loadBalance = async keypair => {\n    const publicKey = (keypair === null || keypair === void 0 ? void 0 : keypair.publicKey) || (walletKeypair === null || walletKeypair === void 0 ? void 0 : walletKeypair.publicKey);\n    if (!publicKey) return;\n    setIsLoadingBalance(true);\n    try {\n      console.log(\"Đang tải balance cho địa chỉ:\", publicKey.toString());\n      const balance = await connection.getBalance(publicKey);\n      console.log(\"Balance đã tải thành công:\", balance / 1000000000);\n      setWalletBalance(balance / 1000000000); // Chuyển từ lamports sang SOL\n    } catch (error) {\n      console.error('Lỗi khi tải balance:', error);\n      // Không hiển thị lỗi cho người dùng, chỉ log ra console\n    } finally {\n      setIsLoadingBalance(false);\n    }\n  };\n\n  // Tạo ví với WebAuthn\n  const createWalletWithWebAuthn = async () => {\n    try {\n      // Kiểm tra xem người dùng đã nhập recovery phrase chưa\n      if (!recoveryPhrase || recoveryPhrase.trim().length < 8) {\n        setTransactionStatus('Vui lòng nhập recovery phrase (ít nhất 8 ký tự) trước khi tạo ví');\n        return;\n      }\n\n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n      setTransactionStatus('Đang tạo ví Moon Wallet...\\n\\nBước 1: Đang tạo khóa WebAuthn...');\n\n      // 1. Tạo khóa WebAuthn\n      const walletAddress = projectFeePayerKeypair.publicKey.toString(); // Sử dụng địa chỉ của fee payer\n      const result = await createWebAuthnCredential(walletAddress, walletName);\n\n      // Chuyển đổi rawId thành base64 để lưu trữ và sử dụng\n      const rawIdBase64 = Buffer.from(result.rawId).toString('base64');\n\n      // Lưu thông tin WebAuthn\n      setCredentialId(rawIdBase64); // Lưu base64 thay vì hex\n      setWebauthnPubkey(result.publicKey);\n      setTransactionStatus(prev => prev + `\\nĐã tạo khóa WebAuthn thành công!\\nCredential ID (base64): ${rawIdBase64.slice(0, 10)}...\\nPublic Key: ${result.publicKey.slice(0, 10)}...`);\n\n      // 2. Tính PDA cho Multisig\n      const multisigPDA = getMultisigPDA(rawIdBase64);\n      console.log(\"Multisig PDA:\", multisigPDA.toString());\n      setMultisigAddress(multisigPDA);\n      setTransactionStatus(prev => prev + `\\n\\nBước 2: Đang khởi tạo ví multisig tại địa chỉ: ${multisigPDA.toString()}...`);\n\n      // Kiểm tra xem multisig account đã tồn tại chưa\n      const existingAccount = await connection.getAccountInfo(multisigPDA);\n      if (existingAccount) {\n        setTransactionStatus(prev => prev + `\\n\\nLỖI: Ví multisig với credential ID này đã tồn tại. Điều này gần như không thể xảy ra vì credential ID luôn duy nhất.`);\n        return;\n      }\n\n      // 3. Tính PDA address cho guardian\n      // Tạo ID dạng u64 cho guardian\n      const guardianId = BigInt(1); // Owner có ID = 1\n\n      // Chuyển đổi guardianId sang bytes (little-endian)\n      const guardianIdBytes = bigIntToLeBytes(guardianId);\n      const [guardianPDAAddress] = PublicKey.findProgramAddressSync([Buffer.from(\"guardian\").subarray(0), multisigPDA.toBuffer(), guardianIdBytes], PROGRAM_ID);\n      setGuardianPDA(guardianPDAAddress);\n\n      // 4. Tạo transaction tích hợp để khởi tạo multisig và thêm guardian owner\n      const transaction = new Transaction();\n\n      // 4.1 Khởi tạo Multisig\n      // Đây là discriminator cho initialize_multisig (sử dụng giá trị chính xác từ Anchor IDL)\n      const initMultisigDiscriminator = new Uint8Array([220, 130, 117, 21, 27, 227, 78, 213]);\n      const thresholdBytes = new Uint8Array([threshold]);\n\n      // LƯU Ý QUAN TRỌNG: credential_id trong smart contract sử dụng as_bytes() trực tiếp, \n      // nên chúng ta phải gửi chính xác chuỗi rawIdBase64 như một chuỗi UTF-8\n      // không phải decode nó sang dạng binary\n      const credentialIdString = rawIdBase64;\n      const credentialIdBuffer = Buffer.from(credentialIdString);\n      console.log(\"Credential ID gửi đi (chuỗi gốc):\", credentialIdString);\n      const credentialIdLenBuffer = Buffer.alloc(4);\n      credentialIdLenBuffer.writeUInt32LE(credentialIdBuffer.length, 0);\n      const credentialIdLenBytes = bufferToUint8Array(credentialIdLenBuffer);\n      const credentialIdDataBytes = bufferToUint8Array(credentialIdBuffer);\n\n      // Tạo dữ liệu instruction theo đúng cấu trúc contract yêu cầu\n      const initData = concatUint8Arrays(initMultisigDiscriminator, thresholdBytes, credentialIdLenBytes, credentialIdDataBytes);\n\n      // Thêm instruction khởi tạo multisig vào transaction\n      transaction.add(new TransactionInstruction({\n        keys: [{\n          pubkey: multisigPDA,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: projectFeePayerKeypair.publicKey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: SystemProgram.programId,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: PROGRAM_ID,\n        data: Buffer.from(initData)\n      }));\n\n      // Sign và gửi transaction\n      transaction.feePayer = projectFeePayerKeypair.publicKey;\n      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n\n      // Thông báo cho người dùng\n      setTransactionStatus(prev => prev + '\\nĐang gửi transaction để khởi tạo ví và thêm guardian owner...');\n\n      // Log dữ liệu transaction để debug\n      console.log(\"Transaction data:\", {\n        instructions: transaction.instructions.map((ix, index) => ({\n          programId: ix.programId.toString(),\n          keys: ix.keys.map(k => ({\n            pubkey: k.pubkey.toString(),\n            isSigner: k.isSigner,\n            isWritable: k.isWritable\n          })),\n          data: index === 1 ? {\n            discriminator: Array.from(initMultisigDiscriminator),\n            threshold: threshold,\n            credentialIdLength: credentialIdBuffer.length,\n            credentialId: Array.from(credentialIdBuffer),\n            isOwner: true,\n            hasWebauthn: true,\n            webauthnPubkeyLength: result.publicKey.length\n          } : \"initMultisig\"\n        }))\n      });\n      const signature = await connection.sendTransaction(transaction, [projectFeePayerKeypair]);\n      await connection.confirmTransaction(signature);\n      setTransactionStatus(prev => prev + `\\nVí multisig đã được khởi tạo thành công! Signature: ${signature}`);\n\n      // 5. Thêm guardian đầu tiên (owner)\n      setTransactionStatus(prev => prev + '\\n\\nBước 3: Đang thêm guardian owner đầu tiên...');\n      try {\n        // Tính PDA cho guardian\n        const guardianId = BigInt(1); // Owner có ID = 1\n        const guardianIdBytes = bigIntToLeBytes(guardianId);\n\n        // 5.1 Tính PDA cho multisig với credential_id\n        const guardianMultisigPDA = multisigPDA;\n        console.log(\"Sử dụng PDA cho guardian với multisig PDA:\", guardianMultisigPDA.toString());\n\n        // 5.2 Tính PDA cho guardian\n        const guardianPDA = getGuardianPDA(guardianMultisigPDA, 1); // Owner có ID = 1\n\n        setGuardianPDA(guardianPDA);\n\n        // Hash recovery phrase tại frontend\n        console.log(\"Recovery phrase gốc:\", recoveryPhrase);\n        const hashedRecoveryBytes = await hashRecoveryPhrase(recoveryPhrase);\n        console.log(\"Recovery phrase sau khi hash tại frontend:\", Buffer.from(hashedRecoveryBytes).toString('hex'));\n\n        // Tạo discriminator cho add_guardian\n        const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n\n        // Chuyển guardian ID thành bytes\n        const guardianIdBigIntBytes = bigIntToLeBytes(guardianId);\n\n        // Chuẩn bị tên guardian\n        const guardianNameBuffer = Buffer.from(guardianName || 'Owner');\n        const guardianNameLenBuffer = Buffer.alloc(4);\n        guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n\n        // Chuẩn bị recovery hash - sử dụng giá trị đã hash\n        const recoveryHashIntermediateBytes = hashedRecoveryBytes;\n\n        // Chuẩn bị các tham số khác\n        const isOwnerByte = new Uint8Array([1]); // true = 1\n\n        // WebAuthn pubkey - nén khóa từ 65 bytes (uncompressed) thành 33 bytes (compressed)\n        // Smart contract yêu cầu webauthn_pubkey: Option<[u8; 33]>\n        const uncompressedKeyBuffer = Buffer.from(result.publicKey, 'hex');\n        console.log(\"WebAuthn key (uncompressed, 65 bytes):\", result.publicKey);\n\n        // Nén khóa thành 33 bytes\n        const compressedKeyBuffer = compressPublicKey(uncompressedKeyBuffer);\n        console.log(\"WebAuthn key (compressed, 33 bytes):\", compressedKeyBuffer.toString('hex'));\n\n        // Nối tất cả lại với nhau\n        const addGuardianData = concatUint8Arrays(addGuardianDiscriminator,\n        // guardian_id (u64)\n        bufferToUint8Array(Buffer.from(guardianIdBigIntBytes)),\n        // guardian_name (string)\n        bufferToUint8Array(guardianNameLenBuffer), bufferToUint8Array(guardianNameBuffer),\n        // recovery_hash_intermediate ([u8; 32])\n        recoveryHashIntermediateBytes,\n        // is_owner (bool)\n        isOwnerByte,\n        // webauthn_pubkey (Option<[u8; 33]>)\n        new Uint8Array([1]),\n        // Some variant\n        bufferToUint8Array(compressedKeyBuffer) // Sử dụng khóa đã được nén\n        );\n\n        // Tạo transaction add guardian\n        const addGuardianTransaction = new Transaction();\n        addGuardianTransaction.add(new TransactionInstruction({\n          keys: [{\n            pubkey: multisigPDA,\n            isSigner: false,\n            isWritable: true\n          }, {\n            pubkey: guardianPDA,\n            isSigner: false,\n            isWritable: true\n          }, {\n            pubkey: projectFeePayerKeypair.publicKey,\n            isSigner: false,\n            isWritable: false\n          }, {\n            pubkey: projectFeePayerKeypair.publicKey,\n            isSigner: true,\n            isWritable: true\n          }, {\n            pubkey: SystemProgram.programId,\n            isSigner: false,\n            isWritable: false\n          }],\n          programId: PROGRAM_ID,\n          data: Buffer.from(addGuardianData)\n        }));\n\n        // Sign và gửi transaction\n        addGuardianTransaction.feePayer = projectFeePayerKeypair.publicKey;\n        addGuardianTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n        const addGuardianSignature = await connection.sendTransaction(addGuardianTransaction, [projectFeePayerKeypair]);\n        await connection.confirmTransaction(addGuardianSignature);\n        setTransactionStatus(prev => prev + `\\nGuardian owner đã được thêm thành công! Signature: ${addGuardianSignature}`);\n      } catch (error) {\n        console.error(\"Lỗi khi thêm guardian owner:\", error);\n        setTransactionStatus(prev => prev + `\\nLỗi khi thêm guardian owner: ${error.message}`);\n      }\n\n      // 6. Hoàn thành quá trình tạo ví\n      setTransactionStatus(prev => prev + '\\n\\n✅ VÍ MOON WALLET ĐÃ ĐƯỢC TẠO THÀNH CÔNG!\\n' + `Địa chỉ ví Multisig: ${multisigPDA.toString()}\\n` + `Recovery Phrase: ${recoveryPhrase}\\n` + 'Vui lòng lưu lại thông tin này để sử dụng sau này!');\n\n      // Kiểm tra số dư của ví PDA sau khi tạo\n      await loadPdaBalance(multisigPDA);\n    } catch (error) {\n      console.error('Lỗi trong quá trình tạo ví:', error);\n      setTransactionStatus(`Lỗi: ${error.message}`);\n    }\n  };\n\n  // Sửa lại hàm tính PDA cho multisig wallet\n  const findMultisigAddress = async () => {\n    // Sử dụng credential ID (nếu có) hoặc một giá trị tạm thời nếu chưa có\n    if (!credentialId) {\n      // Nếu chưa có credential ID, không thể tính PDA chính xác\n      setMultisigAddress(null);\n      return;\n    }\n    console.log(\"findMultisigAddress - credential ID:\", credentialId);\n\n    // Sử dụng helper function để tính PDA một cách nhất quán\n    const [pda, bump] = await calculateMultisigAddress(PROGRAM_ID, credentialId);\n    console.log(\"findMultisigAddress - PDA:\", pda.toString(), \"bump:\", bump);\n    setMultisigAddress(pda);\n\n    // Load balance cho PDA\n    await loadPdaBalance(pda);\n  };\n\n  // Tải balance với xử lý lỗi tốt hơn\n  const loadPdaBalance = async pdaAddress => {\n    try {\n      setIsLoadingPdaBalance(true);\n      const balance = await connection.getBalance(pdaAddress);\n      console.log(`PDA balance: ${balance / 1000000000} SOL`);\n      setPdaBalance(balance / 1000000000);\n    } catch (error) {\n      console.error(\"Lỗi khi load balance của PDA:\", error);\n    } finally {\n      setIsLoadingPdaBalance(false);\n    }\n  };\n\n  // Tính PDA address cho guardian\n  const findGuardianAddress = async (guardianId = 1) => {\n    if (!multisigAddress) return null;\n    try {\n      // Chuyển đổi guardianId sang bytes (little-endian)\n      const guardianIdBigInt = BigInt(guardianId);\n      const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n\n      // Tính PDA cho guardian trực tiếp từ multisigAddress\n      const [guardianPDA] = PublicKey.findProgramAddressSync([Buffer.from(\"guardian\"), multisigAddress.toBuffer(), guardianIdBytes], PROGRAM_ID);\n      console.log(`Tính PDA cho guardian ID ${guardianId} với multisig: ${multisigAddress.toString()}`);\n      console.log(`Guardian PDA: ${guardianPDA.toString()}`);\n      if (guardianId === 1) {\n        setGuardianPDA(guardianPDA); // Chỉ set state cho guardian chính (ID=1)\n      }\n      return guardianPDA;\n    } catch (error) {\n      console.error(`Lỗi khi tính PDA cho guardian ID ${guardianId}:`, error);\n      return null;\n    }\n  };\n\n  // Airdrop SOL cho testing\n  const requestAirdrop = async () => {\n    if (!projectFeePayerKeypair) {\n      setTransactionStatus('Không tìm thấy fee payer của dự án.');\n      return;\n    }\n    try {\n      setTransactionStatus('Đang yêu cầu airdrop cho fee payer của dự án...');\n      const signature = await connection.requestAirdrop(projectFeePayerKeypair.publicKey, 2000000000 // 2 SOL\n      );\n      await connection.confirmTransaction(signature);\n      // Tải lại số dư của fee payer\n      await loadFeePayerBalance(projectFeePayerKeypair);\n      setTransactionStatus('Airdrop thành công! 2 SOL đã được thêm vào ví fee payer của dự án.');\n    } catch (error) {\n      console.error('Lỗi khi thực hiện airdrop:', error);\n      setTransactionStatus(`Lỗi airdrop: ${error.message}. Đang thử phương thức chuyển tiền trực tiếp...`);\n\n      // Thử phương pháp khác nếu airdrop thất bại\n      fundFromValidator(projectFeePayerKeypair);\n    }\n  };\n\n  // Chuyển tiền từ validator wallet sang ví người dùng \n  const fundFromValidator = async keypair => {\n    try {\n      setTransactionStatus('Đang chuyển tiền từ validator vào fee payer...');\n\n      // Tạo kết nối với validator wallet (địa chỉ mặc định của validator)\n      const validatorKey = new PublicKey('E6mJJmCvg4PDhanmaBxxeyTczza9vKpMgirRUD6Qz5kv');\n\n      // Tạo transaction chuyển tiền\n      const transaction = new Transaction().add(SystemProgram.transfer({\n        fromPubkey: validatorKey,\n        toPubkey: keypair.publicKey,\n        lamports: 2000000000 // 2 SOL\n      }));\n\n      // Lấy các thông tin cần thiết cho transaction\n      transaction.feePayer = validatorKey;\n      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n\n      // Không thể ký transaction vì không có private key của validator\n      // Thay vào đó, sử dụng phương thức sendTransactionWithRetry không cần chữ ký\n      const signature = await connection.sendTransaction(transaction, [] // Không cần signers khi gửi đến validator local\n      );\n      await connection.confirmTransaction(signature);\n\n      // Tải lại số dư\n      if (keypair === projectFeePayerKeypair) {\n        await loadFeePayerBalance(keypair);\n        setTransactionStatus('Chuyển tiền thành công! 2 SOL đã được thêm vào ví fee payer của dự án.');\n      } else {\n        await loadBalance(keypair);\n        setTransactionStatus('Chuyển tiền thành công! 2 SOL đã được thêm vào ví.');\n      }\n    } catch (error) {\n      console.error('Lỗi khi chuyển tiền từ validator:', error);\n      setTransactionStatus(`Lỗi khi chuyển tiền: ${error.message}. Hãy thử khởi động lại validator.`);\n    }\n  };\n\n  // Xem thông tin wallet\n  const getWalletInfo = async () => {\n    if (!multisigAddress) return;\n    try {\n      setTransactionStatus('Đang truy vấn thông tin ví...');\n\n      // Load balance trước\n      await loadPdaBalance(multisigAddress);\n      const multisigAccount = await connection.getAccountInfo(multisigAddress);\n      if (!multisigAccount) {\n        setTransactionStatus('Ví chưa được khởi tạo');\n        return;\n      }\n\n      // Bỏ qua 8 byte discriminator\n      const data = multisigAccount.data.slice(8);\n\n      // Parse dữ liệu dựa trên struct MultiSigWallet mới\n      // MultiSigWallet: threshold, guardian_count, recovery_nonce, bump, transaction_nonce, last_transaction_timestamp\n      const threshold = data[0];\n      const guardian_count = data[1];\n      const recovery_nonce = new DataView(data.buffer, data.byteOffset + 2, 8).getBigUint64(0, true);\n      const bump = data[10];\n      const transaction_nonce = new DataView(data.buffer, data.byteOffset + 11, 8).getBigUint64(0, true);\n      const last_transaction_timestamp = new DataView(data.buffer, data.byteOffset + 19, 8).getBigInt64(0, true);\n\n      // Hiển thị thông tin\n      setTransactionStatus(`Thông tin ví:\\n` + `- Threshold: ${threshold}\\n` + `- Guardian Count: ${guardian_count}\\n` + `- Recovery Nonce: ${recovery_nonce}\\n` + `- Bump: ${bump}\\n` + `- Transaction Nonce: ${transaction_nonce}\\n` + `- Last Transaction Timestamp: ${last_transaction_timestamp}`);\n    } catch (error) {\n      console.error('Lỗi khi truy vấn thông tin ví:', error);\n      setTransactionStatus(`Lỗi: ${error.message}`);\n    }\n  };\n\n  // Xem thông tin guardian\n  const getGuardianInfo = async () => {\n    if (!multisigAddress) {\n      setTransactionStatus('Vui lòng tạo ví trước khi xem thông tin guardian');\n      return;\n    }\n    try {\n      setTransactionStatus(`Đang truy vấn thông tin guardian ID=${selectedGuardianId}...`);\n\n      // Tính guardian PDA dựa trên ID được chọn\n      const guardianPDA = await findGuardianAddress(selectedGuardianId);\n      if (!guardianPDA) {\n        setTransactionStatus('Không thể tìm thấy địa chỉ Guardian');\n        return;\n      }\n      console.log(`Đang truy vấn thông tin guardian ID=${selectedGuardianId} với PDA: ${guardianPDA.toString()}`);\n      const guardianAccount = await connection.getAccountInfo(guardianPDA);\n      if (!guardianAccount) {\n        console.log(`Không tìm thấy thông tin account tại địa chỉ: ${guardianPDA.toString()}`);\n        setTransactionStatus(`Guardian với ID=${selectedGuardianId} chưa được khởi tạo hoặc không tồn tại`);\n        return;\n      }\n      console.log(`Đã tìm thấy account tại địa chỉ: ${guardianPDA.toString()}`);\n      console.log(`Data size: ${guardianAccount.data.length} bytes`);\n      console.log(`Owner: ${guardianAccount.owner.toString()}`);\n\n      // Kiểm tra xem account có thuộc về program của chúng ta không\n      if (!guardianAccount.owner.equals(PROGRAM_ID)) {\n        console.error(`Account không thuộc về program của chúng ta. Owner: ${guardianAccount.owner.toString()}`);\n        setTransactionStatus(`Guardian với ID=${selectedGuardianId} không thuộc về program của chúng ta`);\n        return;\n      }\n\n      // Bỏ qua 8 byte discriminator\n      const data = guardianAccount.data.slice(8);\n      console.log(`Data sau khi bỏ qua discriminator: ${data.length} bytes`);\n      console.log(`Raw data: ${Buffer.from(data).toString('hex').substring(0, 100)}...`);\n      try {\n        // Parse dữ liệu dựa trên struct Guardian\n        // Guardian struct trên Rust: \n        // pub struct Guardian {\n        //     pub wallet: Pubkey,                  // 32 bytes\n        //     pub guardian_id: u64,                // 8 bytes\n        //     pub name: String,                    // 4 bytes length + n bytes string\n        //     pub is_active: bool,                 // 1 byte\n        //     pub recovery_hash_intermediate: [u8; 32], // 32 bytes\n        //     pub is_owner: bool,                  // 1 byte\n        //     pub webauthn_pubkey: Option<[u8; 33]>, // 1 byte discriminator + 33 bytes if Some\n        //     pub bump: u8,                        // 1 byte\n        // }\n\n        // Đọc wallet address (32 bytes)\n        const walletBytes = data.slice(0, 32);\n        const wallet = new PublicKey(walletBytes);\n        console.log(`Wallet address parsed: ${wallet.toString()}`);\n\n        // Đọc guardian_id (8 bytes - u64)\n        const guardianIdBytes = data.slice(32, 40);\n        let guardianId = BigInt(0);\n        for (let i = 0; i < 8; i++) {\n          guardianId |= BigInt(guardianIdBytes[i]) << BigInt(8 * i);\n        }\n        console.log(`Guardian ID parsed: ${guardianId}`);\n\n        // Đọc name (string dài tối đa 32 bytes)\n        const nameLength = new DataView(data.buffer, data.byteOffset + 40, 4).getUint32(0, true);\n        console.log(`Guardian name length: ${nameLength}`);\n        if (nameLength > 100) {\n          console.error(`Name length quá lớn: ${nameLength}, có thể không đúng cấu trúc dữ liệu`);\n          throw new Error(\"Lỗi parse dữ liệu guardian: Name length không hợp lệ\");\n        }\n\n        // Vị trí bắt đầu của name bytes\n        const nameOffset = 44;\n        const nameBytes = data.slice(nameOffset, nameOffset + nameLength);\n        const name = new TextDecoder().decode(nameBytes);\n        console.log(`Guardian name parsed: ${name}`);\n\n        // Vị trí tiếp theo sau name\n        let currentOffset = nameOffset + nameLength;\n\n        // Đọc is_active (1 byte)\n        const isActive = data[currentOffset] === 1;\n        console.log(`Is active byte: ${data[currentOffset]} (offset: ${currentOffset})`);\n        currentOffset += 1;\n\n        // Đọc recovery_hash (32 bytes)\n        const recoveryHash = data.slice(currentOffset, currentOffset + 32);\n        const recoveryHashHex = Buffer.from(recoveryHash).toString('hex');\n        console.log(`Recovery hash (hex): ${recoveryHashHex} (offset: ${currentOffset})`);\n        currentOffset += 32;\n\n        // Đọc is_owner (1 byte)\n        const isOwner = data[currentOffset] === 1;\n        console.log(`Is owner byte: ${data[currentOffset]} (offset: ${currentOffset})`);\n        currentOffset += 1;\n\n        // Đọc webauthn_pubkey (option, 1 byte discriminator + 33 bytes if Some)\n        const hasWebauthn = data[currentOffset] === 1;\n        console.log(`Has webauthn byte: ${data[currentOffset]} (offset: ${currentOffset})`);\n        currentOffset += 1;\n        let webauthnPubkey = null;\n        if (hasWebauthn) {\n          webauthnPubkey = data.slice(currentOffset, currentOffset + 33);\n          const webauthnHex = Buffer.from(webauthnPubkey).toString('hex');\n          console.log(`WebAuthn pubkey: ${webauthnHex} (offset: ${currentOffset})`);\n          // Log thêm thông tin về format của key\n          console.log(`WebAuthn key format byte: 0x${webauthnHex.slice(0, 2)} (${webauthnPubkey[0]})`);\n          currentOffset += 33;\n        }\n\n        // Đọc bump (1 byte)\n        const bump = data[currentOffset];\n        console.log(`Bump: ${bump} (offset: ${currentOffset})`);\n\n        // Hiển thị thông tin\n        setTransactionStatus(`Thông tin Guardian (ID=${guardianId}):\\n` + `- Loại Guardian: ${isOwner ? 'Owner (Quản trị viên)' : 'Regular (Thành viên)'}\\n` + `- Wallet: ${wallet.toString()}\\n` + `- Guardian ID: ${guardianId}\\n` + `- Name: ${name}\\n` + `- Active: ${isActive ? 'Có' : 'Không'}\\n` + `- Recovery Hash: ${recoveryHashHex.slice(0, 10)}...${recoveryHashHex.slice(-10)}\\n` + (hasWebauthn ? `- WebAuthn Key: ${Buffer.from(webauthnPubkey).toString('hex')}\\n` : '') + (hasWebauthn ? `- WebAuthn Key Format: ${webauthnPubkey[0] === 2 ? '02 (even y)' : webauthnPubkey[0] === 3 ? '03 (odd y)' : webauthnPubkey[0].toString()}\\n` : '') + (hasWebauthn ? `- Công dụng: ${isOwner ? 'Dùng để ký giao dịch và quản lý ví' : 'Dùng để xác thực từ thiết bị này'}\\n` : '') + `- Bump: ${bump}\\n` + `- PDA: ${guardianPDA.toString()}`);\n      } catch (parseError) {\n        console.error(\"Lỗi khi parse dữ liệu guardian:\", parseError);\n\n        // Hiển thị thông tin thô nếu không thể parse\n        setTransactionStatus(`Không thể parse dữ liệu guardian chi tiết. Dữ liệu thô:\\n` + `- PDA: ${guardianPDA.toString()}\\n` + `- Data size: ${guardianAccount.data.length} bytes\\n` + `- Raw data: ${Buffer.from(guardianAccount.data).toString('hex').substring(0, 100)}...\\n` + `- Error: ${parseError}`);\n      }\n    } catch (error) {\n      console.error('Lỗi khi truy vấn thông tin guardian:', error);\n      setTransactionStatus(`Lỗi: ${error.message}`);\n    }\n  };\n\n  // Hàm để lấy danh sách guardian ID hiện có\n  const getExistingGuardianIds = async () => {\n    if (!multisigAddress) return [];\n    try {\n      setTransactionStatus('Đang kiểm tra danh sách Guardian ID...');\n      const guardianIds = [];\n\n      // Kiểm tra guardian từ ID 1 đến 8\n      for (let i = 1; i <= 8; i++) {\n        try {\n          // Tính PDA cho guardian với ID i sử dụng hàm đã sửa\n          const guardianPDA = await findGuardianAddress(i);\n          if (!guardianPDA) {\n            console.log(`Guardian ID ${i}: Không tính được PDA`);\n            continue;\n          }\n\n          // Kiểm tra xem guardian với ID này có tồn tại không\n          console.log(`Đang kiểm tra Guardian ID ${i} tại địa chỉ: ${guardianPDA.toString()}`);\n          const guardianAccount = await connection.getAccountInfo(guardianPDA);\n          if (guardianAccount) {\n            guardianIds.push(i);\n            console.log(`Guardian ID ${i} đã tồn tại - PDA: ${guardianPDA.toString()}`);\n            console.log(`  - Owner: ${guardianAccount.owner.toString()}`);\n            console.log(`  - Data size: ${guardianAccount.data.length} bytes`);\n\n            // Kiểm tra discriminator (8 bytes đầu)\n            const discriminator = guardianAccount.data.slice(0, 8);\n            console.log(`  - Discriminator: ${Buffer.from(discriminator).toString('hex')}`);\n          } else {\n            console.log(`Guardian ID ${i}: Account không tồn tại tại địa chỉ ${guardianPDA.toString()}`);\n          }\n        } catch (error) {\n          console.error(`Lỗi khi kiểm tra guardian ID ${i}:`, error);\n        }\n      }\n      console.log(\"Danh sách guardian ID hiện tại:\", guardianIds);\n\n      // Nếu không có guardian nào, thêm ID 1 vào danh sách để có thể chọn\n      if (guardianIds.length === 0) {\n        guardianIds.push(1);\n        console.log(\"Không tìm thấy guardian nào, thêm ID 1 mặc định vào danh sách\");\n      }\n      setExistingGuardians(guardianIds);\n\n      // Đảm bảo selectedGuardianId nằm trong danh sách các ID hiện có\n      if (!guardianIds.includes(selectedGuardianId)) {\n        console.log(`Selected Guardian ID ${selectedGuardianId} không tồn tại, chuyển sang ID ${guardianIds[0]}`);\n        setSelectedGuardianId(guardianIds[0]);\n      }\n      setTransactionStatus(`Đã tìm thấy ${guardianIds.length} guardian. IDs: ${guardianIds.join(', ')}`);\n      return guardianIds;\n    } catch (error) {\n      console.error(\"Lỗi khi lấy danh sách guardian:\", error);\n      return [];\n    }\n  };\n\n  // Hàm sinh guardian ID mới không bị trùng\n  const generateNewGuardianId = existingIds => {\n    // Nếu không có ID nào tồn tại, bắt đầu từ 2 (vì ID 1 thường là owner)\n    if (existingIds.length === 0) return 2;\n\n    // Tìm ID nhỏ nhất không bị trùng\n    let newId = 1;\n    while (existingIds.includes(newId)) {\n      newId++;\n    }\n    return newId;\n  };\n\n  // Hàm thêm guardian mới với chữ ký WebAuthn riêng\n  const addNewGuardian = async () => {\n    try {\n      // Kiểm tra xem ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi thêm guardian.');\n        return;\n      }\n\n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n\n      // Kiểm tra các trường bắt buộc\n      if (!newGuardianName || !newRecoveryPhrase || newRecoveryPhrase.length < 8) {\n        setTransactionStatus('Vui lòng nhập tên guardian và recovery phrase (ít nhất 8 ký tự).');\n        return;\n      }\n      setTransactionStatus('Đang thêm guardian mới...\\n\\nBước 1: Tạo khóa WebAuthn cho guardian mới...');\n\n      // Lấy danh sách guardian ID hiện tại\n      const existingIds = await getExistingGuardianIds();\n\n      // Sinh guardian ID mới không bị trùng\n      const newGuardianId = generateNewGuardianId(existingIds);\n      console.log(\"=== ADD GUARDIAN === Guardian ID mới được sinh:\", newGuardianId);\n\n      // 1. Tạo khóa WebAuthn cho guardian mới\n      try {\n        // Sử dụng một định danh duy nhất cho khóa mới\n        const guardianIdentifier = `${multisigAddress === null || multisigAddress === void 0 ? void 0 : multisigAddress.toString()}_guardian_${newGuardianId}`;\n        const webAuthnResult = await createWebAuthnCredential(guardianIdentifier, newGuardianName);\n\n        // Log thông tin WebAuthn\n        console.log(\"=== ADD GUARDIAN === WebAuthn credential mới đã được tạo:\");\n        console.log(\"=== ADD GUARDIAN === Credential ID:\", webAuthnResult.credentialId);\n        console.log(\"=== ADD GUARDIAN === Public Key:\", webAuthnResult.publicKey);\n        setTransactionStatus(prev => prev + `\\nĐã tạo khóa WebAuthn thành công!`);\n\n        // 2. Tính PDA cho guardian mới\n        const guardianPDA = await findGuardianAddress(newGuardianId);\n        if (!guardianPDA) {\n          setTransactionStatus('Không thể tính PDA cho guardian mới.');\n          return;\n        }\n        console.log(\"=== ADD GUARDIAN === Guardian PDA mới:\", guardianPDA.toString());\n\n        // Kiểm tra trước xem guardian account đã tồn tại chưa\n        const existingGuardian = await connection.getAccountInfo(guardianPDA);\n        if (existingGuardian) {\n          console.log(\"=== ADD GUARDIAN === Guardian account đã tồn tại!\", existingGuardian);\n          setTransactionStatus(`Guardian với ID=${newGuardianId} đã tồn tại rồi. Hãy chọn ID khác.`);\n          return;\n        }\n\n        // 3. Hash recovery phrase\n        const hashedRecoveryBytes = await hashRecoveryPhrase(newRecoveryPhrase);\n        console.log(\"=== ADD GUARDIAN === Recovery phrase sau khi hash:\", Buffer.from(hashedRecoveryBytes).toString('hex'));\n\n        // 4. Chuyển đổi guardian ID thành bytes (little-endian)\n        const guardianIdBigInt = BigInt(newGuardianId);\n        const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n\n        // 5. Nén khóa WebAuthn từ 65 bytes (uncompressed) thành 33 bytes (compressed)\n        const uncompressedKeyBuffer = Buffer.from(webAuthnResult.publicKey, 'hex');\n        console.log(\"=== ADD GUARDIAN === WebAuthn key (uncompressed, 65 bytes):\", webAuthnResult.publicKey);\n\n        // Nén khóa thành 33 bytes\n        const compressedKeyBuffer = compressPublicKey(uncompressedKeyBuffer);\n        console.log(\"=== ADD GUARDIAN === WebAuthn key (compressed, 33 bytes):\", compressedKeyBuffer.toString('hex'));\n\n        // 6. Tạo discriminator cho add_guardian\n        const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n\n        // 7. Chuẩn bị tên guardian\n        const guardianNameBuffer = Buffer.from(newGuardianName);\n        const guardianNameLenBuffer = Buffer.alloc(4);\n        guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n\n        // 8. Đặt is_owner = false vì đây là guardian member, không phải owner\n        const isOwnerByte = new Uint8Array([0]); // false = 0\n\n        // 9. Cấu hình webauthn_pubkey là Some(compressed_key)\n        const hasWebauthn = new Uint8Array([1]); // Some variant\n\n        // 10. Tạo dữ liệu instruction\n        const addGuardianData = concatUint8Arrays(addGuardianDiscriminator,\n        // guardian_id (u64)\n        bufferToUint8Array(Buffer.from(guardianIdBytes)),\n        // guardian_name (string)\n        bufferToUint8Array(guardianNameLenBuffer), bufferToUint8Array(guardianNameBuffer),\n        // recovery_hash_intermediate ([u8; 32])\n        hashedRecoveryBytes,\n        // is_owner (bool)\n        isOwnerByte,\n        // webauthn_pubkey (Option<[u8; 33]>) - Some variant + compressed key\n        hasWebauthn, bufferToUint8Array(compressedKeyBuffer));\n\n        // Log dữ liệu instruction để debug\n        console.log(\"=== ADD GUARDIAN === Dữ liệu instruction:\", {\n          discriminator: Buffer.from(addGuardianDiscriminator).toString('hex'),\n          guardianId: newGuardianId.toString(),\n          guardianIdBytes: Buffer.from(guardianIdBytes).toString('hex'),\n          nameLength: guardianNameBuffer.length,\n          name: newGuardianName,\n          recoveryHashHex: Buffer.from(hashedRecoveryBytes).toString('hex'),\n          isOwner: false,\n          hasWebauthn: true,\n          webauthnPubkey: compressedKeyBuffer.toString('hex')\n        });\n        setTransactionStatus(prev => prev + `\\n\\nBước 2: Đang thêm guardian vào blockchain...`);\n\n        // 11. Tạo transaction add guardian\n        const addGuardianTransaction = new Transaction();\n        addGuardianTransaction.add(new TransactionInstruction({\n          keys: [{\n            pubkey: multisigAddress,\n            isSigner: false,\n            isWritable: true\n          }, {\n            pubkey: guardianPDA,\n            isSigner: false,\n            isWritable: true\n          }, {\n            pubkey: projectFeePayerKeypair.publicKey,\n            isSigner: false,\n            isWritable: false\n          }, {\n            pubkey: projectFeePayerKeypair.publicKey,\n            isSigner: true,\n            isWritable: true\n          }, {\n            pubkey: SystemProgram.programId,\n            isSigner: false,\n            isWritable: false\n          }],\n          programId: PROGRAM_ID,\n          data: Buffer.from(addGuardianData)\n        }));\n\n        // Sign và gửi transaction với fee payer của dự án\n        addGuardianTransaction.feePayer = projectFeePayerKeypair.publicKey;\n        addGuardianTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n        console.log(\"=== ADD GUARDIAN === Đang gửi transaction...\");\n        const addGuardianSignature = await connection.sendTransaction(addGuardianTransaction, [projectFeePayerKeypair]);\n        console.log(\"=== ADD GUARDIAN === Transaction đã gửi. Signature:\", addGuardianSignature);\n        setTransactionStatus(prev => prev + `\\nĐang xác nhận transaction thêm guardian...`);\n        await connection.confirmTransaction(addGuardianSignature);\n        setTransactionStatus(`Guardian mới đã được thêm thành công với ID: ${newGuardianId}!\\n` + `Chữ ký WebAuthn đã được lưu cho guardian này.\\n` + `Signature: ${addGuardianSignature}`);\n\n        // Kiểm tra xem guardian đã được thêm thành công chưa\n        console.log(\"=== ADD GUARDIAN === Đang kiểm tra guardian vừa thêm...\");\n        await new Promise(resolve => setTimeout(resolve, 2000)); // Đợi 2 giây\n\n        const newGuardianAccount = await connection.getAccountInfo(guardianPDA);\n        if (newGuardianAccount) {\n          console.log(\"=== ADD GUARDIAN === Guardian đã được thêm thành công!\");\n          console.log(`=== ADD GUARDIAN === Data size: ${newGuardianAccount.data.length} bytes`);\n\n          // Kiểm tra discriminator\n          const discriminator = newGuardianAccount.data.slice(0, 8);\n          console.log(`=== ADD GUARDIAN === Discriminator: ${Buffer.from(discriminator).toString('hex')}`);\n        } else {\n          console.log(\"=== ADD GUARDIAN === Guardian không được tìm thấy sau khi thêm!\");\n          setTransactionStatus(prev => prev + '\\n\\nCẢNH BÁO: Guardian có vẻ như chưa được khởi tạo trên blockchain mặc dù transaction đã thành công!');\n        }\n\n        // Cập nhật danh sách guardian\n        await getExistingGuardianIds();\n\n        // Cập nhật số dư của ví PDA\n        await loadPdaBalance(multisigAddress);\n\n        // Reset form\n        setNewGuardianName('');\n        setNewRecoveryPhrase('');\n      } catch (webAuthnError) {\n        console.error(\"=== ADD GUARDIAN === Lỗi khi tạo khóa WebAuthn:\", webAuthnError);\n        setTransactionStatus(`Lỗi khi tạo khóa WebAuthn: ${webAuthnError.message || 'Không xác định'}. Vui lòng thử lại.`);\n        return;\n      }\n    } catch (error) {\n      console.error(\"=== ADD GUARDIAN === Lỗi khi thêm guardian mới:\", error);\n      setTransactionStatus(`Lỗi khi thêm guardian mới: ${error.message}`);\n    }\n  };\n\n  // Hàm để nạp SOL vào ví multisig\n  const depositToMultisig = async () => {\n    try {\n      // Kiểm tra xem ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi nạp tiền.');\n        return;\n      }\n\n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n\n      // Kiểm tra số tiền hợp lệ\n      if (!depositAmount || depositAmount <= 0) {\n        setTransactionStatus('Vui lòng nhập số tiền hợp lệ để nạp.');\n        return;\n      }\n\n      // Kiểm tra số dư của fee payer\n      const feePayerBalance = await connection.getBalance(projectFeePayerKeypair.publicKey);\n      const lamportsToSend = depositAmount * LAMPORTS_PER_SOL;\n      if (feePayerBalance < lamportsToSend + 5000) {\n        // 5000 lamports cho phí giao dịch\n        setTransactionStatus(`Số dư fee payer không đủ. Hiện tại: ${feePayerBalance / LAMPORTS_PER_SOL} SOL`);\n        return;\n      }\n      setTransactionStatus(`Đang nạp ${depositAmount} SOL vào ví...`);\n\n      // Tạo transaction chuyển tiền\n      const transaction = new Transaction().add(SystemProgram.transfer({\n        fromPubkey: projectFeePayerKeypair.publicKey,\n        toPubkey: multisigAddress,\n        lamports: lamportsToSend\n      }));\n\n      // Cấu hình transaction\n      transaction.feePayer = projectFeePayerKeypair.publicKey;\n      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n\n      // Ký và gửi transaction\n      const signature = await connection.sendTransaction(transaction, [projectFeePayerKeypair]);\n      await connection.confirmTransaction(signature);\n\n      // Cập nhật số dư\n      await loadPdaBalance(multisigAddress);\n      await loadFeePayerBalance(projectFeePayerKeypair);\n      setTransactionStatus(`Đã nạp thành công ${depositAmount} SOL vào ví! Signature: ${signature}`);\n    } catch (error) {\n      console.error('Lỗi khi nạp tiền vào ví:', error);\n      setTransactionStatus(`Lỗi khi nạp tiền: ${error.message}`);\n    }\n  };\n\n  // Hàm để rút tiền từ ví multisig\n  const withdrawFromMultisig = async (amount, destinationAddressStr) => {\n    if (!multisigAddress) {\n      console.error('Multisig address chưa được tạo');\n      return;\n    }\n    try {\n      setTransactionStatus('Đang xử lý giao dịch...');\n      const destinationAddress = new PublicKey(destinationAddressStr);\n      const lamports = Math.floor(amount * LAMPORTS_PER_SOL);\n\n      // Lấy fee payer từ biến môi trường\n      let feePayerSecretKey;\n      try {\n        feePayerSecretKey = convertSecretKeyStringToUint8Array(process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\n      } catch (error) {\n        console.error(\"Lỗi khi chuyển đổi fee payer secret key:\", error);\n        setTransactionStatus('Lỗi khi chuyển đổi fee payer secret key');\n        return;\n      }\n\n      // Tạo fee payer keypair\n      const feePayerKeypair = Keypair.fromSecretKey(feePayerSecretKey);\n\n      // Lấy khóa công khai từ WebAuthn credential\n      if (!credentialId) {\n        console.error('WebAuthn credential chưa được tạo');\n        setTransactionStatus('WebAuthn credential chưa được tạo');\n        return;\n      }\n\n      // Lấy client data JSON cho hàm withdraw\n      const assertion = await getWebAuthnAssertionForLogin(credentialId);\n      if (!assertion || !assertion.success) {\n        console.error('Không thể lấy WebAuthn assertion');\n        setTransactionStatus('Không thể lấy WebAuthn assertion');\n        return;\n      }\n\n      // Tạo instruction data\n      // ActionParams: { amount: u64, destination: Pubkey, token_mint: Option<Pubkey> }\n\n      // 1. Tạo Buffer cho action \"withdraw\"\n      const action = Buffer.from(\"withdraw\");\n\n      // 2. Chuyển đổi amount (lamports) thành little-endian bytes\n      const amountBytes = bigIntToLeBytes(BigInt(lamports), 8);\n\n      // 3. Thêm bytes của destination pubkey\n      const destinationBytes = destinationAddress.toBytes();\n\n      // 4. Thêm 0x00 để đánh dấu không có token_mint (None)\n      const tokenMintOption = Buffer.from([0]);\n\n      // Phần chữ ký (signature)\n      const signatureBytes = Buffer.from(assertion.signature || []);\n      const signatureLen = Buffer.alloc(4);\n      signatureLen.writeUInt32LE(signatureBytes.length, 0);\n\n      // Phần authenticator data\n      const authenticatorData = Buffer.from(assertion.authenticatorData || []);\n      const authenticatorDataLen = Buffer.alloc(4);\n      authenticatorDataLen.writeUInt32LE(authenticatorData.length, 0);\n\n      // Phần client data JSON\n      const clientDataJSON = Buffer.from(assertion.clientDataJSON || []);\n      const clientDataJSONLen = Buffer.alloc(4);\n      clientDataJSONLen.writeUInt32LE(clientDataJSON.length, 0);\n\n      // Kết hợp tất cả dữ liệu\n      const data = Buffer.concat([action, Buffer.from(amountBytes), Buffer.from(destinationBytes), tokenMintOption, signatureLen, signatureBytes, authenticatorDataLen, authenticatorData, clientDataJSONLen, clientDataJSON]);\n\n      // Tạo transaction instruction\n      const instruction = new TransactionInstruction({\n        keys: [{\n          pubkey: multisigAddress,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: destinationAddress,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: feePayerKeypair.publicKey,\n          isSigner: true,\n          isWritable: true\n        }],\n        programId: PROGRAM_ID,\n        data: data\n      });\n\n      // Tạo transaction\n      const transaction = new Transaction().add(instruction);\n\n      // Gửi transaction\n      const txSignature = await sendAndConfirmTransaction(connection, transaction, [feePayerKeypair], {\n        commitment: 'confirmed'\n      });\n      console.log(`Transaction đã hoàn thành: https://explorer.solana.com/tx/${txSignature}?cluster=custom`);\n      setTransactionStatus(`Giao dịch thành công! Signature: ${txSignature}`);\n\n      // Cập nhật lại số dư\n      loadPdaBalance(multisigAddress);\n    } catch (error) {\n      console.error('Lỗi khi rút tiền từ multisig:', error);\n      setTransactionStatus(`Lỗi khi rút tiền: ${error instanceof Error ? error.message : 'Lỗi không xác định'}`);\n      throw error;\n    }\n  };\n\n  // Tự động cập nhật danh sách guardians khi multisigAddress thay đổi\n  useEffect(() => {\n    if (multisigAddress) {\n      // Load lại danh sách guardian IDs\n      getExistingGuardianIds();\n\n      // Load số dư của PDA\n      loadPdaBalance(multisigAddress);\n    }\n  }, [multisigAddress]);\n\n  // Hàm để kiểm tra guardian ID cụ thể\n  const testGuardianInfo = async id => {\n    if (!multisigAddress) {\n      setTransactionStatus('Ví chưa được khởi tạo');\n      return;\n    }\n    setTransactionStatus(`Đang kiểm tra chi tiết Guardian ID ${id}...`);\n    try {\n      // Tính PDA \n      const guardianPDA = await findGuardianAddress(id);\n      if (!guardianPDA) {\n        setTransactionStatus(`Không thể tính PDA cho Guardian ID ${id}`);\n        return;\n      }\n      console.log(`=== TEST === Đang kiểm tra chi tiết Guardian ID ${id} tại ${guardianPDA.toString()}`);\n      const guardianAccount = await connection.getAccountInfo(guardianPDA);\n      if (!guardianAccount) {\n        console.log(`=== TEST === Account không tồn tại tại địa chỉ ${guardianPDA.toString()}`);\n        setTransactionStatus(`Guardian ID ${id} không tồn tại trên blockchain`);\n        return;\n      }\n      console.log(`=== TEST === Account tồn tại!`);\n      console.log(`=== TEST === Owner: ${guardianAccount.owner.toString()}`);\n      console.log(`=== TEST === Data size: ${guardianAccount.data.length} bytes`);\n\n      // Kiểm tra discriminator\n      const discriminator = guardianAccount.data.slice(0, 8);\n      console.log(`=== TEST === Discriminator: ${Buffer.from(discriminator).toString('hex')}`);\n\n      // Bỏ qua 8 byte discriminator\n      const data = guardianAccount.data.slice(8);\n      try {\n        // Wallet (32 bytes)\n        const walletBytes = data.slice(0, 32);\n        const wallet = new PublicKey(walletBytes);\n        console.log(`=== TEST === Wallet: ${wallet.toString()}`);\n\n        // Guardian ID (8 bytes)\n        const guardianIdBytes = data.slice(32, 40);\n        let guardianId = BigInt(0);\n        for (let i = 0; i < 8; i++) {\n          guardianId |= BigInt(guardianIdBytes[i]) << BigInt(8 * i);\n        }\n        console.log(`=== TEST === Guardian ID parsed: ${guardianId}`);\n\n        // Name\n        const nameLength = new DataView(data.buffer, data.byteOffset + 40, 4).getUint32(0, true);\n        console.log(`=== TEST === Name length: ${nameLength}`);\n\n        // Nếu name length hợp lệ, tiếp tục parse\n        if (nameLength <= 100) {\n          const nameBytes = data.slice(44, 44 + nameLength);\n          const name = new TextDecoder().decode(nameBytes);\n          console.log(`=== TEST === Name: ${name}`);\n          setTransactionStatus(`Guardian ID ${id} tồn tại!\\n- PDA: ${guardianPDA.toString()}\\n- Wallet: ${wallet.toString()}\\n- Name: ${name}\\n- Guardian ID: ${guardianId}`);\n        } else {\n          console.log(`=== TEST === Name length không hợp lệ`);\n          setTransactionStatus(`Guardian ID ${id} tồn tại nhưng có cấu trúc dữ liệu không hợp lệ`);\n        }\n      } catch (parseError) {\n        console.error(`=== TEST === Lỗi khi parse dữ liệu:`, parseError);\n        setTransactionStatus(`Guardian ID ${id} tồn tại nhưng không thể parse dữ liệu: ${parseError}`);\n      }\n    } catch (error) {\n      console.error(`=== TEST === Lỗi:`, error);\n      setTransactionStatus(`Lỗi khi kiểm tra: ${error.message}`);\n    }\n  };\n\n  // Hàm đăng nhập vào ví đã tạo\n  const loginToWallet = async () => {\n    try {\n      setIsLoggingIn(true);\n      setTransactionStatus('Đang đăng nhập vào ví...\\n\\nBước 1: Đang yêu cầu xác thực WebAuthn...');\n\n      // 1. Yêu cầu người dùng xác thực với thiết bị (không cần nhập credential ID cụ thể)\n      try {\n        // Gọi hàm getWebAuthnAssertionForLogin với allowEmpty=true để cho phép người dùng chọn từ bất kỳ credential nào\n        const assertionResult = await getWebAuthnAssertionForLogin('', true);\n        if (!assertionResult.success || !assertionResult.rawId) {\n          throw new Error(assertionResult.error || 'Không thể xác thực với thiết bị');\n        }\n\n        // Lấy thông tin credential từ phản hồi\n        const credentialRawData = assertionResult.rawId;\n\n        // Chuyển rawId thành hex để sử dụng làm key trong bảng webauthn_credentials\n        const credentialIdHex = Buffer.from(credentialRawData).toString('hex');\n        console.log(\"Credential ID (hex):\", credentialIdHex);\n\n        // Chuyển rawId thành base64 để sử dụng trong blockchain\n        const rawIdBase64 = Buffer.from(credentialRawData).toString('base64');\n        console.log(\"Raw credential ID (base64):\", rawIdBase64);\n        setTransactionStatus(prev => prev + '\\nXác thực WebAuthn thành công!\\n\\nBước 2: Đang tìm thông tin ví...');\n\n        // 2. Truy vấn thông tin ví từ bảng webauthn_credentials\n        const credentialMapping = await getWalletByCredentialId(credentialIdHex);\n        if (credentialMapping) {\n          // Nếu tìm thấy trong bảng ánh xạ\n          setTransactionStatus(prev => prev + `\\nĐã tìm thấy thông tin ví trong database!`);\n\n          // Chuyển đổi từ chuỗi sang PublicKey\n          const walletAddressFromDB = new PublicKey(credentialMapping.walletAddress);\n          console.log(\"Wallet address from database:\", walletAddressFromDB.toString());\n\n          // 3. Kiểm tra xem ví có tồn tại trên blockchain không\n          const walletAccount = await connection.getAccountInfo(walletAddressFromDB);\n          if (!walletAccount) {\n            setTransactionStatus(`Ví tìm thấy trong database không tồn tại trên blockchain. Địa chỉ: ${walletAddressFromDB.toString()}`);\n            setIsLoggingIn(false);\n            return;\n          }\n\n          // 4. Cập nhật state với thông tin ví\n          setMultisigAddress(walletAddressFromDB);\n          setCredentialId(rawIdBase64); // Lưu credential ID gốc\n\n          setTransactionStatus(prev => prev + `\\nĐã tìm thấy ví tại địa chỉ: ${walletAddressFromDB.toString()}\\n\\nBước 3: Đang tải thông tin ví...`);\n        } else {\n          // Nếu không tìm thấy trong bảng ánh xạ, sử dụng phương pháp tính toán cũ\n          setTransactionStatus(prev => prev + '\\nKhông tìm thấy thông tin trong database, đang tính toán địa chỉ ví...');\n\n          // Tính địa chỉ ví từ credential ID\n          const multisigPDA = getMultisigPDA(rawIdBase64);\n          console.log(\"Computed Multisig PDA:\", multisigPDA.toString());\n\n          // Kiểm tra xem ví có tồn tại không\n          const walletAccount = await connection.getAccountInfo(multisigPDA);\n          if (!walletAccount) {\n            setTransactionStatus(`Không tìm thấy ví với credential này. Có thể bạn cần tạo ví mới.`);\n            setIsLoggingIn(false);\n            return;\n          }\n          setTransactionStatus(prev => prev + `\\nĐã tìm thấy ví tại địa chỉ: ${multisigPDA.toString()}\\n\\nBước 3: Đang tải thông tin ví...`);\n\n          // Cập nhật state với thông tin ví\n          setMultisigAddress(multisigPDA);\n          setCredentialId(rawIdBase64); // Lưu credential ID gốc\n        }\n\n        // 5. Tìm guardian PDA\n        await findGuardianAddress(1); // Tìm guardian chính (owner)\n\n        // 6. Tải số dư và danh sách guardian\n        await loadPdaBalance(multisigAddress);\n        await getExistingGuardianIds();\n\n        // 7. Hoàn thành đăng nhập\n        setIsLoggedIn(true);\n        setIsLoggingIn(false);\n        setTransactionStatus(`Đăng nhập thành công!\\n\\nĐịa chỉ ví: ${multisigAddress.toString()}\\nSố guardian: ${existingGuardians.length}`);\n\n        // 8. Ẩn form đăng nhập\n        setShowLoginForm(false);\n      } catch (webAuthnError) {\n        console.error(\"Lỗi khi xác thực WebAuthn:\", webAuthnError);\n        setTransactionStatus(`Lỗi khi xác thực: ${webAuthnError.message}`);\n        setIsLoggingIn(false);\n      }\n    } catch (error) {\n      console.error('Lỗi khi đăng nhập:', error);\n      setTransactionStatus(`Lỗi khi đăng nhập: ${error.message}`);\n      setIsLoggingIn(false);\n    }\n  };\n\n  // Hàm tạo mã mời ngẫu nhiên\n  const generateRandomCode = length => {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let result = '';\n    const randomValues = new Uint8Array(length);\n    crypto.getRandomValues(randomValues);\n    for (let i = 0; i < length; i++) {\n      result += chars.charAt(randomValues[i] % chars.length);\n    }\n    return result;\n  };\n\n  // Hàm tạo link mời guardian mới\n  const generateGuardianInvite = async () => {\n    try {\n      // Kiểm tra ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi mời guardian.');\n        return;\n      }\n\n      // Lấy danh sách guardian ID hiện tại\n      const existingIds = await getExistingGuardianIds();\n\n      // Sinh guardian ID mới không bị trùng\n      const newGuardianId = generateNewGuardianId(existingIds);\n\n      // Tạo mã ngẫu nhiên cho link mời\n      const inviteCode = generateRandomCode(8);\n\n      // Tạo link mời với URL ngrok từ biến môi trường hoặc sử dụng địa chỉ hiện tại\n      const ngrokUrl = process.env.REACT_APP_NGROK_URL || window.location.origin;\n      const inviteLink = `${ngrokUrl}/#/guardian-signup/${inviteCode}`;\n\n      // Hiển thị link (đặt state trước khi lưu vào Firebase)\n      setInviteCode(inviteCode);\n      setInviteLink(inviteLink);\n      setShowQRCode(true);\n\n      // Lưu thông tin vào Firebase\n      try {\n        await saveInvitation({\n          multisigAddress: multisigAddress.toString(),\n          guardianId: newGuardianId,\n          inviteCode,\n          status: 'pending',\n          ownerId: (projectFeePayerKeypair === null || projectFeePayerKeypair === void 0 ? void 0 : projectFeePayerKeypair.publicKey.toString()) || ''\n        });\n      } catch (error) {\n        console.error(\"Lỗi khi lưu vào Firebase:\", error);\n        // Hiển thị lỗi nhưng vẫn tiếp tục hiển thị link mời\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        setTransactionStatus(`Đã tạo link mời guardian: ${inviteLink}\\nLưu ý: Có lỗi khi lưu thông tin: ${errorMessage}`);\n        return inviteLink;\n      }\n      setTransactionStatus(`Đã tạo link mời guardian: ${inviteLink}`);\n      return inviteLink;\n    } catch (error) {\n      console.error(\"Lỗi khi tạo link mời guardian:\", error);\n      setTransactionStatus(`Lỗi khi tạo link mời guardian: ${error.message}`);\n      return null;\n    }\n  };\n\n  // Tải danh sách mã mời đang chờ\n  const loadPendingInvites = async () => {\n    try {\n      if (!projectFeePayerKeypair || !multisigAddress) return;\n      const ownerId = projectFeePayerKeypair.publicKey.toString();\n      // Chỉ lọc guardian của chính ví multisig hiện tại\n      const multisigAddressStr = multisigAddress.toString();\n      const invitesList = await getPendingInvites(ownerId, multisigAddressStr);\n      setPendingInvites(invitesList);\n      if (invitesList.length > 0) {\n        console.log(`Tìm thấy ${invitesList.length} guardian đang chờ hoàn tất cho ví ${multisigAddressStr}. Mã mời: ${invitesList.join(', ')}`);\n      }\n    } catch (error) {\n      console.error(\"Lỗi khi tải danh sách mã mời:\", error);\n    }\n  };\n\n  // Load danh sách mã mời khi component được mount và mỗi khi projectFeePayerKeypair hoặc multisigAddress thay đổi\n  useEffect(() => {\n    if (projectFeePayerKeypair && multisigAddress) {\n      loadPendingInvites();\n    }\n  }, [projectFeePayerKeypair, multisigAddress]);\n\n  // Hàm để lấy thông tin guardian đã đăng ký\n  const fetchGuardianDataFromDatabase = async inviteCode => {\n    try {\n      return await getGuardianData(inviteCode);\n    } catch (error) {\n      console.error(\"Lỗi khi lấy dữ liệu guardian:\", error);\n      return null;\n    }\n  };\n\n  // Hàm để lấy thông tin invitation\n  const fetchInviteFromDatabase = async inviteCode => {\n    try {\n      return await getInvitation(inviteCode);\n    } catch (error) {\n      console.error(\"Lỗi khi lấy dữ liệu invite:\", error);\n      return null;\n    }\n  };\n\n  // Hàm để cập nhật trạng thái guardian\n  const updateGuardianStatusInDatabase = async (inviteCode, status, txSignature) => {\n    try {\n      await updateGuardianStatus(inviteCode, status, txSignature);\n    } catch (error) {\n      console.error(\"Lỗi khi cập nhật trạng thái guardian:\", error);\n    }\n  };\n\n  // Hàm hoàn tất đăng ký guardian từ dữ liệu đã lưu\n  const completeGuardianRegistration = async inviteCode => {\n    try {\n      setTransactionStatus('Đang hoàn tất đăng ký guardian...');\n\n      // 1. Lấy dữ liệu guardian từ localStorage\n      const guardianData = await fetchGuardianDataFromDatabase(inviteCode);\n      if (!guardianData) {\n        setTransactionStatus('Không tìm thấy dữ liệu guardian. Vui lòng đảm bảo guardian đã hoàn tất đăng ký.');\n        return;\n      }\n      if (guardianData.status !== 'ready') {\n        setTransactionStatus('Guardian chưa hoàn tất đăng ký.');\n        return;\n      }\n\n      // 2. Lấy thông tin invite\n      const inviteData = await fetchInviteFromDatabase(inviteCode);\n      if (!inviteData) {\n        setTransactionStatus('Không tìm thấy thông tin mời guardian.');\n        return;\n      }\n\n      // 3. Tính PDA cho guardian\n      const multisigPDA = new PublicKey(inviteData.multisigAddress);\n      const guardianId = inviteData.guardianId;\n      const guardianPDA = await findGuardianAddress(guardianId);\n      if (!guardianPDA) {\n        setTransactionStatus('Không thể tính PDA cho guardian.');\n        return;\n      }\n\n      // 4. Chuyển đổi dữ liệu thành format phù hợp\n      const hashedRecoveryBytes = new Uint8Array(guardianData.hashedRecoveryBytes);\n      const compressedKeyBuffer = Buffer.from(guardianData.webauthnPublicKey);\n\n      // 5. Tạo discriminator cho add_guardian\n      const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n\n      // 6. Chuyển đổi guardian ID thành bytes (little-endian)\n      const guardianIdBigInt = BigInt(guardianId);\n      const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n\n      // 7. Chuẩn bị tên guardian\n      const guardianNameBuffer = Buffer.from(guardianData.guardianName);\n      const guardianNameLenBuffer = Buffer.alloc(4);\n      guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n\n      // 8. Đặt is_owner = false vì đây là guardian member, không phải owner\n      const isOwnerByte = new Uint8Array([0]); // false = 0\n\n      // 9. Cấu hình webauthn_pubkey là Some(compressed_key)\n      const hasWebauthn = new Uint8Array([1]); // Some variant\n\n      // 10. Tạo dữ liệu instruction\n      const addGuardianData = concatUint8Arrays(addGuardianDiscriminator,\n      // guardian_id (u64)\n      bufferToUint8Array(Buffer.from(guardianIdBytes)),\n      // guardian_name (string)\n      bufferToUint8Array(guardianNameLenBuffer), bufferToUint8Array(guardianNameBuffer),\n      // recovery_hash_intermediate ([u8; 32])\n      hashedRecoveryBytes,\n      // is_owner (bool)\n      isOwnerByte,\n      // webauthn_pubkey (Option<[u8; 33]>) - Some variant + compressed key\n      hasWebauthn, bufferToUint8Array(Buffer.from(compressedKeyBuffer)));\n\n      // 11. Tạo transaction add guardian\n      const addGuardianTransaction = new Transaction();\n      addGuardianTransaction.add(new TransactionInstruction({\n        keys: [{\n          pubkey: multisigPDA,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: guardianPDA,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: projectFeePayerKeypair.publicKey,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: projectFeePayerKeypair.publicKey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: SystemProgram.programId,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: PROGRAM_ID,\n        data: Buffer.from(addGuardianData)\n      }));\n\n      // Sign và gửi transaction với fee payer của dự án\n      addGuardianTransaction.feePayer = projectFeePayerKeypair.publicKey;\n      addGuardianTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      setTransactionStatus(prev => prev + '\\nĐang gửi transaction...');\n      const addGuardianSignature = await connection.sendTransaction(addGuardianTransaction, [projectFeePayerKeypair]);\n      setTransactionStatus(prev => prev + '\\nĐang xác nhận transaction...');\n      await connection.confirmTransaction(addGuardianSignature);\n\n      // Cập nhật trạng thái trong DB\n      await updateGuardianStatusInDatabase(inviteCode, 'completed', addGuardianSignature);\n      setTransactionStatus(`Guardian đã được thêm thành công với ID: ${guardianId}!\\n` + `Signature: ${addGuardianSignature}`);\n\n      // Xóa dữ liệu guardian từ database sau khi hoàn tất\n      setTransactionStatus(prev => prev + '\\n\\nĐang xóa dữ liệu guardian từ database...');\n      console.log(`Bắt đầu xóa dữ liệu guardian với mã mời: ${inviteCode}`);\n      const deleteResult = await deleteGuardianData(inviteCode);\n      if (deleteResult) {\n        console.log(`✅ ĐÃ XÓA THÀNH CÔNG dữ liệu guardian, invitation và lookup với mã mời: ${inviteCode}`);\n\n        // Cập nhật thông báo thành công rõ ràng hơn\n        setTransactionStatus(`✅ HOÀN TẤT THÀNH CÔNG!\n        \n        Guardian \"${guardianData.guardianName}\" (ID: ${guardianData.guardianId}) đã được thêm thành công vào ví.\n        \n        Địa chỉ Guardian: ${guardianPDA.toString()}\n        Signature: ${addGuardianSignature}\n        \n        ✅ Dữ liệu đã được xóa khỏi database để bảo vệ quyền riêng tư.\n        \n        ✅ Guardian hiện đã sẵn sàng sử dụng và đã được ẩn khỏi danh sách chờ.`);\n\n        // Bỏ mã mời đã sử dụng khỏi danh sách\n        setPendingInvites(prev => prev.filter(code => code !== inviteCode));\n\n        // Không đóng form để người dùng có thể tiếp tục thêm guardian khác\n        /* \n        if (pendingInvites.length <= 1) {\n          setShowInviteInput(false);\n        }\n        */\n      } else {\n        console.error(`❌ KHÔNG THỂ XÓA dữ liệu guardian với mã mời: ${inviteCode}`);\n        setTransactionStatus(prev => prev + '\\n❌ Không thể xóa dữ liệu guardian từ database.');\n      }\n\n      // Cập nhật danh sách guardian và load lại danh sách mã mời\n      await getExistingGuardianIds();\n      await loadPendingInvites();\n\n      // Cập nhật số dư của ví PDA\n      await loadPdaBalance(multisigPDA);\n    } catch (error) {\n      console.error(\"Lỗi khi hoàn tất đăng ký guardian:\", error);\n      setTransactionStatus(`Lỗi khi hoàn tất đăng ký guardian: ${error.message}`);\n    }\n  };\n\n  // Hàm kiểm tra thông tin guardians trong database\n  const checkGuardiansInDatabase = async () => {\n    try {\n      setTransactionStatus('Đang kiểm tra dữ liệu guardians từ Firestore...');\n      if (!projectFeePayerKeypair || !multisigAddress) {\n        setTransactionStatus('Cần có thông tin fee payer và multisig address để kiểm tra.');\n        return;\n      }\n      const ownerId = projectFeePayerKeypair.publicKey.toString();\n      const multisigAddressStr = multisigAddress.toString();\n\n      // Lấy danh sách invitations đang chờ CHỈ của ví hiện tại\n      const pendingInvites = await getPendingInvites(ownerId, multisigAddressStr);\n      console.log(`Danh sách mã mời đang chờ cho ví ${multisigAddressStr}:`, pendingInvites);\n      if (pendingInvites.length === 0) {\n        setTransactionStatus(`Không tìm thấy mã mời nào đang chờ xử lý cho ví ${multisigAddressStr}.`);\n        return;\n      }\n\n      // Kiểm tra thông tin từng guardian\n      let resultMessage = 'Thông tin guardians từ database:\\n\\n';\n      for (const inviteCode of pendingInvites) {\n        // Lấy thông tin invitation\n        const inviteData = await getInvitation(inviteCode);\n        if (!inviteData) {\n          resultMessage += `Mã mời ${inviteCode}: Không tìm thấy thông tin invitation.\\n`;\n          continue;\n        }\n\n        // Lấy thông tin guardian\n        const guardianData = await getGuardianData(inviteCode);\n        if (!guardianData) {\n          resultMessage += `Mã mời ${inviteCode}: Invitation tồn tại nhưng chưa có thông tin guardian.\\n`;\n          continue;\n        }\n\n        // Hiển thị thông tin\n        resultMessage += `Mã mời: ${inviteCode}\\n`;\n        resultMessage += `Guardian ID: ${guardianData.guardianId}\\n`;\n        resultMessage += `Tên guardian: ${guardianData.guardianName}\\n`;\n        resultMessage += `Trạng thái: ${guardianData.status}\\n`;\n        resultMessage += `WebAuthn ID: ${guardianData.webauthnCredentialId.substring(0, 20)}...\\n\\n`;\n      }\n      setTransactionStatus(resultMessage);\n    } catch (error) {\n      console.error(\"Lỗi khi kiểm tra thông tin guardians:\", error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      setTransactionStatus(`Lỗi khi kiểm tra thông tin guardians: ${errorMessage}`);\n    }\n  };\n\n  // Hoàn tất quá trình đăng ký guardian dựa trên mã mời\n  const completeGuardianSetup = async inviteCode => {\n    try {\n      setTransactionStatus(`Đang hoàn tất quá trình đăng ký guardian với mã mời: ${inviteCode}...`);\n\n      // 1. Lấy thông tin guardian\n      const guardianData = await getGuardianData(inviteCode);\n      if (!guardianData) {\n        setTransactionStatus('Không tìm thấy thông tin guardian. Vui lòng đảm bảo guardian đã hoàn tất đăng ký.');\n        return;\n      }\n      if (guardianData.status !== 'ready') {\n        setTransactionStatus(`Guardian có trạng thái không hợp lệ: ${guardianData.status}`);\n        return;\n      }\n\n      // 2. Thêm guardian vào blockchain\n      setTransactionStatus(prev => prev + '\\n\\nĐang thêm guardian vào blockchain...');\n\n      // Tạo multisig PDA từ địa chỉ multisig\n      const multisigPubkey = new PublicKey(guardianData.multisigAddress);\n\n      // Tạo WebAuthn public key từ dữ liệu lưu trữ\n      const webauthnPubkey = Buffer.from(new Uint8Array(guardianData.webauthnPublicKey));\n\n      // Chuẩn bị dữ liệu guardian\n      const guardianIndex = guardianData.guardianId;\n      const guardianName = guardianData.guardianName;\n      const guardianType = 0; // 0 = Guardian thường\n      const recoveryHash = Uint8Array.from(guardianData.hashedRecoveryBytes);\n\n      // Thêm guardian vào blockchain\n      if (projectFeePayerKeypair) {\n        // Tạo transaction\n        const tx = new Transaction();\n\n        // Tìm PDA cho guardian\n        const guardianIdBigInt = BigInt(guardianIndex);\n        const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n        const [guardianPDA] = await PublicKey.findProgramAddress([Buffer.from(\"guardian\"), multisigPubkey.toBuffer(), guardianIdBytes], PROGRAM_ID);\n\n        // Tạo instruction để thêm guardian\n        // Sử dụng discriminator đúng cho add_guardian theo IDL\n        const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n\n        // Chuẩn bị tên guardian\n        const guardianNameBuffer = Buffer.from(guardianName);\n        const guardianNameLenBuffer = Buffer.alloc(4);\n        guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n\n        // Đặt is_owner = false vì đây là guardian member, không phải owner\n        const isOwnerByte = new Uint8Array([0]); // false = 0\n\n        // Cấu hình webauthn_pubkey là Some(webauthnPubkey)\n        const hasWebauthn = new Uint8Array([1]); // Some variant\n\n        // Tạo dữ liệu instruction\n        const instructionData = concatUint8Arrays(addGuardianDiscriminator, guardianIdBytes, bufferToUint8Array(guardianNameLenBuffer), bufferToUint8Array(guardianNameBuffer), recoveryHash, isOwnerByte, hasWebauthn, bufferToUint8Array(webauthnPubkey));\n        const addGuardianIx = new TransactionInstruction({\n          keys: [{\n            pubkey: multisigPubkey,\n            isSigner: false,\n            isWritable: true\n          }, {\n            pubkey: guardianPDA,\n            isSigner: false,\n            isWritable: true\n          }, {\n            pubkey: projectFeePayerKeypair.publicKey,\n            isSigner: false,\n            isWritable: false\n          }, {\n            pubkey: projectFeePayerKeypair.publicKey,\n            isSigner: true,\n            isWritable: true\n          }, {\n            pubkey: SystemProgram.programId,\n            isSigner: false,\n            isWritable: false\n          }],\n          programId: PROGRAM_ID,\n          data: Buffer.from(instructionData)\n        });\n        tx.add(addGuardianIx);\n\n        // Gửi transaction\n        setTransactionStatus(prev => prev + '\\nĐang gửi transaction...');\n        const signature = await sendAndConfirmTransaction(connection, tx, [projectFeePayerKeypair], {\n          commitment: 'confirmed',\n          skipPreflight: true\n        });\n\n        // Xác nhận transaction đã thành công\n        setTransactionStatus(prev => prev + '\\nĐang xác nhận transaction...');\n        await connection.confirmTransaction(signature, 'confirmed');\n\n        // Cập nhật trạng thái guardian\n        await updateGuardianStatus(inviteCode, 'completed', signature);\n\n        // Thông báo kết quả\n        setTransactionStatus(`Guardian đã được thêm thành công vào blockchain!\n- Tên: ${guardianData.guardianName}\n- ID: ${guardianData.guardianId}\n- Địa chỉ: ${guardianPDA.toString()}\n- Signature: ${signature}\n\nGuardian đã sẵn sàng để sử dụng trong ví multisig của bạn.`);\n\n        // Xóa dữ liệu guardian từ database sau khi hoàn tất\n        setTransactionStatus(prev => prev + '\\n\\nĐang xóa dữ liệu guardian từ database...');\n        console.log(`Bắt đầu xóa dữ liệu guardian với mã mời: ${inviteCode}`);\n        const deleteResult = await deleteGuardianData(inviteCode);\n        if (deleteResult) {\n          console.log(`✅ ĐÃ XÓA THÀNH CÔNG dữ liệu guardian, invitation và lookup với mã mời: ${inviteCode}`);\n\n          // Cập nhật thông báo thành công rõ ràng hơn\n          setTransactionStatus(`✅ HOÀN TẤT THÀNH CÔNG!\n          \n          Guardian \"${guardianData.guardianName}\" (ID: ${guardianData.guardianId}) đã được thêm thành công vào ví.\n          \n          Địa chỉ Guardian: ${guardianPDA.toString()}\n          Signature: ${signature}\n          \n          ✅ Dữ liệu đã được xóa khỏi database để bảo vệ quyền riêng tư.\n          \n          ✅ Guardian hiện đã sẵn sàng sử dụng và đã được ẩn khỏi danh sách chờ.`);\n\n          // Bỏ mã mời đã sử dụng khỏi danh sách\n          setPendingInvites(prev => prev.filter(code => code !== inviteCode));\n\n          // Không đóng form sau khi hoàn tất để người dùng có thể tiếp tục thêm guardian khác\n          /* \n          if (pendingInvites.length <= 1) {\n            setShowInviteInput(false);\n          }\n          */\n        } else {\n          console.error(`❌ KHÔNG THỂ XÓA dữ liệu guardian với mã mời: ${inviteCode}`);\n          setTransactionStatus(prev => prev + '\\n❌ Không thể xóa dữ liệu guardian từ database.');\n        }\n\n        // Làm mới danh sách guardian và cập nhật UI\n        await getExistingGuardianIds();\n        await loadPendingInvites();\n\n        // Cập nhật số dư của ví\n        if (multisigAddress) {\n          await loadPdaBalance(multisigAddress);\n        }\n      } else {\n        setTransactionStatus('Lỗi: Fee payer không khả dụng');\n      }\n    } catch (error) {\n      console.error(\"Lỗi khi hoàn tất quá trình đăng ký guardian:\", error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      setTransactionStatus(`Lỗi khi hoàn tất quá trình đăng ký guardian: ${errorMessage}`);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: /*#__PURE__*/_jsxDEV(\"header\", {\n      className: \"App-header\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: \"Moon Wallet\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2084,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"V\\xED \\u0111a ch\\u1EEF k\\xFD an to\\xE0n tr\\xEAn Solana\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2085,\n        columnNumber: 9\n      }, this), !isLoggedIn ? /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"auth-section\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2088,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"wallet-section\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"mb-4\",\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            className: `tab-button ${!showTransfer ? 'active' : ''}`,\n            onClick: () => setShowTransfer(false),\n            children: \"Qu\\u1EA3n l\\xFD v\\xED\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2094,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            className: `tab-button ${showTransfer ? 'active' : ''}`,\n            onClick: () => setShowTransfer(true),\n            children: \"Chuy\\u1EC3n ti\\u1EC1n\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2100,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 2093,\n          columnNumber: 13\n        }, this), showTransfer ? /*#__PURE__*/_jsxDEV(Transfer, {\n          multisigAddress: multisigAddress,\n          balance: pdaBalance / LAMPORTS_PER_SOL,\n          withdrawFromMultisig: withdrawFromMultisig\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2109,\n          columnNumber: 15\n        }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"wallet-container\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2115,\n          columnNumber: 15\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2092,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 2083,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 2082,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"KTh4x2dt6m3UVGvb0lNqwDlThgw=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","Connection","PublicKey","Keypair","Transaction","SystemProgram","TransactionInstruction","LAMPORTS_PER_SOL","sendAndConfirmTransaction","Buffer","createWebAuthnCredential","getWebAuthnAssertionForLogin","calculateMultisigAddress","processCredentialIdForPDA","getMultisigPDA","getGuardianPDA","saveInvitation","getInvitation","getGuardianData","updateGuardianStatus","getPendingInvites","deleteGuardianData","getWalletByCredentialId","Transfer","jsxDEV","_jsxDEV","RPC_ENDPOINT","process","env","REACT_APP_RPC_ENDPOINT","PROGRAM_ID_STRING","REACT_APP_PROGRAM_ID","PROGRAM_ID","console","log","REACT_APP_FEE_PAYER_SECRET_KEY","split","length","connectionOptions","commitment","confirmTransactionInitialTimeout","disableRetryOnRateLimit","fetch","connection","ActionParams","constructor","props","amount","destination","tokenMint","TEMP_WALLET_PUBKEY","bufferToUint8Array","buffer","Uint8Array","byteOffset","byteLength","concatUint8Arrays","arrays","totalLength","reduce","acc","arr","result","offset","set","bigIntToLeBytes","value","bytesLength","i","Number","BigInt","calculateMultisigPDA","programId","credentialId","seedBuffer","from","toString","findProgramAddressSync","compressPublicKey","uncompressedKey","warn","randomKey","alloc","randomBytes","crypto","getRandomValues","x","slice","y","prefix","compressedKey","hashRecoveryPhrase","phrase","phraseBytes","TextEncoder","encode","inputBytes","Math","min","hashBuffer","subtle","digest","convertSecretKeyStringToUint8Array","secretKeyString","Error","numbers","map","s","parseInt","trim","bytes","hashCredentialId","encoder","data","App","_s","walletKeypair","setWalletKeypair","walletBalance","setWalletBalance","multisigAddress","setMultisigAddress","threshold","setThreshold","guardianName","setGuardianName","recoveryPhrase","setRecoveryPhrase","transactionStatus","setTransactionStatus","guardianPDA","setGuardianPDA","isLoadingBalance","setIsLoadingBalance","setCredentialId","webauthnPubkey","setWebauthnPubkey","walletName","setWalletName","isUsingTempWallet","setIsUsingTempWallet","newGuardianName","setNewGuardianName","newRecoveryPhrase","setNewRecoveryPhrase","existingGuardians","setExistingGuardians","showAddGuardianForm","setShowAddGuardianForm","projectFeePayerKeypair","setProjectFeePayerKeypair","usingProjectFeePayer","setUsingProjectFeePayer","feePayerBalance","setFeePayerBalance","isLoadingFeePayerBalance","setIsLoadingFeePayerBalance","pdaBalance","setPdaBalance","isLoadingPdaBalance","setIsLoadingPdaBalance","selectedGuardianId","setSelectedGuardianId","depositAmount","setDepositAmount","withdrawAmount","setWithdrawAmount","recipientAddress","setRecipientAddress","loginCredentialId","setLoginCredentialId","isLoggingIn","setIsLoggingIn","isLoggedIn","setIsLoggedIn","showLoginForm","setShowLoginForm","inviteLink","setInviteLink","inviteCode","setInviteCode","showQRCode","setShowQRCode","showInviteInput","setShowInviteInput","pendingInvites","setPendingInvites","showTransfer","setShowTransfer","newKeypair","generate","projectPayerPrivateKey","feePayerKeypair","fromSecretKey","loadFeePayerBalance","keypair","balance","getBalance","publicKey","error","useTempWallet","tempWalletPrivateKey","findMultisigAddress","loadBalance","message","createWalletWithWebAuthn","walletAddress","rawIdBase64","rawId","prev","multisigPDA","existingAccount","getAccountInfo","guardianId","guardianIdBytes","guardianPDAAddress","subarray","toBuffer","transaction","initMultisigDiscriminator","thresholdBytes","credentialIdString","credentialIdBuffer","credentialIdLenBuffer","writeUInt32LE","credentialIdLenBytes","credentialIdDataBytes","initData","add","keys","pubkey","isSigner","isWritable","feePayer","recentBlockhash","getLatestBlockhash","blockhash","instructions","ix","index","k","discriminator","Array","credentialIdLength","isOwner","hasWebauthn","webauthnPubkeyLength","signature","sendTransaction","confirmTransaction","guardianMultisigPDA","hashedRecoveryBytes","addGuardianDiscriminator","guardianIdBigIntBytes","guardianNameBuffer","guardianNameLenBuffer","recoveryHashIntermediateBytes","isOwnerByte","uncompressedKeyBuffer","compressedKeyBuffer","addGuardianData","addGuardianTransaction","addGuardianSignature","loadPdaBalance","pda","bump","pdaAddress","findGuardianAddress","guardianIdBigInt","requestAirdrop","fundFromValidator","validatorKey","transfer","fromPubkey","toPubkey","lamports","getWalletInfo","multisigAccount","guardian_count","recovery_nonce","DataView","getBigUint64","transaction_nonce","last_transaction_timestamp","getBigInt64","getGuardianInfo","guardianAccount","owner","equals","substring","walletBytes","wallet","nameLength","getUint32","nameOffset","nameBytes","name","TextDecoder","decode","currentOffset","isActive","recoveryHash","recoveryHashHex","webauthnHex","parseError","getExistingGuardianIds","guardianIds","push","includes","join","generateNewGuardianId","existingIds","newId","addNewGuardian","newGuardianId","guardianIdentifier","webAuthnResult","existingGuardian","Promise","resolve","setTimeout","newGuardianAccount","webAuthnError","depositToMultisig","lamportsToSend","withdrawFromMultisig","destinationAddressStr","destinationAddress","floor","feePayerSecretKey","assertion","success","action","amountBytes","destinationBytes","toBytes","tokenMintOption","signatureBytes","signatureLen","authenticatorData","authenticatorDataLen","clientDataJSON","clientDataJSONLen","concat","instruction","txSignature","testGuardianInfo","id","loginToWallet","assertionResult","credentialRawData","credentialIdHex","credentialMapping","walletAddressFromDB","walletAccount","generateRandomCode","chars","randomValues","charAt","generateGuardianInvite","ngrokUrl","REACT_APP_NGROK_URL","window","location","origin","status","ownerId","errorMessage","loadPendingInvites","multisigAddressStr","invitesList","fetchGuardianDataFromDatabase","fetchInviteFromDatabase","updateGuardianStatusInDatabase","completeGuardianRegistration","guardianData","inviteData","webauthnPublicKey","deleteResult","filter","code","checkGuardiansInDatabase","resultMessage","webauthnCredentialId","completeGuardianSetup","multisigPubkey","guardianIndex","guardianType","tx","findProgramAddress","instructionData","addGuardianIx","skipPreflight","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","_c","$RefreshReg$"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/acacac/src/App.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { Connection, PublicKey, Keypair, Transaction, SystemProgram, TransactionInstruction, Commitment, Signer, LAMPORTS_PER_SOL, sendAndConfirmTransaction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport './App.css';\nimport { createWebAuthnCredential, getWebAuthnAssertionForLogin, calculateMultisigAddress, getWebAuthnAssertion } from './utils/webauthnUtils';\nimport { processCredentialIdForPDA, getMultisigPDA, getGuardianPDA, getAllGuardianPDAs } from './utils/credentialUtils';\nimport { QRCodeSVG } from 'qrcode.react';\nimport { \n  saveInvitation, \n  getInvitation, \n  getGuardianData, \n  updateGuardianStatus,\n  getPendingInvites,\n  deleteGuardianData\n} from './firebase/guardianService';\nimport { getWalletByCredentialId } from './firebase/webAuthnService';\nimport Transfer from './components/Transfer';\n\n// Lấy các biến môi trường hoặc sử dụng giá trị mặc định\nconst RPC_ENDPOINT = process.env.REACT_APP_RPC_ENDPOINT || 'http://127.0.0.1:8899'; // Localhost validator\nconst PROGRAM_ID_STRING = process.env.REACT_APP_PROGRAM_ID || 'DeN1rBfabZezHPvrq9q7BbzUbZkrjnHE1kQDrPK8kWQ3'; // Program ID mới triển khai\n\n// Địa chỉ Program ID từ smart contract\nexport const PROGRAM_ID = new PublicKey(PROGRAM_ID_STRING);\n\n// Log biến môi trường để debug\nconsole.log(\"Biến môi trường RPC_ENDPOINT:\", process.env.REACT_APP_RPC_ENDPOINT);\nconsole.log(\"Biến môi trường PROGRAM_ID:\", process.env.REACT_APP_PROGRAM_ID);\nconsole.log(\"Biến môi trường FEE_PAYER_SECRET_KEY tồn tại:\", !!process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\nif (process.env.REACT_APP_FEE_PAYER_SECRET_KEY) {\n  console.log(\"Độ dài FEE_PAYER_SECRET_KEY:\", process.env.REACT_APP_FEE_PAYER_SECRET_KEY.split(',').length);\n}\n\n// Tùy chọn kết nối\nconst connectionOptions = {\n  commitment: 'confirmed' as Commitment,\n  confirmTransactionInitialTimeout: 60000,\n  disableRetryOnRateLimit: false,\n  fetch: fetch\n};\n\n// Connection với validator\nconst connection = new Connection(RPC_ENDPOINT, connectionOptions);\n\n// Schema cho các struct của chương trình\nclass ActionParams {\n  amount: number | null;\n  destination: PublicKey | null;\n  tokenMint: PublicKey | null;\n\n  constructor(props: { \n    amount: number | null; \n    destination: PublicKey | null; \n    tokenMint: PublicKey | null \n  }) {\n    this.amount = props.amount;\n    this.destination = props.destination;\n    this.tokenMint = props.tokenMint;\n  }\n}\n\n// Ví tạm thời đã được tạo và nhận SOL trước đó\nconst TEMP_WALLET_PUBKEY = '9Q8iZnAvCQP3uaDTuYbrvYSRDWB7Kk19u4TS1MDRSStJ';\n\n// Hàm chuyển đổi Buffer sang Uint8Array\nfunction bufferToUint8Array(buffer: Buffer): Uint8Array {\n  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n}\n\n// Hàm concat cho Uint8Array\nfunction concatUint8Arrays(...arrays: Uint8Array[]): Uint8Array {\n  // Tính tổng độ dài\n  const totalLength = arrays.reduce((acc, arr) => acc + arr.length, 0);\n  \n  // Tạo mảng mới với tổng độ dài\n  const result = new Uint8Array(totalLength);\n  \n  // Copy dữ liệu vào mảng mới\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  \n  return result;\n}\n\n// Hàm chuyển đổi từ BigInt (u64) sang bytes theo thứ tự little-endian\nconst bigIntToLeBytes = (value: bigint, bytesLength: number = 8): Uint8Array => {\n  const result = new Uint8Array(bytesLength);\n  for (let i = 0; i < bytesLength; i++) {\n    result[i] = Number((value >> BigInt(8 * i)) & BigInt(0xff));\n  }\n  return result;\n};\n\n// Helper function để tính toán MultisigPDA một cách nhất quán\nconst calculateMultisigPDA = async (programId: PublicKey, credentialId: string): Promise<[PublicKey, number]> => {\n  // Sử dụng hàm processCredentialIdForPDA từ helpers.ts để xử lý credential ID\n  // đảm bảo nhất quán với smart contract\n  const seedBuffer = processCredentialIdForPDA(credentialId);\n  console.log(\"Xử lý credential ID:\", credentialId);\n  console.log(\"Seed buffer để tính PDA:\", Buffer.from(seedBuffer).toString('hex'));\n  \n  return PublicKey.findProgramAddressSync(\n    [\n      Buffer.from(\"multisig\"),\n      seedBuffer\n    ],\n    programId\n  );\n};\n\n// Hàm nén khóa công khai từ dạng uncompressed (65 bytes) sang compressed (33 bytes)\nconst compressPublicKey = (uncompressedKey: Buffer): Buffer => {\n  // Đảm bảo khóa bắt đầu với byte 0x04 (không nén)\n  if (uncompressedKey[0] !== 0x04 || uncompressedKey.length !== 65) {\n    console.warn('Khóa không đúng định dạng không nén ECDSA, tạo khóa ngẫu nhiên');\n    // Tạo khóa random nếu không đúng định dạng\n    const randomKey = Buffer.alloc(33);\n    randomKey[0] = 0x02; // compressed, y is even\n    \n    // Tạo dữ liệu ngẫu nhiên cho 32 bytes còn lại\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    \n    // Sao chép vào buffer\n    for (let i = 0; i < 32; i++) {\n      randomKey[i+1] = randomBytes[i];\n    }\n    \n    return randomKey;\n  }\n  \n  // Lấy tọa độ x và y\n  const x = new Uint8Array(uncompressedKey.slice(1, 33));\n  const y = new Uint8Array(uncompressedKey.slice(33, 65));\n  \n  // Tính prefix: 0x02 nếu y chẵn, 0x03 nếu y lẻ\n  const prefix = (y[31] & 1) === 0 ? 0x02 : 0x03;\n  \n  // Tạo khóa nén: prefix (1 byte) + x (32 bytes)\n  const compressedKey = Buffer.alloc(33);\n  compressedKey[0] = prefix;\n  \n  // Copy x vào compressedKey từ vị trí 1\n  for (let i = 0; i < 32; i++) {\n    compressedKey[i + 1] = x[i];\n  }\n  \n  return compressedKey;\n};\n\n// Hàm hash recovery phrase tại frontend\nconst hashRecoveryPhrase = async (phrase: string): Promise<Uint8Array> => {\n  // Chuyển recovery phrase thành bytes\n  const phraseBytes = new TextEncoder().encode(phrase);\n  \n  // Tạo buffer 32 bytes để lưu dữ liệu\n  const inputBytes = new Uint8Array(32);\n  \n  // Sao chép dữ liệu từ phrase, đảm bảo không vượt quá 32 bytes\n  inputBytes.set(phraseBytes.slice(0, Math.min(phraseBytes.length, 32)));\n  \n  // Hash bằng SHA-256\n  const hashBuffer = await crypto.subtle.digest('SHA-256', inputBytes);\n  \n  // Chuyển kết quả thành Uint8Array\n  return new Uint8Array(hashBuffer);\n};\n\n// Chuyển đổi secret key từ chuỗi trong .env thành mảng số\nconst convertSecretKeyStringToUint8Array = (secretKeyString: string | undefined): Uint8Array => {\n  if (!secretKeyString) {\n    throw new Error('Fee payer secret key không được định nghĩa trong biến môi trường');\n  }\n  \n  // Chuyển đổi chuỗi \"1,2,3,...\" thành mảng số\n  const numbers = secretKeyString.split(',').map(s => parseInt(s.trim(), 10));\n  \n  // Kiểm tra kích thước hợp lệ (64 bytes cho ed25519)\n  if (numbers.length !== 64 && numbers.length !== 65) {\n    throw new Error(`Secret key phải có 64 hoặc 65 bytes, nhưng có ${numbers.length} bytes`);\n  }\n  \n  // Nếu có 65 bytes, bỏ qua byte cuối cùng (thường là checksum)\n  const bytes = numbers.length === 65 ? numbers.slice(0, 64) : numbers;\n  \n  return new Uint8Array(bytes);\n};\n\n// Add this function near the top with other utility functions\nconst hashCredentialId = async (credentialId: string): Promise<Uint8Array> => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(credentialId);\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  return new Uint8Array(hashBuffer);\n};\n\nfunction App() {\n  const [walletKeypair, setWalletKeypair] = useState<Keypair | null>(null);\n  const [walletBalance, setWalletBalance] = useState<number>(0);\n  const [multisigAddress, setMultisigAddress] = useState<PublicKey | null>(null);\n  const [threshold, setThreshold] = useState<number>(1);\n  const [guardianName, setGuardianName] = useState<string>('Owner');\n  const [recoveryPhrase, setRecoveryPhrase] = useState<string>('');\n  const [transactionStatus, setTransactionStatus] = useState<string>('');\n  const [guardianPDA, setGuardianPDA] = useState<PublicKey | null>(null);\n  const [isLoadingBalance, setIsLoadingBalance] = useState<boolean>(false);\n  const [credentialId, setCredentialId] = useState<string>('');\n  const [webauthnPubkey, setWebauthnPubkey] = useState<string>('');\n  const [walletName, setWalletName] = useState<string>('My Moon Wallet');\n  const [isUsingTempWallet, setIsUsingTempWallet] = useState<boolean>(false);\n  // Thêm state cho new guardian\n  const [newGuardianName, setNewGuardianName] = useState<string>('');\n  const [newRecoveryPhrase, setNewRecoveryPhrase] = useState<string>('');\n  const [existingGuardians, setExistingGuardians] = useState<number[]>([]);  // Lưu các guardian ID đã tồn tại\n  const [showAddGuardianForm, setShowAddGuardianForm] = useState<boolean>(false);\n  // Thêm state cho fee payer của dự án\n  const [projectFeePayerKeypair, setProjectFeePayerKeypair] = useState<Keypair | null>(null);\n  const [usingProjectFeePayer, setUsingProjectFeePayer] = useState<boolean>(true);\n  const [feePayerBalance, setFeePayerBalance] = useState<number>(0);\n  const [isLoadingFeePayerBalance, setIsLoadingFeePayerBalance] = useState<boolean>(false);\n  // Thêm state cho số dư PDA\n  const [pdaBalance, setPdaBalance] = useState<number>(0);\n  const [isLoadingPdaBalance, setIsLoadingPdaBalance] = useState<boolean>(false);\n  // Thêm state cho việc chọn guardian ID\n  const [selectedGuardianId, setSelectedGuardianId] = useState<number>(1);\n  // State cho form nạp tiền\n  const [depositAmount, setDepositAmount] = useState<number>(0.1);\n  // State cho form rút tiền\n  const [withdrawAmount, setWithdrawAmount] = useState<number>(0.05);\n  const [recipientAddress, setRecipientAddress] = useState<string>('');\n  // State cho form đăng nhập ví\n  const [loginCredentialId, setLoginCredentialId] = useState<string>('');\n  const [isLoggingIn, setIsLoggingIn] = useState<boolean>(false);\n  const [isLoggedIn, setIsLoggedIn] = useState<boolean>(false);\n  const [showLoginForm, setShowLoginForm] = useState<boolean>(false);\n  \n  // Thêm state cho chức năng tạo invitation\n  const [inviteLink, setInviteLink] = useState<string>('');\n  const [inviteCode, setInviteCode] = useState<string>('');\n  const [showQRCode, setShowQRCode] = useState<boolean>(false);\n  const [showInviteInput, setShowInviteInput] = useState<boolean>(false);\n  const [pendingInvites, setPendingInvites] = useState<string[]>([]);\n  const [showTransfer, setShowTransfer] = useState<boolean>(false);\n\n  // Tạo keypair mới khi component được mount\n  useEffect(() => {\n    // Tạo keypair ngẫu nhiên mới cho user\n    const newKeypair = Keypair.generate();\n    setWalletKeypair(newKeypair);\n    \n    // Tạo keypair cố định cho dự án để trả phí\n    // Trong môi trường thực tế, bạn có thể lấy keypair này từ server hoặc một nguồn an toàn\n    const projectPayerPrivateKey = convertSecretKeyStringToUint8Array(process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\n    \n    // Sử dụng keypair cố định cho fee payer\n    const feePayerKeypair = Keypair.fromSecretKey(projectPayerPrivateKey);\n    setProjectFeePayerKeypair(feePayerKeypair);\n    \n    // Load balance cho fee payer\n    loadFeePayerBalance(feePayerKeypair);\n    \n    // Không tính PDA ngay vì chưa có credential ID\n    // findMultisigAddress sẽ được gọi sau khi người dùng tạo WebAuthn credential\n  }, []);\n\n  // Thêm hàm để load balance của fee payer\n  const loadFeePayerBalance = async (keypair: Keypair) => {\n    try {\n      setIsLoadingFeePayerBalance(true);\n      const balance = await connection.getBalance(keypair.publicKey);\n      console.log(`Fee payer balance: ${balance / 1_000_000_000} SOL`);\n      \n      // Nếu balance quá thấp, có thể gửi thông báo cảnh báo\n      if (balance < 100_000_000) { // dưới 0.1 SOL\n        console.warn(\"Fee payer balance thấp, cần nạp thêm SOL\");\n      }\n      \n      setFeePayerBalance(balance / 1_000_000_000);\n    } catch (error) {\n      console.error(\"Lỗi khi load balance của fee payer:\", error);\n    } finally {\n      setIsLoadingFeePayerBalance(false);\n    }\n  };\n\n  // Sử dụng ví tạm thời đã có SOL\n  const useTempWallet = async () => {\n    try {\n      setTransactionStatus('Đang tải ví tạm thời với SOL...');\n      \n      // Sử dụng cùng secret key của fee payer\n      const tempWalletPrivateKey = convertSecretKeyStringToUint8Array(process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\n      \n      // Tạo Keypair từ private key\n      const keypair = Keypair.fromSecretKey(tempWalletPrivateKey);\n      \n      setWalletKeypair(keypair);\n      setIsUsingTempWallet(true);\n      \n      // Tính PDA mới dựa trên keypair mới\n      findMultisigAddress();\n      \n      // Tải balance của ví tạm thời\n      await loadBalance(keypair);\n      \n      setTransactionStatus(`Đã chuyển sang ví tạm thời: ${keypair.publicKey.toString()}. Ví này đã có sẵn SOL để giao dịch.`);\n    } catch (error: any) {\n      console.error('Lỗi khi tải ví tạm thời:', error);\n      setTransactionStatus(`Lỗi khi tải ví tạm thời: ${error.message}`);\n    }\n  };\n\n  // Tải balance với xử lý lỗi tốt hơn\n  const loadBalance = async (keypair?: Keypair) => {\n    const publicKey = keypair?.publicKey || walletKeypair?.publicKey;\n    if (!publicKey) return;\n    \n    setIsLoadingBalance(true);\n    try {\n      console.log(\"Đang tải balance cho địa chỉ:\", publicKey.toString());\n      const balance = await connection.getBalance(publicKey);\n      console.log(\"Balance đã tải thành công:\", balance / 1_000_000_000);\n      setWalletBalance(balance / 1_000_000_000); // Chuyển từ lamports sang SOL\n    } catch (error: any) {\n      console.error('Lỗi khi tải balance:', error);\n      // Không hiển thị lỗi cho người dùng, chỉ log ra console\n    } finally {\n      setIsLoadingBalance(false);\n    }\n  };\n\n  // Tạo ví với WebAuthn\n  const createWalletWithWebAuthn = async () => {\n    try {\n      // Kiểm tra xem người dùng đã nhập recovery phrase chưa\n      if (!recoveryPhrase || recoveryPhrase.trim().length < 8) {\n        setTransactionStatus('Vui lòng nhập recovery phrase (ít nhất 8 ký tự) trước khi tạo ví');\n        return;\n      }\n      \n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n      \n      setTransactionStatus('Đang tạo ví Moon Wallet...\\n\\nBước 1: Đang tạo khóa WebAuthn...');\n      \n      // 1. Tạo khóa WebAuthn\n      const walletAddress = projectFeePayerKeypair.publicKey.toString(); // Sử dụng địa chỉ của fee payer\n      const result = await createWebAuthnCredential(walletAddress, walletName);\n      \n      // Chuyển đổi rawId thành base64 để lưu trữ và sử dụng\n      const rawIdBase64 = Buffer.from(result.rawId).toString('base64');\n      \n      // Lưu thông tin WebAuthn\n      setCredentialId(rawIdBase64); // Lưu base64 thay vì hex\n      setWebauthnPubkey(result.publicKey);\n      \n      setTransactionStatus(prev => prev + `\\nĐã tạo khóa WebAuthn thành công!\\nCredential ID (base64): ${rawIdBase64.slice(0, 10)}...\\nPublic Key: ${result.publicKey.slice(0, 10)}...`);\n      \n      // 2. Tính PDA cho Multisig\n      const multisigPDA = getMultisigPDA(rawIdBase64);\n      console.log(\"Multisig PDA:\", multisigPDA.toString());\n      \n      setMultisigAddress(multisigPDA);\n      setTransactionStatus(prev => prev + `\\n\\nBước 2: Đang khởi tạo ví multisig tại địa chỉ: ${multisigPDA.toString()}...`);\n      \n      // Kiểm tra xem multisig account đã tồn tại chưa\n      const existingAccount = await connection.getAccountInfo(multisigPDA);\n      if (existingAccount) {\n        setTransactionStatus(prev => prev + `\\n\\nLỖI: Ví multisig với credential ID này đã tồn tại. Điều này gần như không thể xảy ra vì credential ID luôn duy nhất.`);\n        return;\n      }\n      \n      // 3. Tính PDA address cho guardian\n      // Tạo ID dạng u64 cho guardian\n      const guardianId = BigInt(1); // Owner có ID = 1\n\n      // Chuyển đổi guardianId sang bytes (little-endian)\n      const guardianIdBytes = bigIntToLeBytes(guardianId);\n      \n      const [guardianPDAAddress] = PublicKey.findProgramAddressSync(\n        [\n          Buffer.from(\"guardian\").subarray(0),\n          multisigPDA.toBuffer(),\n          guardianIdBytes\n        ],\n        PROGRAM_ID\n      );\n      \n      setGuardianPDA(guardianPDAAddress);\n      \n      // 4. Tạo transaction tích hợp để khởi tạo multisig và thêm guardian owner\n      const transaction = new Transaction();\n      \n      // 4.1 Khởi tạo Multisig\n      // Đây là discriminator cho initialize_multisig (sử dụng giá trị chính xác từ Anchor IDL)\n      const initMultisigDiscriminator = new Uint8Array([220, 130, 117, 21, 27, 227, 78, 213]);\n      const thresholdBytes = new Uint8Array([threshold]);\n      \n      // LƯU Ý QUAN TRỌNG: credential_id trong smart contract sử dụng as_bytes() trực tiếp, \n      // nên chúng ta phải gửi chính xác chuỗi rawIdBase64 như một chuỗi UTF-8\n      // không phải decode nó sang dạng binary\n      const credentialIdString = rawIdBase64;\n      const credentialIdBuffer = Buffer.from(credentialIdString);\n      console.log(\"Credential ID gửi đi (chuỗi gốc):\", credentialIdString);\n      \n      const credentialIdLenBuffer = Buffer.alloc(4);\n      credentialIdLenBuffer.writeUInt32LE(credentialIdBuffer.length, 0);\n      const credentialIdLenBytes = bufferToUint8Array(credentialIdLenBuffer);\n      const credentialIdDataBytes = bufferToUint8Array(credentialIdBuffer);\n      \n      // Tạo dữ liệu instruction theo đúng cấu trúc contract yêu cầu\n      const initData = concatUint8Arrays(\n        initMultisigDiscriminator,\n        thresholdBytes,\n        credentialIdLenBytes,\n        credentialIdDataBytes\n      );\n      \n      // Thêm instruction khởi tạo multisig vào transaction\n      transaction.add(new TransactionInstruction({\n        keys: [\n          { pubkey: multisigPDA, isSigner: false, isWritable: true },\n          { pubkey: projectFeePayerKeypair.publicKey, isSigner: true, isWritable: true },\n          { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n        ],\n        programId: PROGRAM_ID,\n        data: Buffer.from(initData)\n      }));\n      \n      // Sign và gửi transaction\n      transaction.feePayer = projectFeePayerKeypair.publicKey;\n      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      \n      // Thông báo cho người dùng\n      setTransactionStatus(prev => prev + '\\nĐang gửi transaction để khởi tạo ví và thêm guardian owner...');\n      \n      // Log dữ liệu transaction để debug\n      console.log(\"Transaction data:\", {\n        instructions: transaction.instructions.map((ix, index) => ({\n          programId: ix.programId.toString(),\n          keys: ix.keys.map(k => ({\n            pubkey: k.pubkey.toString(),\n            isSigner: k.isSigner,\n            isWritable: k.isWritable\n          })),\n          data: index === 1 ? {\n            discriminator: Array.from(initMultisigDiscriminator),\n            threshold: threshold,\n            credentialIdLength: credentialIdBuffer.length,\n            credentialId: Array.from(credentialIdBuffer),\n            isOwner: true,\n            hasWebauthn: true,\n            webauthnPubkeyLength: result.publicKey.length\n          } : \"initMultisig\"\n        }))\n      });\n      \n      const signature = await connection.sendTransaction(\n        transaction,\n        [projectFeePayerKeypair]\n      );\n      \n      await connection.confirmTransaction(signature);\n      setTransactionStatus(prev => prev + `\\nVí multisig đã được khởi tạo thành công! Signature: ${signature}`);\n      \n      // 5. Thêm guardian đầu tiên (owner)\n      setTransactionStatus(prev => prev + '\\n\\nBước 3: Đang thêm guardian owner đầu tiên...');\n\n      try {\n        // Tính PDA cho guardian\n        const guardianId = BigInt(1); // Owner có ID = 1\n        const guardianIdBytes = bigIntToLeBytes(guardianId);\n        \n        // 5.1 Tính PDA cho multisig với credential_id\n        const guardianMultisigPDA = multisigPDA;\n        \n        console.log(\"Sử dụng PDA cho guardian với multisig PDA:\", guardianMultisigPDA.toString());\n        \n        // 5.2 Tính PDA cho guardian\n        const guardianPDA = getGuardianPDA(guardianMultisigPDA, 1); // Owner có ID = 1\n        \n        setGuardianPDA(guardianPDA);\n        \n        // Hash recovery phrase tại frontend\n        console.log(\"Recovery phrase gốc:\", recoveryPhrase);\n        const hashedRecoveryBytes = await hashRecoveryPhrase(recoveryPhrase);\n        console.log(\"Recovery phrase sau khi hash tại frontend:\", Buffer.from(hashedRecoveryBytes).toString('hex'));\n        \n        // Tạo discriminator cho add_guardian\n        const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n        \n        // Chuyển guardian ID thành bytes\n        const guardianIdBigIntBytes = bigIntToLeBytes(guardianId);\n        \n        // Chuẩn bị tên guardian\n        const guardianNameBuffer = Buffer.from(guardianName || 'Owner');\n        const guardianNameLenBuffer = Buffer.alloc(4);\n        guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n        \n        // Chuẩn bị recovery hash - sử dụng giá trị đã hash\n        const recoveryHashIntermediateBytes = hashedRecoveryBytes;\n        \n        // Chuẩn bị các tham số khác\n        const isOwnerByte = new Uint8Array([1]); // true = 1\n        \n        // WebAuthn pubkey - nén khóa từ 65 bytes (uncompressed) thành 33 bytes (compressed)\n        // Smart contract yêu cầu webauthn_pubkey: Option<[u8; 33]>\n        const uncompressedKeyBuffer = Buffer.from(result.publicKey, 'hex');\n        console.log(\"WebAuthn key (uncompressed, 65 bytes):\", result.publicKey);\n        \n        // Nén khóa thành 33 bytes\n        const compressedKeyBuffer = compressPublicKey(uncompressedKeyBuffer);\n        console.log(\"WebAuthn key (compressed, 33 bytes):\", compressedKeyBuffer.toString('hex'));\n        \n        // Nối tất cả lại với nhau\n        const addGuardianData = concatUint8Arrays(\n          addGuardianDiscriminator,\n          // guardian_id (u64)\n          bufferToUint8Array(Buffer.from(guardianIdBigIntBytes)),\n          // guardian_name (string)\n          bufferToUint8Array(guardianNameLenBuffer),\n          bufferToUint8Array(guardianNameBuffer),\n          // recovery_hash_intermediate ([u8; 32])\n          recoveryHashIntermediateBytes,\n          // is_owner (bool)\n          isOwnerByte,\n          // webauthn_pubkey (Option<[u8; 33]>)\n          new Uint8Array([1]), // Some variant\n          bufferToUint8Array(compressedKeyBuffer) // Sử dụng khóa đã được nén\n        );\n        \n        // Tạo transaction add guardian\n        const addGuardianTransaction = new Transaction();\n        addGuardianTransaction.add(\n          new TransactionInstruction({\n            keys: [\n              { pubkey: multisigPDA, isSigner: false, isWritable: true },\n              { pubkey: guardianPDA, isSigner: false, isWritable: true },\n              { pubkey: projectFeePayerKeypair.publicKey, isSigner: false, isWritable: false },\n              { pubkey: projectFeePayerKeypair.publicKey, isSigner: true, isWritable: true },\n              { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n            ],\n            programId: PROGRAM_ID,\n            data: Buffer.from(addGuardianData)\n          })\n        );\n        \n        // Sign và gửi transaction\n        addGuardianTransaction.feePayer = projectFeePayerKeypair.publicKey;\n        addGuardianTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n        \n        const addGuardianSignature = await connection.sendTransaction(\n          addGuardianTransaction,\n          [projectFeePayerKeypair]\n        );\n        \n        await connection.confirmTransaction(addGuardianSignature);\n        setTransactionStatus(prev => prev + `\\nGuardian owner đã được thêm thành công! Signature: ${addGuardianSignature}`);\n      } catch (error: any) {\n        console.error(\"Lỗi khi thêm guardian owner:\", error);\n        setTransactionStatus(prev => prev + `\\nLỗi khi thêm guardian owner: ${error.message}`);\n      }\n      \n      // 6. Hoàn thành quá trình tạo ví\n      setTransactionStatus(prev => prev + '\\n\\n✅ VÍ MOON WALLET ĐÃ ĐƯỢC TẠO THÀNH CÔNG!\\n' +\n        `Địa chỉ ví Multisig: ${multisigPDA.toString()}\\n` +\n        `Recovery Phrase: ${recoveryPhrase}\\n` +\n        'Vui lòng lưu lại thông tin này để sử dụng sau này!');\n      \n      // Kiểm tra số dư của ví PDA sau khi tạo\n      await loadPdaBalance(multisigPDA);\n      \n    } catch (error: any) {\n      console.error('Lỗi trong quá trình tạo ví:', error);\n      setTransactionStatus(`Lỗi: ${error.message}`);\n    }\n  };\n\n  // Sửa lại hàm tính PDA cho multisig wallet\n  const findMultisigAddress = async () => {\n    // Sử dụng credential ID (nếu có) hoặc một giá trị tạm thời nếu chưa có\n    if (!credentialId) {\n      // Nếu chưa có credential ID, không thể tính PDA chính xác\n      setMultisigAddress(null);\n      return;\n    }\n    \n    console.log(\"findMultisigAddress - credential ID:\", credentialId);\n    \n    // Sử dụng helper function để tính PDA một cách nhất quán\n    const [pda, bump] = await calculateMultisigAddress(PROGRAM_ID, credentialId);\n    console.log(\"findMultisigAddress - PDA:\", pda.toString(), \"bump:\", bump);\n    \n    setMultisigAddress(pda);\n    \n    // Load balance cho PDA\n    await loadPdaBalance(pda);\n  };\n\n  // Tải balance với xử lý lỗi tốt hơn\n  const loadPdaBalance = async (pdaAddress: PublicKey) => {\n    try {\n      setIsLoadingPdaBalance(true);\n      const balance = await connection.getBalance(pdaAddress);\n      console.log(`PDA balance: ${balance / 1_000_000_000} SOL`);\n      setPdaBalance(balance / 1_000_000_000);\n    } catch (error) {\n      console.error(\"Lỗi khi load balance của PDA:\", error);\n    } finally {\n      setIsLoadingPdaBalance(false);\n    }\n  };\n\n  // Tính PDA address cho guardian\n  const findGuardianAddress = async (guardianId: number = 1) => {\n    if (!multisigAddress) return null;\n    \n    try {\n      // Chuyển đổi guardianId sang bytes (little-endian)\n      const guardianIdBigInt = BigInt(guardianId);\n      const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n      \n      // Tính PDA cho guardian trực tiếp từ multisigAddress\n      const [guardianPDA] = PublicKey.findProgramAddressSync(\n        [\n          Buffer.from(\"guardian\"),\n          multisigAddress.toBuffer(),\n          guardianIdBytes\n        ],\n        PROGRAM_ID\n      );\n      \n      console.log(`Tính PDA cho guardian ID ${guardianId} với multisig: ${multisigAddress.toString()}`);\n      console.log(`Guardian PDA: ${guardianPDA.toString()}`);\n      \n      if (guardianId === 1) {\n        setGuardianPDA(guardianPDA); // Chỉ set state cho guardian chính (ID=1)\n      }\n      return guardianPDA;\n    } catch (error) {\n      console.error(`Lỗi khi tính PDA cho guardian ID ${guardianId}:`, error);\n      return null;\n    }\n  };\n\n  // Airdrop SOL cho testing\n  const requestAirdrop = async () => {\n    if (!projectFeePayerKeypair) {\n      setTransactionStatus('Không tìm thấy fee payer của dự án.');\n      return;\n    }\n    \n    try {\n      setTransactionStatus('Đang yêu cầu airdrop cho fee payer của dự án...');\n      const signature = await connection.requestAirdrop(\n        projectFeePayerKeypair.publicKey,\n        2_000_000_000 // 2 SOL\n      );\n      \n      await connection.confirmTransaction(signature);\n      // Tải lại số dư của fee payer\n      await loadFeePayerBalance(projectFeePayerKeypair);\n      setTransactionStatus('Airdrop thành công! 2 SOL đã được thêm vào ví fee payer của dự án.');\n    } catch (error: any) {\n      console.error('Lỗi khi thực hiện airdrop:', error);\n      setTransactionStatus(`Lỗi airdrop: ${error.message}. Đang thử phương thức chuyển tiền trực tiếp...`);\n      \n      // Thử phương pháp khác nếu airdrop thất bại\n      fundFromValidator(projectFeePayerKeypair);\n    }\n  };\n\n  // Chuyển tiền từ validator wallet sang ví người dùng \n  const fundFromValidator = async (keypair: Keypair) => {\n    try {\n      setTransactionStatus('Đang chuyển tiền từ validator vào fee payer...');\n      \n      // Tạo kết nối với validator wallet (địa chỉ mặc định của validator)\n      const validatorKey = new PublicKey('E6mJJmCvg4PDhanmaBxxeyTczza9vKpMgirRUD6Qz5kv');\n      \n      // Tạo transaction chuyển tiền\n      const transaction = new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: validatorKey,\n          toPubkey: keypair.publicKey,\n          lamports: 2_000_000_000 // 2 SOL\n        })\n      );\n      \n      // Lấy các thông tin cần thiết cho transaction\n      transaction.feePayer = validatorKey;\n      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      \n      // Không thể ký transaction vì không có private key của validator\n      // Thay vào đó, sử dụng phương thức sendTransactionWithRetry không cần chữ ký\n      const signature = await connection.sendTransaction(\n        transaction,\n        [] // Không cần signers khi gửi đến validator local\n      );\n      \n      await connection.confirmTransaction(signature);\n      \n      // Tải lại số dư\n      if (keypair === projectFeePayerKeypair) {\n        await loadFeePayerBalance(keypair);\n        setTransactionStatus('Chuyển tiền thành công! 2 SOL đã được thêm vào ví fee payer của dự án.');\n      } else {\n        await loadBalance(keypair);\n        setTransactionStatus('Chuyển tiền thành công! 2 SOL đã được thêm vào ví.');\n      }\n    } catch (error: any) {\n      console.error('Lỗi khi chuyển tiền từ validator:', error);\n      setTransactionStatus(`Lỗi khi chuyển tiền: ${error.message}. Hãy thử khởi động lại validator.`);\n    }\n  };\n\n  // Xem thông tin wallet\n  const getWalletInfo = async () => {\n    if (!multisigAddress) return;\n    \n    try {\n      setTransactionStatus('Đang truy vấn thông tin ví...');\n      \n      // Load balance trước\n      await loadPdaBalance(multisigAddress);\n      \n      const multisigAccount = await connection.getAccountInfo(multisigAddress);\n      \n      if (!multisigAccount) {\n        setTransactionStatus('Ví chưa được khởi tạo');\n        return;\n      }\n      \n      // Bỏ qua 8 byte discriminator\n      const data = multisigAccount.data.slice(8);\n      \n      // Parse dữ liệu dựa trên struct MultiSigWallet mới\n      // MultiSigWallet: threshold, guardian_count, recovery_nonce, bump, transaction_nonce, last_transaction_timestamp\n      const threshold = data[0];\n      const guardian_count = data[1];\n      const recovery_nonce = new DataView(data.buffer, data.byteOffset + 2, 8).getBigUint64(0, true);\n      const bump = data[10];\n      const transaction_nonce = new DataView(data.buffer, data.byteOffset + 11, 8).getBigUint64(0, true);\n      const last_transaction_timestamp = new DataView(data.buffer, data.byteOffset + 19, 8).getBigInt64(0, true);\n      \n      // Hiển thị thông tin\n      setTransactionStatus(\n        `Thông tin ví:\\n` +\n        `- Threshold: ${threshold}\\n` +\n        `- Guardian Count: ${guardian_count}\\n` +\n        `- Recovery Nonce: ${recovery_nonce}\\n` +\n        `- Bump: ${bump}\\n` +\n        `- Transaction Nonce: ${transaction_nonce}\\n` +\n        `- Last Transaction Timestamp: ${last_transaction_timestamp}`\n      );\n    } catch (error: any) {\n      console.error('Lỗi khi truy vấn thông tin ví:', error);\n      setTransactionStatus(`Lỗi: ${error.message}`);\n    }\n  };\n  \n  // Xem thông tin guardian\n  const getGuardianInfo = async () => {\n    if (!multisigAddress) {\n      setTransactionStatus('Vui lòng tạo ví trước khi xem thông tin guardian');\n      return;\n    }\n    \n    try {\n      setTransactionStatus(`Đang truy vấn thông tin guardian ID=${selectedGuardianId}...`);\n      \n      // Tính guardian PDA dựa trên ID được chọn\n      const guardianPDA = await findGuardianAddress(selectedGuardianId);\n      \n      if (!guardianPDA) {\n        setTransactionStatus('Không thể tìm thấy địa chỉ Guardian');\n        return;\n      }\n      \n      console.log(`Đang truy vấn thông tin guardian ID=${selectedGuardianId} với PDA: ${guardianPDA.toString()}`);\n      const guardianAccount = await connection.getAccountInfo(guardianPDA);\n      \n      if (!guardianAccount) {\n        console.log(`Không tìm thấy thông tin account tại địa chỉ: ${guardianPDA.toString()}`);\n        setTransactionStatus(`Guardian với ID=${selectedGuardianId} chưa được khởi tạo hoặc không tồn tại`);\n        return;\n      }\n      \n      console.log(`Đã tìm thấy account tại địa chỉ: ${guardianPDA.toString()}`);\n      console.log(`Data size: ${guardianAccount.data.length} bytes`);\n      console.log(`Owner: ${guardianAccount.owner.toString()}`);\n      \n      // Kiểm tra xem account có thuộc về program của chúng ta không\n      if (!guardianAccount.owner.equals(PROGRAM_ID)) {\n        console.error(`Account không thuộc về program của chúng ta. Owner: ${guardianAccount.owner.toString()}`);\n        setTransactionStatus(`Guardian với ID=${selectedGuardianId} không thuộc về program của chúng ta`);\n        return;\n      }\n      \n      // Bỏ qua 8 byte discriminator\n      const data = guardianAccount.data.slice(8);\n      console.log(`Data sau khi bỏ qua discriminator: ${data.length} bytes`);\n      console.log(`Raw data: ${Buffer.from(data).toString('hex').substring(0, 100)}...`);\n      \n      try {\n        // Parse dữ liệu dựa trên struct Guardian\n        // Guardian struct trên Rust: \n        // pub struct Guardian {\n        //     pub wallet: Pubkey,                  // 32 bytes\n        //     pub guardian_id: u64,                // 8 bytes\n        //     pub name: String,                    // 4 bytes length + n bytes string\n        //     pub is_active: bool,                 // 1 byte\n        //     pub recovery_hash_intermediate: [u8; 32], // 32 bytes\n        //     pub is_owner: bool,                  // 1 byte\n        //     pub webauthn_pubkey: Option<[u8; 33]>, // 1 byte discriminator + 33 bytes if Some\n        //     pub bump: u8,                        // 1 byte\n        // }\n        \n        // Đọc wallet address (32 bytes)\n        const walletBytes = data.slice(0, 32);\n        const wallet = new PublicKey(walletBytes);\n        console.log(`Wallet address parsed: ${wallet.toString()}`);\n        \n        // Đọc guardian_id (8 bytes - u64)\n        const guardianIdBytes = data.slice(32, 40);\n        let guardianId = BigInt(0);\n        for (let i = 0; i < 8; i++) {\n          guardianId |= BigInt(guardianIdBytes[i]) << BigInt(8 * i);\n        }\n        console.log(`Guardian ID parsed: ${guardianId}`);\n        \n        // Đọc name (string dài tối đa 32 bytes)\n        const nameLength = new DataView(data.buffer, data.byteOffset + 40, 4).getUint32(0, true);\n        console.log(`Guardian name length: ${nameLength}`);\n        \n        if (nameLength > 100) {\n          console.error(`Name length quá lớn: ${nameLength}, có thể không đúng cấu trúc dữ liệu`);\n          throw new Error(\"Lỗi parse dữ liệu guardian: Name length không hợp lệ\");\n        }\n        \n        // Vị trí bắt đầu của name bytes\n        const nameOffset = 44;\n        const nameBytes = data.slice(nameOffset, nameOffset + nameLength);\n        const name = new TextDecoder().decode(nameBytes);\n        console.log(`Guardian name parsed: ${name}`);\n        \n        // Vị trí tiếp theo sau name\n        let currentOffset = nameOffset + nameLength;\n        \n        // Đọc is_active (1 byte)\n        const isActive = data[currentOffset] === 1;\n        console.log(`Is active byte: ${data[currentOffset]} (offset: ${currentOffset})`);\n        currentOffset += 1;\n        \n        // Đọc recovery_hash (32 bytes)\n        const recoveryHash = data.slice(currentOffset, currentOffset + 32);\n        const recoveryHashHex = Buffer.from(recoveryHash).toString('hex');\n        console.log(`Recovery hash (hex): ${recoveryHashHex} (offset: ${currentOffset})`);\n        currentOffset += 32;\n        \n        // Đọc is_owner (1 byte)\n        const isOwner = data[currentOffset] === 1;\n        console.log(`Is owner byte: ${data[currentOffset]} (offset: ${currentOffset})`);\n        currentOffset += 1;\n        \n        // Đọc webauthn_pubkey (option, 1 byte discriminator + 33 bytes if Some)\n        const hasWebauthn = data[currentOffset] === 1;\n        console.log(`Has webauthn byte: ${data[currentOffset]} (offset: ${currentOffset})`);\n        currentOffset += 1;\n        \n        let webauthnPubkey = null;\n        if (hasWebauthn) {\n          webauthnPubkey = data.slice(currentOffset, currentOffset + 33);\n          const webauthnHex = Buffer.from(webauthnPubkey).toString('hex');\n          console.log(`WebAuthn pubkey: ${webauthnHex} (offset: ${currentOffset})`);\n          // Log thêm thông tin về format của key\n          console.log(`WebAuthn key format byte: 0x${webauthnHex.slice(0, 2)} (${webauthnPubkey[0]})`);\n          currentOffset += 33;\n        }\n        \n        // Đọc bump (1 byte)\n        const bump = data[currentOffset];\n        console.log(`Bump: ${bump} (offset: ${currentOffset})`);\n        \n        // Hiển thị thông tin\n        setTransactionStatus(\n          `Thông tin Guardian (ID=${guardianId}):\\n` +\n          `- Loại Guardian: ${isOwner ? 'Owner (Quản trị viên)' : 'Regular (Thành viên)'}\\n` +\n          `- Wallet: ${wallet.toString()}\\n` +\n          `- Guardian ID: ${guardianId}\\n` +\n          `- Name: ${name}\\n` +\n          `- Active: ${isActive ? 'Có' : 'Không'}\\n` +\n          `- Recovery Hash: ${recoveryHashHex.slice(0, 10)}...${recoveryHashHex.slice(-10)}\\n` +\n          (hasWebauthn ? `- WebAuthn Key: ${Buffer.from(webauthnPubkey!).toString('hex')}\\n` : '') +\n          (hasWebauthn ? `- WebAuthn Key Format: ${webauthnPubkey![0] === 2 ? '02 (even y)' : \n                                                (webauthnPubkey![0] === 3 ? '03 (odd y)' : \n                                                webauthnPubkey![0].toString())}\\n` : '') +\n          (hasWebauthn ? `- Công dụng: ${isOwner ? 'Dùng để ký giao dịch và quản lý ví' : 'Dùng để xác thực từ thiết bị này'}\\n` : '') +\n          `- Bump: ${bump}\\n` +\n          `- PDA: ${guardianPDA.toString()}`\n        );\n      } catch (parseError) {\n        console.error(\"Lỗi khi parse dữ liệu guardian:\", parseError);\n        \n        // Hiển thị thông tin thô nếu không thể parse\n        setTransactionStatus(\n          `Không thể parse dữ liệu guardian chi tiết. Dữ liệu thô:\\n` +\n          `- PDA: ${guardianPDA.toString()}\\n` +\n          `- Data size: ${guardianAccount.data.length} bytes\\n` +\n          `- Raw data: ${Buffer.from(guardianAccount.data).toString('hex').substring(0, 100)}...\\n` +\n          `- Error: ${parseError}`\n        );\n      }\n    } catch (error: any) {\n      console.error('Lỗi khi truy vấn thông tin guardian:', error);\n      setTransactionStatus(`Lỗi: ${error.message}`);\n    }\n  };\n\n  // Hàm để lấy danh sách guardian ID hiện có\n  const getExistingGuardianIds = async () => {\n    if (!multisigAddress) return [];\n    \n    try {\n      setTransactionStatus('Đang kiểm tra danh sách Guardian ID...');\n      \n      const guardianIds: number[] = [];\n      \n      // Kiểm tra guardian từ ID 1 đến 8\n      for (let i = 1; i <= 8; i++) {\n        try {\n          // Tính PDA cho guardian với ID i sử dụng hàm đã sửa\n          const guardianPDA = await findGuardianAddress(i);\n          \n          if (!guardianPDA) {\n            console.log(`Guardian ID ${i}: Không tính được PDA`);\n            continue;\n          }\n          \n          // Kiểm tra xem guardian với ID này có tồn tại không\n          console.log(`Đang kiểm tra Guardian ID ${i} tại địa chỉ: ${guardianPDA.toString()}`);\n          const guardianAccount = await connection.getAccountInfo(guardianPDA);\n          \n          if (guardianAccount) {\n            guardianIds.push(i);\n            console.log(`Guardian ID ${i} đã tồn tại - PDA: ${guardianPDA.toString()}`);\n            console.log(`  - Owner: ${guardianAccount.owner.toString()}`);\n            console.log(`  - Data size: ${guardianAccount.data.length} bytes`);\n            \n            // Kiểm tra discriminator (8 bytes đầu)\n            const discriminator = guardianAccount.data.slice(0, 8);\n            console.log(`  - Discriminator: ${Buffer.from(discriminator).toString('hex')}`);\n          } else {\n            console.log(`Guardian ID ${i}: Account không tồn tại tại địa chỉ ${guardianPDA.toString()}`);\n          }\n        } catch (error) {\n          console.error(`Lỗi khi kiểm tra guardian ID ${i}:`, error);\n        }\n      }\n      \n      console.log(\"Danh sách guardian ID hiện tại:\", guardianIds);\n      \n      // Nếu không có guardian nào, thêm ID 1 vào danh sách để có thể chọn\n      if (guardianIds.length === 0) {\n        guardianIds.push(1);\n        console.log(\"Không tìm thấy guardian nào, thêm ID 1 mặc định vào danh sách\");\n      }\n      \n      setExistingGuardians(guardianIds);\n      \n      // Đảm bảo selectedGuardianId nằm trong danh sách các ID hiện có\n      if (!guardianIds.includes(selectedGuardianId)) {\n        console.log(`Selected Guardian ID ${selectedGuardianId} không tồn tại, chuyển sang ID ${guardianIds[0]}`);\n        setSelectedGuardianId(guardianIds[0]);\n      }\n      \n      setTransactionStatus(`Đã tìm thấy ${guardianIds.length} guardian. IDs: ${guardianIds.join(', ')}`);\n      return guardianIds;\n    } catch (error) {\n      console.error(\"Lỗi khi lấy danh sách guardian:\", error);\n      return [];\n    }\n  };\n  \n  // Hàm sinh guardian ID mới không bị trùng\n  const generateNewGuardianId = (existingIds: number[]) => {\n    // Nếu không có ID nào tồn tại, bắt đầu từ 2 (vì ID 1 thường là owner)\n    if (existingIds.length === 0) return 2;\n    \n    // Tìm ID nhỏ nhất không bị trùng\n    let newId = 1;\n    while (existingIds.includes(newId)) {\n      newId++;\n    }\n    \n    return newId;\n  };\n  \n  // Hàm thêm guardian mới với chữ ký WebAuthn riêng\n  const addNewGuardian = async () => {\n    try {\n      // Kiểm tra xem ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi thêm guardian.');\n        return;\n      }\n      \n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n      \n      // Kiểm tra các trường bắt buộc\n      if (!newGuardianName || !newRecoveryPhrase || newRecoveryPhrase.length < 8) {\n        setTransactionStatus('Vui lòng nhập tên guardian và recovery phrase (ít nhất 8 ký tự).');\n        return;\n      }\n      \n      setTransactionStatus('Đang thêm guardian mới...\\n\\nBước 1: Tạo khóa WebAuthn cho guardian mới...');\n      \n      // Lấy danh sách guardian ID hiện tại\n      const existingIds = await getExistingGuardianIds();\n      \n      // Sinh guardian ID mới không bị trùng\n      const newGuardianId = generateNewGuardianId(existingIds);\n      console.log(\"=== ADD GUARDIAN === Guardian ID mới được sinh:\", newGuardianId);\n      \n      // 1. Tạo khóa WebAuthn cho guardian mới\n      try {\n        // Sử dụng một định danh duy nhất cho khóa mới\n        const guardianIdentifier = `${multisigAddress?.toString()}_guardian_${newGuardianId}`;\n        const webAuthnResult = await createWebAuthnCredential(guardianIdentifier, newGuardianName);\n        \n        // Log thông tin WebAuthn\n        console.log(\"=== ADD GUARDIAN === WebAuthn credential mới đã được tạo:\");\n        console.log(\"=== ADD GUARDIAN === Credential ID:\", webAuthnResult.credentialId);\n        console.log(\"=== ADD GUARDIAN === Public Key:\", webAuthnResult.publicKey);\n        \n        setTransactionStatus(prev => prev + `\\nĐã tạo khóa WebAuthn thành công!`);\n        \n        // 2. Tính PDA cho guardian mới\n        const guardianPDA = await findGuardianAddress(newGuardianId);\n        \n        if (!guardianPDA) {\n          setTransactionStatus('Không thể tính PDA cho guardian mới.');\n          return;\n        }\n        \n        console.log(\"=== ADD GUARDIAN === Guardian PDA mới:\", guardianPDA.toString());\n        \n        // Kiểm tra trước xem guardian account đã tồn tại chưa\n        const existingGuardian = await connection.getAccountInfo(guardianPDA);\n        if (existingGuardian) {\n          console.log(\"=== ADD GUARDIAN === Guardian account đã tồn tại!\", existingGuardian);\n          setTransactionStatus(`Guardian với ID=${newGuardianId} đã tồn tại rồi. Hãy chọn ID khác.`);\n          return;\n        }\n        \n        // 3. Hash recovery phrase\n        const hashedRecoveryBytes = await hashRecoveryPhrase(newRecoveryPhrase);\n        console.log(\"=== ADD GUARDIAN === Recovery phrase sau khi hash:\", Buffer.from(hashedRecoveryBytes).toString('hex'));\n        \n        // 4. Chuyển đổi guardian ID thành bytes (little-endian)\n        const guardianIdBigInt = BigInt(newGuardianId);\n        const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n        \n        // 5. Nén khóa WebAuthn từ 65 bytes (uncompressed) thành 33 bytes (compressed)\n        const uncompressedKeyBuffer = Buffer.from(webAuthnResult.publicKey, 'hex');\n        console.log(\"=== ADD GUARDIAN === WebAuthn key (uncompressed, 65 bytes):\", webAuthnResult.publicKey);\n        \n        // Nén khóa thành 33 bytes\n        const compressedKeyBuffer = compressPublicKey(uncompressedKeyBuffer);\n        console.log(\"=== ADD GUARDIAN === WebAuthn key (compressed, 33 bytes):\", compressedKeyBuffer.toString('hex'));\n        \n        // 6. Tạo discriminator cho add_guardian\n        const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n        \n        // 7. Chuẩn bị tên guardian\n        const guardianNameBuffer = Buffer.from(newGuardianName);\n        const guardianNameLenBuffer = Buffer.alloc(4);\n        guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n        \n        // 8. Đặt is_owner = false vì đây là guardian member, không phải owner\n        const isOwnerByte = new Uint8Array([0]); // false = 0\n        \n        // 9. Cấu hình webauthn_pubkey là Some(compressed_key)\n        const hasWebauthn = new Uint8Array([1]); // Some variant\n        \n        // 10. Tạo dữ liệu instruction\n        const addGuardianData = concatUint8Arrays(\n          addGuardianDiscriminator,\n          // guardian_id (u64)\n          bufferToUint8Array(Buffer.from(guardianIdBytes)),\n          // guardian_name (string)\n          bufferToUint8Array(guardianNameLenBuffer),\n          bufferToUint8Array(guardianNameBuffer),\n          // recovery_hash_intermediate ([u8; 32])\n          hashedRecoveryBytes,\n          // is_owner (bool)\n          isOwnerByte,\n          // webauthn_pubkey (Option<[u8; 33]>) - Some variant + compressed key\n          hasWebauthn,\n          bufferToUint8Array(compressedKeyBuffer)\n        );\n        \n        // Log dữ liệu instruction để debug\n        console.log(\"=== ADD GUARDIAN === Dữ liệu instruction:\", {\n          discriminator: Buffer.from(addGuardianDiscriminator).toString('hex'),\n          guardianId: newGuardianId.toString(),\n          guardianIdBytes: Buffer.from(guardianIdBytes).toString('hex'),\n          nameLength: guardianNameBuffer.length,\n          name: newGuardianName,\n          recoveryHashHex: Buffer.from(hashedRecoveryBytes).toString('hex'),\n          isOwner: false,\n          hasWebauthn: true,\n          webauthnPubkey: compressedKeyBuffer.toString('hex')\n        });\n        \n        setTransactionStatus(prev => prev + `\\n\\nBước 2: Đang thêm guardian vào blockchain...`);\n        \n        // 11. Tạo transaction add guardian\n        const addGuardianTransaction = new Transaction();\n        addGuardianTransaction.add(\n          new TransactionInstruction({\n            keys: [\n              { pubkey: multisigAddress, isSigner: false, isWritable: true },\n              { pubkey: guardianPDA, isSigner: false, isWritable: true },\n              { pubkey: projectFeePayerKeypair.publicKey, isSigner: false, isWritable: false },\n              { pubkey: projectFeePayerKeypair.publicKey, isSigner: true, isWritable: true },\n              { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n            ],\n            programId: PROGRAM_ID,\n            data: Buffer.from(addGuardianData)\n          })\n        );\n        \n        // Sign và gửi transaction với fee payer của dự án\n        addGuardianTransaction.feePayer = projectFeePayerKeypair.publicKey;\n        addGuardianTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n        \n        console.log(\"=== ADD GUARDIAN === Đang gửi transaction...\");\n        const addGuardianSignature = await connection.sendTransaction(\n          addGuardianTransaction,\n          [projectFeePayerKeypair] as Signer[]\n        );\n        \n        console.log(\"=== ADD GUARDIAN === Transaction đã gửi. Signature:\", addGuardianSignature);\n        \n        setTransactionStatus(prev => prev + `\\nĐang xác nhận transaction thêm guardian...`);\n        await connection.confirmTransaction(addGuardianSignature);\n        \n        setTransactionStatus(`Guardian mới đã được thêm thành công với ID: ${newGuardianId}!\\n` +\n          `Chữ ký WebAuthn đã được lưu cho guardian này.\\n` +\n          `Signature: ${addGuardianSignature}`\n        );\n        \n        // Kiểm tra xem guardian đã được thêm thành công chưa\n        console.log(\"=== ADD GUARDIAN === Đang kiểm tra guardian vừa thêm...\");\n        await new Promise(resolve => setTimeout(resolve, 2000)); // Đợi 2 giây\n        \n        const newGuardianAccount = await connection.getAccountInfo(guardianPDA);\n        if (newGuardianAccount) {\n          console.log(\"=== ADD GUARDIAN === Guardian đã được thêm thành công!\");\n          console.log(`=== ADD GUARDIAN === Data size: ${newGuardianAccount.data.length} bytes`);\n          \n          // Kiểm tra discriminator\n          const discriminator = newGuardianAccount.data.slice(0, 8);\n          console.log(`=== ADD GUARDIAN === Discriminator: ${Buffer.from(discriminator).toString('hex')}`);\n        } else {\n          console.log(\"=== ADD GUARDIAN === Guardian không được tìm thấy sau khi thêm!\");\n          setTransactionStatus(prev => prev + '\\n\\nCẢNH BÁO: Guardian có vẻ như chưa được khởi tạo trên blockchain mặc dù transaction đã thành công!');\n        }\n        \n        // Cập nhật danh sách guardian\n        await getExistingGuardianIds();\n        \n        // Cập nhật số dư của ví PDA\n        await loadPdaBalance(multisigAddress);\n        \n        // Reset form\n        setNewGuardianName('');\n        setNewRecoveryPhrase('');\n      } catch (webAuthnError: any) {\n        console.error(\"=== ADD GUARDIAN === Lỗi khi tạo khóa WebAuthn:\", webAuthnError);\n        setTransactionStatus(`Lỗi khi tạo khóa WebAuthn: ${webAuthnError.message || 'Không xác định'}. Vui lòng thử lại.`);\n        return;\n      }\n    } catch (error: any) {\n      console.error(\"=== ADD GUARDIAN === Lỗi khi thêm guardian mới:\", error);\n      setTransactionStatus(`Lỗi khi thêm guardian mới: ${error.message}`);\n    }\n  };\n\n  // Hàm để nạp SOL vào ví multisig\n  const depositToMultisig = async () => {\n    try {\n      // Kiểm tra xem ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi nạp tiền.');\n        return;\n      }\n      \n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n      \n      // Kiểm tra số tiền hợp lệ\n      if (!depositAmount || depositAmount <= 0) {\n        setTransactionStatus('Vui lòng nhập số tiền hợp lệ để nạp.');\n        return;\n      }\n      \n      // Kiểm tra số dư của fee payer\n      const feePayerBalance = await connection.getBalance(projectFeePayerKeypair.publicKey);\n      const lamportsToSend = depositAmount * LAMPORTS_PER_SOL;\n      \n      if (feePayerBalance < lamportsToSend + 5000) { // 5000 lamports cho phí giao dịch\n        setTransactionStatus(`Số dư fee payer không đủ. Hiện tại: ${feePayerBalance / LAMPORTS_PER_SOL} SOL`);\n        return;\n      }\n      \n      setTransactionStatus(`Đang nạp ${depositAmount} SOL vào ví...`);\n      \n      // Tạo transaction chuyển tiền\n      const transaction = new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: projectFeePayerKeypair.publicKey,\n          toPubkey: multisigAddress,\n          lamports: lamportsToSend\n        })\n      );\n      \n      // Cấu hình transaction\n      transaction.feePayer = projectFeePayerKeypair.publicKey;\n      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      \n      // Ký và gửi transaction\n      const signature = await connection.sendTransaction(\n        transaction,\n        [projectFeePayerKeypair]\n      );\n      \n      await connection.confirmTransaction(signature);\n      \n      // Cập nhật số dư\n      await loadPdaBalance(multisigAddress);\n      await loadFeePayerBalance(projectFeePayerKeypair);\n      \n      setTransactionStatus(`Đã nạp thành công ${depositAmount} SOL vào ví! Signature: ${signature}`);\n    } catch (error: any) {\n      console.error('Lỗi khi nạp tiền vào ví:', error);\n      setTransactionStatus(`Lỗi khi nạp tiền: ${error.message}`);\n    }\n  };\n\n  // Hàm để rút tiền từ ví multisig\n  const withdrawFromMultisig = async (amount: number, destinationAddressStr: string) => {\n    if (!multisigAddress) {\n      console.error('Multisig address chưa được tạo');\n      return;\n    }\n    \n    try {\n      setTransactionStatus('Đang xử lý giao dịch...');\n      \n      const destinationAddress = new PublicKey(destinationAddressStr);\n      const lamports = Math.floor(amount * LAMPORTS_PER_SOL);\n      \n      // Lấy fee payer từ biến môi trường\n      let feePayerSecretKey: Uint8Array;\n      try {\n        feePayerSecretKey = convertSecretKeyStringToUint8Array(process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\n      } catch (error) {\n        console.error(\"Lỗi khi chuyển đổi fee payer secret key:\", error);\n        setTransactionStatus('Lỗi khi chuyển đổi fee payer secret key');\n        return;\n      }\n      \n      // Tạo fee payer keypair\n      const feePayerKeypair = Keypair.fromSecretKey(feePayerSecretKey);\n      \n      // Lấy khóa công khai từ WebAuthn credential\n      if (!credentialId) {\n        console.error('WebAuthn credential chưa được tạo');\n        setTransactionStatus('WebAuthn credential chưa được tạo');\n        return;\n      }\n      \n      // Lấy client data JSON cho hàm withdraw\n      const assertion = await getWebAuthnAssertionForLogin(credentialId);\n      \n      if (!assertion || !assertion.success) {\n        console.error('Không thể lấy WebAuthn assertion');\n        setTransactionStatus('Không thể lấy WebAuthn assertion');\n        return;\n      }\n      \n      // Tạo instruction data\n      // ActionParams: { amount: u64, destination: Pubkey, token_mint: Option<Pubkey> }\n      \n      // 1. Tạo Buffer cho action \"withdraw\"\n      const action = Buffer.from(\"withdraw\");\n      \n      // 2. Chuyển đổi amount (lamports) thành little-endian bytes\n      const amountBytes = bigIntToLeBytes(BigInt(lamports), 8);\n      \n      // 3. Thêm bytes của destination pubkey\n      const destinationBytes = destinationAddress.toBytes();\n      \n      // 4. Thêm 0x00 để đánh dấu không có token_mint (None)\n      const tokenMintOption = Buffer.from([0]);\n      \n      // Phần chữ ký (signature)\n      const signatureBytes = Buffer.from(assertion.signature || []);\n      const signatureLen = Buffer.alloc(4);\n      signatureLen.writeUInt32LE(signatureBytes.length, 0);\n      \n      // Phần authenticator data\n      const authenticatorData = Buffer.from(assertion.authenticatorData || []);\n      const authenticatorDataLen = Buffer.alloc(4);\n      authenticatorDataLen.writeUInt32LE(authenticatorData.length, 0);\n      \n      // Phần client data JSON\n      const clientDataJSON = Buffer.from(assertion.clientDataJSON || []);\n      const clientDataJSONLen = Buffer.alloc(4);\n      clientDataJSONLen.writeUInt32LE(clientDataJSON.length, 0);\n      \n      // Kết hợp tất cả dữ liệu\n      const data = Buffer.concat([\n        action,\n        Buffer.from(amountBytes),\n        Buffer.from(destinationBytes),\n        tokenMintOption,\n        signatureLen,\n        signatureBytes,\n        authenticatorDataLen,\n        authenticatorData,\n        clientDataJSONLen,\n        clientDataJSON\n      ]);\n      \n      // Tạo transaction instruction\n      const instruction = new TransactionInstruction({\n        keys: [\n          { pubkey: multisigAddress, isSigner: false, isWritable: true },\n          { pubkey: destinationAddress, isSigner: false, isWritable: true },\n          { pubkey: feePayerKeypair.publicKey, isSigner: true, isWritable: true },\n        ],\n        programId: PROGRAM_ID,\n        data: data\n      });\n      \n      // Tạo transaction\n      const transaction = new Transaction().add(instruction);\n      \n      // Gửi transaction\n      const txSignature = await sendAndConfirmTransaction(\n        connection, \n        transaction, \n        [feePayerKeypair],\n        { commitment: 'confirmed' }\n      );\n      \n      console.log(`Transaction đã hoàn thành: https://explorer.solana.com/tx/${txSignature}?cluster=custom`);\n      setTransactionStatus(`Giao dịch thành công! Signature: ${txSignature}`);\n      \n      // Cập nhật lại số dư\n      loadPdaBalance(multisigAddress);\n    } catch (error) {\n      console.error('Lỗi khi rút tiền từ multisig:', error);\n      setTransactionStatus(`Lỗi khi rút tiền: ${error instanceof Error ? error.message : 'Lỗi không xác định'}`);\n      throw error;\n    }\n  };\n\n  // Tự động cập nhật danh sách guardians khi multisigAddress thay đổi\n  useEffect(() => {\n    if (multisigAddress) {\n      // Load lại danh sách guardian IDs\n      getExistingGuardianIds();\n      \n      // Load số dư của PDA\n      loadPdaBalance(multisigAddress);\n    }\n  }, [multisigAddress]);\n\n  // Hàm để kiểm tra guardian ID cụ thể\n  const testGuardianInfo = async (id: number) => {\n    if (!multisigAddress) {\n      setTransactionStatus('Ví chưa được khởi tạo');\n      return;\n    }\n    \n    setTransactionStatus(`Đang kiểm tra chi tiết Guardian ID ${id}...`);\n    \n    try {\n      // Tính PDA \n      const guardianPDA = await findGuardianAddress(id);\n      if (!guardianPDA) {\n        setTransactionStatus(`Không thể tính PDA cho Guardian ID ${id}`);\n        return;\n      }\n      \n      console.log(`=== TEST === Đang kiểm tra chi tiết Guardian ID ${id} tại ${guardianPDA.toString()}`);\n      \n      const guardianAccount = await connection.getAccountInfo(guardianPDA);\n      if (!guardianAccount) {\n        console.log(`=== TEST === Account không tồn tại tại địa chỉ ${guardianPDA.toString()}`);\n        setTransactionStatus(`Guardian ID ${id} không tồn tại trên blockchain`);\n        return;\n      }\n      \n      console.log(`=== TEST === Account tồn tại!`);\n      console.log(`=== TEST === Owner: ${guardianAccount.owner.toString()}`);\n      console.log(`=== TEST === Data size: ${guardianAccount.data.length} bytes`);\n      \n      // Kiểm tra discriminator\n      const discriminator = guardianAccount.data.slice(0, 8);\n      console.log(`=== TEST === Discriminator: ${Buffer.from(discriminator).toString('hex')}`);\n      \n      // Bỏ qua 8 byte discriminator\n      const data = guardianAccount.data.slice(8);\n      \n      try {\n        // Wallet (32 bytes)\n        const walletBytes = data.slice(0, 32);\n        const wallet = new PublicKey(walletBytes);\n        console.log(`=== TEST === Wallet: ${wallet.toString()}`);\n        \n        // Guardian ID (8 bytes)\n        const guardianIdBytes = data.slice(32, 40);\n        let guardianId = BigInt(0);\n        for (let i = 0; i < 8; i++) {\n          guardianId |= BigInt(guardianIdBytes[i]) << BigInt(8 * i);\n        }\n        console.log(`=== TEST === Guardian ID parsed: ${guardianId}`);\n        \n        // Name\n        const nameLength = new DataView(data.buffer, data.byteOffset + 40, 4).getUint32(0, true);\n        console.log(`=== TEST === Name length: ${nameLength}`);\n        \n        // Nếu name length hợp lệ, tiếp tục parse\n        if (nameLength <= 100) {\n          const nameBytes = data.slice(44, 44 + nameLength);\n          const name = new TextDecoder().decode(nameBytes);\n          console.log(`=== TEST === Name: ${name}`);\n          \n          setTransactionStatus(`Guardian ID ${id} tồn tại!\\n- PDA: ${guardianPDA.toString()}\\n- Wallet: ${wallet.toString()}\\n- Name: ${name}\\n- Guardian ID: ${guardianId}`);\n        } else {\n          console.log(`=== TEST === Name length không hợp lệ`);\n          setTransactionStatus(`Guardian ID ${id} tồn tại nhưng có cấu trúc dữ liệu không hợp lệ`);\n        }\n      } catch (parseError) {\n        console.error(`=== TEST === Lỗi khi parse dữ liệu:`, parseError);\n        setTransactionStatus(`Guardian ID ${id} tồn tại nhưng không thể parse dữ liệu: ${parseError}`);\n      }\n      \n    } catch (error: any) {\n      console.error(`=== TEST === Lỗi:`, error);\n      setTransactionStatus(`Lỗi khi kiểm tra: ${error.message}`);\n    }\n  };\n\n  // Hàm đăng nhập vào ví đã tạo\n  const loginToWallet = async () => {\n    try {\n      setIsLoggingIn(true);\n      setTransactionStatus('Đang đăng nhập vào ví...\\n\\nBước 1: Đang yêu cầu xác thực WebAuthn...');\n      \n      // 1. Yêu cầu người dùng xác thực với thiết bị (không cần nhập credential ID cụ thể)\n      try {\n        // Gọi hàm getWebAuthnAssertionForLogin với allowEmpty=true để cho phép người dùng chọn từ bất kỳ credential nào\n        const assertionResult = await getWebAuthnAssertionForLogin('', true);\n        \n        if (!assertionResult.success || !assertionResult.rawId) {\n          throw new Error(assertionResult.error || 'Không thể xác thực với thiết bị');\n        }\n        \n        // Lấy thông tin credential từ phản hồi\n        const credentialRawData = assertionResult.rawId;\n        \n        // Chuyển rawId thành hex để sử dụng làm key trong bảng webauthn_credentials\n        const credentialIdHex = Buffer.from(credentialRawData).toString('hex');\n        console.log(\"Credential ID (hex):\", credentialIdHex);\n        \n        // Chuyển rawId thành base64 để sử dụng trong blockchain\n        const rawIdBase64 = Buffer.from(credentialRawData).toString('base64');\n        console.log(\"Raw credential ID (base64):\", rawIdBase64);\n        \n        setTransactionStatus(prev => prev + '\\nXác thực WebAuthn thành công!\\n\\nBước 2: Đang tìm thông tin ví...');\n        \n        // 2. Truy vấn thông tin ví từ bảng webauthn_credentials\n        const credentialMapping = await getWalletByCredentialId(credentialIdHex);\n        \n        if (credentialMapping) {\n          // Nếu tìm thấy trong bảng ánh xạ\n          setTransactionStatus(prev => prev + `\\nĐã tìm thấy thông tin ví trong database!`);\n          \n          // Chuyển đổi từ chuỗi sang PublicKey\n          const walletAddressFromDB = new PublicKey(credentialMapping.walletAddress);\n          console.log(\"Wallet address from database:\", walletAddressFromDB.toString());\n          \n          // 3. Kiểm tra xem ví có tồn tại trên blockchain không\n          const walletAccount = await connection.getAccountInfo(walletAddressFromDB);\n          \n          if (!walletAccount) {\n            setTransactionStatus(`Ví tìm thấy trong database không tồn tại trên blockchain. Địa chỉ: ${walletAddressFromDB.toString()}`);\n            setIsLoggingIn(false);\n            return;\n          }\n          \n          // 4. Cập nhật state với thông tin ví\n          setMultisigAddress(walletAddressFromDB);\n          setCredentialId(rawIdBase64); // Lưu credential ID gốc\n          \n          setTransactionStatus(prev => prev + `\\nĐã tìm thấy ví tại địa chỉ: ${walletAddressFromDB.toString()}\\n\\nBước 3: Đang tải thông tin ví...`);\n        } else {\n          // Nếu không tìm thấy trong bảng ánh xạ, sử dụng phương pháp tính toán cũ\n          setTransactionStatus(prev => prev + '\\nKhông tìm thấy thông tin trong database, đang tính toán địa chỉ ví...');\n          \n          // Tính địa chỉ ví từ credential ID\n          const multisigPDA = getMultisigPDA(rawIdBase64);\n          console.log(\"Computed Multisig PDA:\", multisigPDA.toString());\n          \n          // Kiểm tra xem ví có tồn tại không\n          const walletAccount = await connection.getAccountInfo(multisigPDA);\n          \n          if (!walletAccount) {\n            setTransactionStatus(`Không tìm thấy ví với credential này. Có thể bạn cần tạo ví mới.`);\n            setIsLoggingIn(false);\n            return;\n          }\n          \n          setTransactionStatus(prev => prev + `\\nĐã tìm thấy ví tại địa chỉ: ${multisigPDA.toString()}\\n\\nBước 3: Đang tải thông tin ví...`);\n          \n          // Cập nhật state với thông tin ví\n          setMultisigAddress(multisigPDA);\n          setCredentialId(rawIdBase64); // Lưu credential ID gốc\n        }\n        \n        // 5. Tìm guardian PDA\n        await findGuardianAddress(1); // Tìm guardian chính (owner)\n        \n        // 6. Tải số dư và danh sách guardian\n        await loadPdaBalance(multisigAddress!);\n        await getExistingGuardianIds();\n        \n        // 7. Hoàn thành đăng nhập\n        setIsLoggedIn(true);\n        setIsLoggingIn(false);\n        setTransactionStatus(`Đăng nhập thành công!\\n\\nĐịa chỉ ví: ${multisigAddress!.toString()}\\nSố guardian: ${existingGuardians.length}`);\n        \n        // 8. Ẩn form đăng nhập\n        setShowLoginForm(false);\n      } catch (webAuthnError: any) {\n        console.error(\"Lỗi khi xác thực WebAuthn:\", webAuthnError);\n        setTransactionStatus(`Lỗi khi xác thực: ${webAuthnError.message}`);\n        setIsLoggingIn(false);\n      }\n    } catch (error: any) {\n      console.error('Lỗi khi đăng nhập:', error);\n      setTransactionStatus(`Lỗi khi đăng nhập: ${error.message}`);\n      setIsLoggingIn(false);\n    }\n  };\n\n  // Hàm tạo mã mời ngẫu nhiên\n  const generateRandomCode = (length: number): string => {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let result = '';\n    const randomValues = new Uint8Array(length);\n    crypto.getRandomValues(randomValues);\n    for (let i = 0; i < length; i++) {\n      result += chars.charAt(randomValues[i] % chars.length);\n    }\n    return result;\n  };\n\n  // Hàm tạo link mời guardian mới\n  const generateGuardianInvite = async () => {\n    try {\n      // Kiểm tra ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi mời guardian.');\n        return;\n      }\n      \n      // Lấy danh sách guardian ID hiện tại\n      const existingIds = await getExistingGuardianIds();\n      \n      // Sinh guardian ID mới không bị trùng\n      const newGuardianId = generateNewGuardianId(existingIds);\n      \n      // Tạo mã ngẫu nhiên cho link mời\n      const inviteCode = generateRandomCode(8);\n      \n      // Tạo link mời với URL ngrok từ biến môi trường hoặc sử dụng địa chỉ hiện tại\n      const ngrokUrl = process.env.REACT_APP_NGROK_URL || window.location.origin;\n      const inviteLink = `${ngrokUrl}/#/guardian-signup/${inviteCode}`;\n      \n      // Hiển thị link (đặt state trước khi lưu vào Firebase)\n      setInviteCode(inviteCode);\n      setInviteLink(inviteLink);\n      setShowQRCode(true);\n      \n      // Lưu thông tin vào Firebase\n      try {\n        await saveInvitation({\n          multisigAddress: multisigAddress.toString(),\n          guardianId: newGuardianId,\n          inviteCode,\n          status: 'pending',\n          ownerId: projectFeePayerKeypair?.publicKey.toString() || ''\n        });\n      } catch (error) {\n        console.error(\"Lỗi khi lưu vào Firebase:\", error);\n        // Hiển thị lỗi nhưng vẫn tiếp tục hiển thị link mời\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        setTransactionStatus(`Đã tạo link mời guardian: ${inviteLink}\\nLưu ý: Có lỗi khi lưu thông tin: ${errorMessage}`);\n        return inviteLink;\n      }\n      \n      setTransactionStatus(`Đã tạo link mời guardian: ${inviteLink}`);\n      \n      return inviteLink;\n    } catch (error: any) {\n      console.error(\"Lỗi khi tạo link mời guardian:\", error);\n      setTransactionStatus(`Lỗi khi tạo link mời guardian: ${error.message}`);\n      return null;\n    }\n  };\n\n  // Tải danh sách mã mời đang chờ\n  const loadPendingInvites = async () => {\n    try {\n      if (!projectFeePayerKeypair || !multisigAddress) return;\n      \n      const ownerId = projectFeePayerKeypair.publicKey.toString();\n      // Chỉ lọc guardian của chính ví multisig hiện tại\n      const multisigAddressStr = multisigAddress.toString();\n      const invitesList = await getPendingInvites(ownerId, multisigAddressStr);\n      setPendingInvites(invitesList);\n      \n      if (invitesList.length > 0) {\n        console.log(`Tìm thấy ${invitesList.length} guardian đang chờ hoàn tất cho ví ${multisigAddressStr}. Mã mời: ${invitesList.join(', ')}`);\n      }\n    } catch (error) {\n      console.error(\"Lỗi khi tải danh sách mã mời:\", error);\n    }\n  };\n\n  // Load danh sách mã mời khi component được mount và mỗi khi projectFeePayerKeypair hoặc multisigAddress thay đổi\n  useEffect(() => {\n    if (projectFeePayerKeypair && multisigAddress) {\n      loadPendingInvites();\n    }\n  }, [projectFeePayerKeypair, multisigAddress]);\n\n  // Hàm để lấy thông tin guardian đã đăng ký\n  const fetchGuardianDataFromDatabase = async (inviteCode: string) => {\n    try {\n      return await getGuardianData(inviteCode);\n    } catch (error) {\n      console.error(\"Lỗi khi lấy dữ liệu guardian:\", error);\n      return null;\n    }\n  };\n\n  // Hàm để lấy thông tin invitation\n  const fetchInviteFromDatabase = async (inviteCode: string) => {\n    try {\n      return await getInvitation(inviteCode);\n    } catch (error) {\n      console.error(\"Lỗi khi lấy dữ liệu invite:\", error);\n      return null;\n    }\n  };\n\n  // Hàm để cập nhật trạng thái guardian\n  const updateGuardianStatusInDatabase = async (inviteCode: string, status: string, txSignature?: string) => {\n    try {\n      await updateGuardianStatus(inviteCode, status as any, txSignature);\n    } catch (error) {\n      console.error(\"Lỗi khi cập nhật trạng thái guardian:\", error);\n    }\n  };\n\n  // Hàm hoàn tất đăng ký guardian từ dữ liệu đã lưu\n  const completeGuardianRegistration = async (inviteCode: string) => {\n    try {\n      setTransactionStatus('Đang hoàn tất đăng ký guardian...');\n      \n      // 1. Lấy dữ liệu guardian từ localStorage\n      const guardianData = await fetchGuardianDataFromDatabase(inviteCode);\n      \n      if (!guardianData) {\n        setTransactionStatus('Không tìm thấy dữ liệu guardian. Vui lòng đảm bảo guardian đã hoàn tất đăng ký.');\n        return;\n      }\n      \n      if (guardianData.status !== 'ready') {\n        setTransactionStatus('Guardian chưa hoàn tất đăng ký.');\n        return;\n      }\n      \n      // 2. Lấy thông tin invite\n      const inviteData = await fetchInviteFromDatabase(inviteCode);\n      \n      if (!inviteData) {\n        setTransactionStatus('Không tìm thấy thông tin mời guardian.');\n        return;\n      }\n      \n      // 3. Tính PDA cho guardian\n      const multisigPDA = new PublicKey(inviteData.multisigAddress);\n      const guardianId = inviteData.guardianId;\n      const guardianPDA = await findGuardianAddress(guardianId);\n      \n      if (!guardianPDA) {\n        setTransactionStatus('Không thể tính PDA cho guardian.');\n        return;\n      }\n      \n      // 4. Chuyển đổi dữ liệu thành format phù hợp\n      const hashedRecoveryBytes = new Uint8Array(guardianData.hashedRecoveryBytes);\n      const compressedKeyBuffer = Buffer.from(guardianData.webauthnPublicKey);\n      \n      // 5. Tạo discriminator cho add_guardian\n      const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n      \n      // 6. Chuyển đổi guardian ID thành bytes (little-endian)\n      const guardianIdBigInt = BigInt(guardianId);\n      const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n      \n      // 7. Chuẩn bị tên guardian\n      const guardianNameBuffer = Buffer.from(guardianData.guardianName);\n      const guardianNameLenBuffer = Buffer.alloc(4);\n      guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n      \n      // 8. Đặt is_owner = false vì đây là guardian member, không phải owner\n      const isOwnerByte = new Uint8Array([0]); // false = 0\n      \n      // 9. Cấu hình webauthn_pubkey là Some(compressed_key)\n      const hasWebauthn = new Uint8Array([1]); // Some variant\n      \n      // 10. Tạo dữ liệu instruction\n      const addGuardianData = concatUint8Arrays(\n        addGuardianDiscriminator,\n        // guardian_id (u64)\n        bufferToUint8Array(Buffer.from(guardianIdBytes)),\n        // guardian_name (string)\n        bufferToUint8Array(guardianNameLenBuffer),\n        bufferToUint8Array(guardianNameBuffer),\n        // recovery_hash_intermediate ([u8; 32])\n        hashedRecoveryBytes,\n        // is_owner (bool)\n        isOwnerByte,\n        // webauthn_pubkey (Option<[u8; 33]>) - Some variant + compressed key\n        hasWebauthn,\n        bufferToUint8Array(Buffer.from(compressedKeyBuffer))\n      );\n      \n      // 11. Tạo transaction add guardian\n      const addGuardianTransaction = new Transaction();\n      addGuardianTransaction.add(\n        new TransactionInstruction({\n          keys: [\n            { pubkey: multisigPDA, isSigner: false, isWritable: true },\n            { pubkey: guardianPDA, isSigner: false, isWritable: true },\n            { pubkey: projectFeePayerKeypair!.publicKey, isSigner: false, isWritable: false },\n            { pubkey: projectFeePayerKeypair!.publicKey, isSigner: true, isWritable: true },\n            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n          ],\n          programId: PROGRAM_ID,\n          data: Buffer.from(addGuardianData)\n        })\n      );\n      \n      // Sign và gửi transaction với fee payer của dự án\n      addGuardianTransaction.feePayer = projectFeePayerKeypair!.publicKey;\n      addGuardianTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      \n      setTransactionStatus(prev => prev + '\\nĐang gửi transaction...');\n      const addGuardianSignature = await connection.sendTransaction(\n        addGuardianTransaction,\n        [projectFeePayerKeypair!] as Signer[]\n      );\n      \n      setTransactionStatus(prev => prev + '\\nĐang xác nhận transaction...');\n      await connection.confirmTransaction(addGuardianSignature);\n      \n      // Cập nhật trạng thái trong DB\n      await updateGuardianStatusInDatabase(inviteCode, 'completed', addGuardianSignature);\n      \n      setTransactionStatus(`Guardian đã được thêm thành công với ID: ${guardianId}!\\n` +\n        `Signature: ${addGuardianSignature}`\n      );\n      \n      // Xóa dữ liệu guardian từ database sau khi hoàn tất\n      setTransactionStatus(prev => prev + '\\n\\nĐang xóa dữ liệu guardian từ database...');\n      console.log(`Bắt đầu xóa dữ liệu guardian với mã mời: ${inviteCode}`);\n      const deleteResult = await deleteGuardianData(inviteCode);\n      \n      if (deleteResult) {\n        console.log(`✅ ĐÃ XÓA THÀNH CÔNG dữ liệu guardian, invitation và lookup với mã mời: ${inviteCode}`);\n        \n        // Cập nhật thông báo thành công rõ ràng hơn\n        setTransactionStatus(`✅ HOÀN TẤT THÀNH CÔNG!\n        \n        Guardian \"${guardianData.guardianName}\" (ID: ${guardianData.guardianId}) đã được thêm thành công vào ví.\n        \n        Địa chỉ Guardian: ${guardianPDA.toString()}\n        Signature: ${addGuardianSignature}\n        \n        ✅ Dữ liệu đã được xóa khỏi database để bảo vệ quyền riêng tư.\n        \n        ✅ Guardian hiện đã sẵn sàng sử dụng và đã được ẩn khỏi danh sách chờ.`);\n        \n        // Bỏ mã mời đã sử dụng khỏi danh sách\n        setPendingInvites(prev => prev.filter(code => code !== inviteCode));\n        \n        // Không đóng form để người dùng có thể tiếp tục thêm guardian khác\n        /* \n        if (pendingInvites.length <= 1) {\n          setShowInviteInput(false);\n        }\n        */\n      } else {\n        console.error(`❌ KHÔNG THỂ XÓA dữ liệu guardian với mã mời: ${inviteCode}`);\n        setTransactionStatus(prev => prev + '\\n❌ Không thể xóa dữ liệu guardian từ database.');\n      }\n      \n      // Cập nhật danh sách guardian và load lại danh sách mã mời\n      await getExistingGuardianIds();\n      await loadPendingInvites();\n      \n      // Cập nhật số dư của ví PDA\n      await loadPdaBalance(multisigPDA);\n    } catch (error: any) {\n      console.error(\"Lỗi khi hoàn tất đăng ký guardian:\", error);\n      setTransactionStatus(`Lỗi khi hoàn tất đăng ký guardian: ${error.message}`);\n    }\n  };\n\n  // Hàm kiểm tra thông tin guardians trong database\n  const checkGuardiansInDatabase = async () => {\n    try {\n      setTransactionStatus('Đang kiểm tra dữ liệu guardians từ Firestore...');\n      \n      if (!projectFeePayerKeypair || !multisigAddress) {\n        setTransactionStatus('Cần có thông tin fee payer và multisig address để kiểm tra.');\n        return;\n      }\n      \n      const ownerId = projectFeePayerKeypair.publicKey.toString();\n      const multisigAddressStr = multisigAddress.toString();\n      \n      // Lấy danh sách invitations đang chờ CHỈ của ví hiện tại\n      const pendingInvites = await getPendingInvites(ownerId, multisigAddressStr);\n      console.log(`Danh sách mã mời đang chờ cho ví ${multisigAddressStr}:`, pendingInvites);\n      \n      if (pendingInvites.length === 0) {\n        setTransactionStatus(`Không tìm thấy mã mời nào đang chờ xử lý cho ví ${multisigAddressStr}.`);\n        return;\n      }\n      \n      // Kiểm tra thông tin từng guardian\n      let resultMessage = 'Thông tin guardians từ database:\\n\\n';\n      \n      for (const inviteCode of pendingInvites) {\n        // Lấy thông tin invitation\n        const inviteData = await getInvitation(inviteCode);\n        if (!inviteData) {\n          resultMessage += `Mã mời ${inviteCode}: Không tìm thấy thông tin invitation.\\n`;\n          continue;\n        }\n        \n        // Lấy thông tin guardian\n        const guardianData = await getGuardianData(inviteCode);\n        if (!guardianData) {\n          resultMessage += `Mã mời ${inviteCode}: Invitation tồn tại nhưng chưa có thông tin guardian.\\n`;\n          continue;\n        }\n        \n        // Hiển thị thông tin\n        resultMessage += `Mã mời: ${inviteCode}\\n`;\n        resultMessage += `Guardian ID: ${guardianData.guardianId}\\n`;\n        resultMessage += `Tên guardian: ${guardianData.guardianName}\\n`;\n        resultMessage += `Trạng thái: ${guardianData.status}\\n`;\n        resultMessage += `WebAuthn ID: ${guardianData.webauthnCredentialId.substring(0, 20)}...\\n\\n`;\n      }\n      \n      setTransactionStatus(resultMessage);\n    } catch (error) {\n      console.error(\"Lỗi khi kiểm tra thông tin guardians:\", error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      setTransactionStatus(`Lỗi khi kiểm tra thông tin guardians: ${errorMessage}`);\n    }\n  };\n\n  // Hoàn tất quá trình đăng ký guardian dựa trên mã mời\n  const completeGuardianSetup = async (inviteCode: string) => {\n    try {\n      setTransactionStatus(`Đang hoàn tất quá trình đăng ký guardian với mã mời: ${inviteCode}...`);\n      \n      // 1. Lấy thông tin guardian\n      const guardianData = await getGuardianData(inviteCode);\n      if (!guardianData) {\n        setTransactionStatus('Không tìm thấy thông tin guardian. Vui lòng đảm bảo guardian đã hoàn tất đăng ký.');\n        return;\n      }\n      \n      if (guardianData.status !== 'ready') {\n        setTransactionStatus(`Guardian có trạng thái không hợp lệ: ${guardianData.status}`);\n        return;\n      }\n      \n      // 2. Thêm guardian vào blockchain\n      setTransactionStatus(prev => prev + '\\n\\nĐang thêm guardian vào blockchain...');\n      \n      // Tạo multisig PDA từ địa chỉ multisig\n      const multisigPubkey = new PublicKey(guardianData.multisigAddress);\n      \n      // Tạo WebAuthn public key từ dữ liệu lưu trữ\n      const webauthnPubkey = Buffer.from(new Uint8Array(guardianData.webauthnPublicKey));\n      \n      // Chuẩn bị dữ liệu guardian\n      const guardianIndex = guardianData.guardianId;\n      const guardianName = guardianData.guardianName;\n      const guardianType = 0; // 0 = Guardian thường\n      const recoveryHash = Uint8Array.from(guardianData.hashedRecoveryBytes);\n      \n      // Thêm guardian vào blockchain\n      if (projectFeePayerKeypair) {\n        // Tạo transaction\n        const tx = new Transaction();\n        \n        // Tìm PDA cho guardian\n        const guardianIdBigInt = BigInt(guardianIndex);\n        const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n        \n        const [guardianPDA] = await PublicKey.findProgramAddress(\n          [\n            Buffer.from(\"guardian\"),\n            multisigPubkey.toBuffer(),\n            guardianIdBytes\n          ],\n          PROGRAM_ID\n        );\n        \n        // Tạo instruction để thêm guardian\n        // Sử dụng discriminator đúng cho add_guardian theo IDL\n        const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n        \n        // Chuẩn bị tên guardian\n        const guardianNameBuffer = Buffer.from(guardianName);\n        const guardianNameLenBuffer = Buffer.alloc(4);\n        guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n        \n        // Đặt is_owner = false vì đây là guardian member, không phải owner\n        const isOwnerByte = new Uint8Array([0]); // false = 0\n        \n        // Cấu hình webauthn_pubkey là Some(webauthnPubkey)\n        const hasWebauthn = new Uint8Array([1]); // Some variant\n        \n        // Tạo dữ liệu instruction\n        const instructionData = concatUint8Arrays(\n          addGuardianDiscriminator,\n          guardianIdBytes,\n          bufferToUint8Array(guardianNameLenBuffer),\n          bufferToUint8Array(guardianNameBuffer),\n          recoveryHash,\n          isOwnerByte,\n          hasWebauthn,\n          bufferToUint8Array(webauthnPubkey)\n        );\n        \n        const addGuardianIx = new TransactionInstruction({\n          keys: [\n            { pubkey: multisigPubkey, isSigner: false, isWritable: true },\n            { pubkey: guardianPDA, isSigner: false, isWritable: true },\n            { pubkey: projectFeePayerKeypair.publicKey, isSigner: false, isWritable: false },\n            { pubkey: projectFeePayerKeypair.publicKey, isSigner: true, isWritable: true },\n            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n          ],\n          programId: PROGRAM_ID,\n          data: Buffer.from(instructionData)\n        });\n        \n        tx.add(addGuardianIx);\n        \n        // Gửi transaction\n        setTransactionStatus(prev => prev + '\\nĐang gửi transaction...');\n        const signature = await sendAndConfirmTransaction(\n          connection,\n          tx,\n          [projectFeePayerKeypair],\n          {\n            commitment: 'confirmed',\n            skipPreflight: true,\n          }\n        );\n        \n        // Xác nhận transaction đã thành công\n        setTransactionStatus(prev => prev + '\\nĐang xác nhận transaction...');\n        await connection.confirmTransaction(signature, 'confirmed');\n        \n        // Cập nhật trạng thái guardian\n        await updateGuardianStatus(inviteCode, 'completed', signature);\n        \n        // Thông báo kết quả\n        setTransactionStatus(`Guardian đã được thêm thành công vào blockchain!\n- Tên: ${guardianData.guardianName}\n- ID: ${guardianData.guardianId}\n- Địa chỉ: ${guardianPDA.toString()}\n- Signature: ${signature}\n\nGuardian đã sẵn sàng để sử dụng trong ví multisig của bạn.`);\n        \n        // Xóa dữ liệu guardian từ database sau khi hoàn tất\n        setTransactionStatus(prev => prev + '\\n\\nĐang xóa dữ liệu guardian từ database...');\n        console.log(`Bắt đầu xóa dữ liệu guardian với mã mời: ${inviteCode}`);\n        const deleteResult = await deleteGuardianData(inviteCode);\n        \n        if (deleteResult) {\n          console.log(`✅ ĐÃ XÓA THÀNH CÔNG dữ liệu guardian, invitation và lookup với mã mời: ${inviteCode}`);\n          \n          // Cập nhật thông báo thành công rõ ràng hơn\n          setTransactionStatus(`✅ HOÀN TẤT THÀNH CÔNG!\n          \n          Guardian \"${guardianData.guardianName}\" (ID: ${guardianData.guardianId}) đã được thêm thành công vào ví.\n          \n          Địa chỉ Guardian: ${guardianPDA.toString()}\n          Signature: ${signature}\n          \n          ✅ Dữ liệu đã được xóa khỏi database để bảo vệ quyền riêng tư.\n          \n          ✅ Guardian hiện đã sẵn sàng sử dụng và đã được ẩn khỏi danh sách chờ.`);\n          \n          // Bỏ mã mời đã sử dụng khỏi danh sách\n          setPendingInvites(prev => prev.filter(code => code !== inviteCode));\n          \n          // Không đóng form sau khi hoàn tất để người dùng có thể tiếp tục thêm guardian khác\n          /* \n          if (pendingInvites.length <= 1) {\n            setShowInviteInput(false);\n          }\n          */\n        } else {\n          console.error(`❌ KHÔNG THỂ XÓA dữ liệu guardian với mã mời: ${inviteCode}`);\n          setTransactionStatus(prev => prev + '\\n❌ Không thể xóa dữ liệu guardian từ database.');\n        }\n        \n        // Làm mới danh sách guardian và cập nhật UI\n        await getExistingGuardianIds();\n        await loadPendingInvites();\n        \n        // Cập nhật số dư của ví\n        if (multisigAddress) {\n          await loadPdaBalance(multisigAddress);\n        }\n      } else {\n        setTransactionStatus('Lỗi: Fee payer không khả dụng');\n      }\n    } catch (error) {\n      console.error(\"Lỗi khi hoàn tất quá trình đăng ký guardian:\", error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      setTransactionStatus(`Lỗi khi hoàn tất quá trình đăng ký guardian: ${errorMessage}`);\n    }\n  };\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>Moon Wallet</h1>\n        <p>Ví đa chữ ký an toàn trên Solana</p>\n        \n        {!isLoggedIn ? (\n          <div className=\"auth-section\">\n            {/* ... existing code ... */}\n          </div>\n        ) : (\n          <div className=\"wallet-section\">\n            <div className=\"mb-4\">\n              <button \n                className={`tab-button ${!showTransfer ? 'active' : ''}`}\n                onClick={() => setShowTransfer(false)}\n              >\n                Quản lý ví\n              </button>\n              <button \n                className={`tab-button ${showTransfer ? 'active' : ''}`}\n                onClick={() => setShowTransfer(true)}\n              >\n                Chuyển tiền\n              </button>\n            </div>\n            \n            {showTransfer ? (\n              <Transfer \n                multisigAddress={multisigAddress}\n                balance={pdaBalance / LAMPORTS_PER_SOL}\n                withdrawFromMultisig={withdrawFromMultisig}\n              />\n            ) : (\n              <div className=\"wallet-container\">\n                {/* ... existing wallet UI ... */}\n              </div>\n            )}\n          </div>\n        )}\n      </header>\n    </div>\n  );\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}