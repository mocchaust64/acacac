{"ast":null,"code":"/**\n * Các hàm tiện ích để xử lý buffer và chuyển đổi dữ liệu\n */\n\nimport { Buffer } from 'buffer';\n\n// Hàm chuyển đổi ArrayBuffer hoặc Uint8Array thành chuỗi hex\nexport const bufferToHex = buffer => {\n  const uintArray = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  return Array.from(uintArray).map(b => b.toString(16).padStart(2, '0')).join('');\n};\n\n// Hàm chuyển đổi chuỗi hex thành ArrayBuffer\nexport const hexToBuffer = hex => {\n  var _hex$match;\n  const bytes = new Uint8Array(((_hex$match = hex.match(/.{1,2}/g)) === null || _hex$match === void 0 ? void 0 : _hex$match.map(byte => parseInt(byte, 16))) || []);\n  return bytes.buffer;\n};\n\n// Hàm hash mật khẩu\nexport const hashPassword = async password => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(password);\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  return new Uint8Array(hashBuffer);\n};\n\n// Hàm nén khóa công khai từ dạng uncompressed (65 bytes) sang compressed (33 bytes)\nexport const compressPublicKey = uncompressedKey => {\n  // Đảm bảo khóa bắt đầu với byte 0x04 (không nén)\n  if (uncompressedKey[0] !== 0x04 || uncompressedKey.length !== 65) {\n    console.warn('Khóa không đúng định dạng không nén ECDSA, tạo khóa ngẫu nhiên');\n    // Tạo khóa random nếu không đúng định dạng\n    const randomKey = Buffer.alloc(33);\n    randomKey[0] = 0x02; // compressed, y is even\n\n    // Tạo dữ liệu ngẫu nhiên cho 32 bytes còn lại\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n\n    // Sao chép vào buffer\n    for (let i = 0; i < 32; i++) {\n      randomKey[i + 1] = randomBytes[i];\n    }\n    return randomKey;\n  }\n\n  // Lấy tọa độ x và y\n  const x = new Uint8Array(uncompressedKey.slice(1, 33));\n  const y = new Uint8Array(uncompressedKey.slice(33, 65));\n\n  // Tính prefix: 0x02 nếu y chẵn, 0x03 nếu y lẻ\n  const prefix = (y[31] & 1) === 0 ? 0x02 : 0x03;\n\n  // Tạo khóa nén: prefix (1 byte) + x (32 bytes)\n  const compressedKey = Buffer.alloc(33);\n  compressedKey[0] = prefix;\n\n  // Copy x vào compressedKey từ vị trí 1\n  for (let i = 0; i < 32; i++) {\n    compressedKey[i + 1] = x[i];\n  }\n  return compressedKey;\n};","map":{"version":3,"names":["Buffer","bufferToHex","buffer","uintArray","Uint8Array","Array","from","map","b","toString","padStart","join","hexToBuffer","hex","_hex$match","bytes","match","byte","parseInt","hashPassword","password","encoder","TextEncoder","data","encode","hashBuffer","crypto","subtle","digest","compressPublicKey","uncompressedKey","length","console","warn","randomKey","alloc","randomBytes","getRandomValues","i","x","slice","y","prefix","compressedKey"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/acacac/src/utils/bufferUtils.ts"],"sourcesContent":["/**\n * Các hàm tiện ích để xử lý buffer và chuyển đổi dữ liệu\n */\n\nimport { Buffer } from 'buffer';\n\n// Hàm chuyển đổi ArrayBuffer hoặc Uint8Array thành chuỗi hex\nexport const bufferToHex = (buffer: ArrayBuffer | Uint8Array): string => {\n  const uintArray = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  return Array.from(uintArray)\n    .map(b => b.toString(16).padStart(2, '0'))\n    .join('');\n};\n\n// Hàm chuyển đổi chuỗi hex thành ArrayBuffer\nexport const hexToBuffer = (hex: string): ArrayBuffer => {\n  const bytes = new Uint8Array(hex.match(/.{1,2}/g)?.map(byte => parseInt(byte, 16)) || []);\n  return bytes.buffer;\n};\n\n// Hàm hash mật khẩu\nexport const hashPassword = async (password: string): Promise<Uint8Array> => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(password);\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  return new Uint8Array(hashBuffer);\n};\n\n// Hàm nén khóa công khai từ dạng uncompressed (65 bytes) sang compressed (33 bytes)\nexport const compressPublicKey = (uncompressedKey: Buffer): Buffer => {\n  // Đảm bảo khóa bắt đầu với byte 0x04 (không nén)\n  if (uncompressedKey[0] !== 0x04 || uncompressedKey.length !== 65) {\n    console.warn('Khóa không đúng định dạng không nén ECDSA, tạo khóa ngẫu nhiên');\n    // Tạo khóa random nếu không đúng định dạng\n    const randomKey = Buffer.alloc(33);\n    randomKey[0] = 0x02; // compressed, y is even\n    \n    // Tạo dữ liệu ngẫu nhiên cho 32 bytes còn lại\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    \n    // Sao chép vào buffer\n    for (let i = 0; i < 32; i++) {\n      randomKey[i+1] = randomBytes[i];\n    }\n    \n    return randomKey;\n  }\n  \n  // Lấy tọa độ x và y\n  const x = new Uint8Array(uncompressedKey.slice(1, 33));\n  const y = new Uint8Array(uncompressedKey.slice(33, 65));\n  \n  // Tính prefix: 0x02 nếu y chẵn, 0x03 nếu y lẻ\n  const prefix = (y[31] & 1) === 0 ? 0x02 : 0x03;\n  \n  // Tạo khóa nén: prefix (1 byte) + x (32 bytes)\n  const compressedKey = Buffer.alloc(33);\n  compressedKey[0] = prefix;\n  \n  // Copy x vào compressedKey từ vị trí 1\n  for (let i = 0; i < 32; i++) {\n    compressedKey[i + 1] = x[i];\n  }\n  \n  return compressedKey;\n};"],"mappings":"AAAA;AACA;AACA;;AAEA,SAASA,MAAM,QAAQ,QAAQ;;AAE/B;AACA,OAAO,MAAMC,WAAW,GAAIC,MAAgC,IAAa;EACvE,MAAMC,SAAS,GAAGD,MAAM,YAAYE,UAAU,GAAGF,MAAM,GAAG,IAAIE,UAAU,CAACF,MAAM,CAAC;EAChF,OAAOG,KAAK,CAACC,IAAI,CAACH,SAAS,CAAC,CACzBI,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CACzCC,IAAI,CAAC,EAAE,CAAC;AACb,CAAC;;AAED;AACA,OAAO,MAAMC,WAAW,GAAIC,GAAW,IAAkB;EAAA,IAAAC,UAAA;EACvD,MAAMC,KAAK,GAAG,IAAIX,UAAU,CAAC,EAAAU,UAAA,GAAAD,GAAG,CAACG,KAAK,CAAC,SAAS,CAAC,cAAAF,UAAA,uBAApBA,UAAA,CAAsBP,GAAG,CAACU,IAAI,IAAIC,QAAQ,CAACD,IAAI,EAAE,EAAE,CAAC,CAAC,KAAI,EAAE,CAAC;EACzF,OAAOF,KAAK,CAACb,MAAM;AACrB,CAAC;;AAED;AACA,OAAO,MAAMiB,YAAY,GAAG,MAAOC,QAAgB,IAA0B;EAC3E,MAAMC,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC;EACjC,MAAMC,IAAI,GAAGF,OAAO,CAACG,MAAM,CAACJ,QAAQ,CAAC;EACrC,MAAMK,UAAU,GAAG,MAAMC,MAAM,CAACC,MAAM,CAACC,MAAM,CAAC,SAAS,EAAEL,IAAI,CAAC;EAC9D,OAAO,IAAInB,UAAU,CAACqB,UAAU,CAAC;AACnC,CAAC;;AAED;AACA,OAAO,MAAMI,iBAAiB,GAAIC,eAAuB,IAAa;EACpE;EACA,IAAIA,eAAe,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,eAAe,CAACC,MAAM,KAAK,EAAE,EAAE;IAChEC,OAAO,CAACC,IAAI,CAAC,gEAAgE,CAAC;IAC9E;IACA,MAAMC,SAAS,GAAGlC,MAAM,CAACmC,KAAK,CAAC,EAAE,CAAC;IAClCD,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;;IAErB;IACA,MAAME,WAAW,GAAG,IAAIhC,UAAU,CAAC,EAAE,CAAC;IACtCsB,MAAM,CAACW,eAAe,CAACD,WAAW,CAAC;;IAEnC;IACA,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;MAC3BJ,SAAS,CAACI,CAAC,GAAC,CAAC,CAAC,GAAGF,WAAW,CAACE,CAAC,CAAC;IACjC;IAEA,OAAOJ,SAAS;EAClB;;EAEA;EACA,MAAMK,CAAC,GAAG,IAAInC,UAAU,CAAC0B,eAAe,CAACU,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;EACtD,MAAMC,CAAC,GAAG,IAAIrC,UAAU,CAAC0B,eAAe,CAACU,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;;EAEvD;EACA,MAAME,MAAM,GAAG,CAACD,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,IAAI,GAAG,IAAI;;EAE9C;EACA,MAAME,aAAa,GAAG3C,MAAM,CAACmC,KAAK,CAAC,EAAE,CAAC;EACtCQ,aAAa,CAAC,CAAC,CAAC,GAAGD,MAAM;;EAEzB;EACA,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;IAC3BK,aAAa,CAACL,CAAC,GAAG,CAAC,CAAC,GAAGC,CAAC,CAACD,CAAC,CAAC;EAC7B;EAEA,OAAOK,aAAa;AACtB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}