{"ast":null,"code":"import { programID } from \"./transactionUtils\";\nimport { web3 } from \"@coral-xyz/anchor\";\n\n// Tạo hàm để lấy multisig PDA dựa vào credential ID\nexport const getMultisigPDA = credentialId => {\n  // Sử dụng hàm processCredentialIdForPDA để đồng bộ với cách tính trong smart contract\n  const seedBuffer = processCredentialIdForPDA(credentialId);\n  const [pda] = web3.PublicKey.findProgramAddressSync([Buffer.from(\"multisig\"), seedBuffer], programID);\n  return pda;\n};\n\n// Tạo hàm lấy guardian PDA (cập nhật để sử dụng credential ID)\nexport const getGuardianPDA = (walletPDA, guardianPubkey) => {\n  const [pda] = web3.PublicKey.findProgramAddressSync([Buffer.from(\"guardian\"), walletPDA.toBuffer(), guardianPubkey.toBuffer()], programID);\n  return pda;\n};\n\n/**\n * Xử lý credential ID để tính PDA đồng nhất với smart contract\n * Cách xử lý này phải khớp với hàm process_credential_id_seed trong smart contract\n */\nexport const processCredentialIdForPDA = credentialId => {\n  const credentialBuffer = Buffer.from(credentialId);\n\n  // Seed tối đa cho PDA là 32 bytes, trừ đi \"multisig\" (8 bytes) còn 24 bytes\n  let seedBuffer;\n  if (credentialBuffer.length > 24) {\n    console.log(\"Credential ID dài quá 24 bytes, thực hiện hash để đảm bảo đồng nhất với smart contract\");\n\n    // Dùng cách XOR hash giống như trong smart contract\n    const hashResult = new Uint8Array(24);\n    for (let i = 0; i < credentialBuffer.length; i++) {\n      hashResult[i % 24] ^= credentialBuffer[i];\n    }\n    seedBuffer = hashResult;\n  } else {\n    // Nếu không quá dài, tạo buffer mới với độ dài cố định 24 bytes, padding với 0\n    seedBuffer = new Uint8Array(24);\n    seedBuffer.set(credentialBuffer.subarray(0, Math.min(credentialBuffer.length, 24)));\n  }\n  return seedBuffer;\n};","map":{"version":3,"names":["programID","web3","getMultisigPDA","credentialId","seedBuffer","processCredentialIdForPDA","pda","PublicKey","findProgramAddressSync","Buffer","from","getGuardianPDA","walletPDA","guardianPubkey","toBuffer","credentialBuffer","length","console","log","hashResult","Uint8Array","i","set","subarray","Math","min"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/frontend_test/src/utils/helpers.ts"],"sourcesContent":["import { programID } from \"./transactionUtils\";\n\nimport { web3 } from \"@coral-xyz/anchor\";\n\n// Tạo hàm để lấy multisig PDA dựa vào credential ID\nexport const getMultisigPDA = (credentialId: string): web3.PublicKey => {\n  // Sử dụng hàm processCredentialIdForPDA để đồng bộ với cách tính trong smart contract\n  const seedBuffer = processCredentialIdForPDA(credentialId);\n  \n  const [pda] = web3.PublicKey.findProgramAddressSync(\n    [Buffer.from(\"multisig\"), seedBuffer],\n    programID\n  );\n  \n  return pda;\n};\n\n// Tạo hàm lấy guardian PDA (cập nhật để sử dụng credential ID)\nexport const getGuardianPDA = (walletPDA: web3.PublicKey, guardianPubkey: web3.PublicKey): web3.PublicKey => {\n  const [pda] = web3.PublicKey.findProgramAddressSync(\n    [Buffer.from(\"guardian\"), walletPDA.toBuffer(), guardianPubkey.toBuffer()],\n    programID\n  );\n  \n  return pda;\n};\n\n/**\n * Xử lý credential ID để tính PDA đồng nhất với smart contract\n * Cách xử lý này phải khớp với hàm process_credential_id_seed trong smart contract\n */\nexport const processCredentialIdForPDA = (credentialId: string): Uint8Array => {\n  const credentialBuffer = Buffer.from(credentialId);\n  \n  // Seed tối đa cho PDA là 32 bytes, trừ đi \"multisig\" (8 bytes) còn 24 bytes\n  let seedBuffer: Uint8Array;\n  \n  if (credentialBuffer.length > 24) {\n    console.log(\"Credential ID dài quá 24 bytes, thực hiện hash để đảm bảo đồng nhất với smart contract\");\n    \n    // Dùng cách XOR hash giống như trong smart contract\n    const hashResult = new Uint8Array(24);\n    for (let i = 0; i < credentialBuffer.length; i++) {\n      hashResult[i % 24] ^= credentialBuffer[i];\n    }\n    \n    seedBuffer = hashResult;\n  } else {\n    // Nếu không quá dài, tạo buffer mới với độ dài cố định 24 bytes, padding với 0\n    seedBuffer = new Uint8Array(24);\n    seedBuffer.set(credentialBuffer.subarray(0, Math.min(credentialBuffer.length, 24)));\n  }\n  \n  return seedBuffer;\n}; "],"mappings":"AAAA,SAASA,SAAS,QAAQ,oBAAoB;AAE9C,SAASC,IAAI,QAAQ,mBAAmB;;AAExC;AACA,OAAO,MAAMC,cAAc,GAAIC,YAAoB,IAAqB;EACtE;EACA,MAAMC,UAAU,GAAGC,yBAAyB,CAACF,YAAY,CAAC;EAE1D,MAAM,CAACG,GAAG,CAAC,GAAGL,IAAI,CAACM,SAAS,CAACC,sBAAsB,CACjD,CAACC,MAAM,CAACC,IAAI,CAAC,UAAU,CAAC,EAAEN,UAAU,CAAC,EACrCJ,SACF,CAAC;EAED,OAAOM,GAAG;AACZ,CAAC;;AAED;AACA,OAAO,MAAMK,cAAc,GAAGA,CAACC,SAAyB,EAAEC,cAA8B,KAAqB;EAC3G,MAAM,CAACP,GAAG,CAAC,GAAGL,IAAI,CAACM,SAAS,CAACC,sBAAsB,CACjD,CAACC,MAAM,CAACC,IAAI,CAAC,UAAU,CAAC,EAAEE,SAAS,CAACE,QAAQ,CAAC,CAAC,EAAED,cAAc,CAACC,QAAQ,CAAC,CAAC,CAAC,EAC1Ed,SACF,CAAC;EAED,OAAOM,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMD,yBAAyB,GAAIF,YAAoB,IAAiB;EAC7E,MAAMY,gBAAgB,GAAGN,MAAM,CAACC,IAAI,CAACP,YAAY,CAAC;;EAElD;EACA,IAAIC,UAAsB;EAE1B,IAAIW,gBAAgB,CAACC,MAAM,GAAG,EAAE,EAAE;IAChCC,OAAO,CAACC,GAAG,CAAC,wFAAwF,CAAC;;IAErG;IACA,MAAMC,UAAU,GAAG,IAAIC,UAAU,CAAC,EAAE,CAAC;IACrC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,gBAAgB,CAACC,MAAM,EAAEK,CAAC,EAAE,EAAE;MAChDF,UAAU,CAACE,CAAC,GAAG,EAAE,CAAC,IAAIN,gBAAgB,CAACM,CAAC,CAAC;IAC3C;IAEAjB,UAAU,GAAGe,UAAU;EACzB,CAAC,MAAM;IACL;IACAf,UAAU,GAAG,IAAIgB,UAAU,CAAC,EAAE,CAAC;IAC/BhB,UAAU,CAACkB,GAAG,CAACP,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,EAAEC,IAAI,CAACC,GAAG,CAACV,gBAAgB,CAACC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC;EACrF;EAEA,OAAOZ,UAAU;AACnB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}