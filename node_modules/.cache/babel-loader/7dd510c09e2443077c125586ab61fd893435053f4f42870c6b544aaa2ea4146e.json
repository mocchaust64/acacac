{"ast":null,"code":"import { PublicKey } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport { PROGRAM_ID } from '../App';\n\n/**\n * Xử lý credential ID để tạo seed cho PDA\n * Cách xử lý này phải khớp với hàm process_credential_id_seed trong smart contract\n */\nexport const processCredentialIdForPDA = credentialId => {\n  const credentialBuffer = Buffer.from(credentialId);\n  console.log(\"FRONTEND - processCredentialIdForPDA\");\n  console.log(\"Input credential ID:\", credentialId);\n  console.log(\"Credential buffer length:\", credentialBuffer.length);\n  console.log(\"Credential buffer bytes:\", Array.from(credentialBuffer));\n\n  // Seed tối đa cho PDA là 32 bytes, trừ đi \"multisig\" (8 bytes) còn 24 bytes\n  let seedBuffer;\n  if (credentialBuffer.length > 24) {\n    console.log(\"Credential ID dài quá 24 bytes, thực hiện hash để đảm bảo đồng nhất với smart contract\");\n\n    // Dùng cách XOR hash giống như trong smart contract\n    const hashResult = new Uint8Array(24);\n    for (let i = 0; i < credentialBuffer.length; i++) {\n      hashResult[i % 24] ^= credentialBuffer[i];\n    }\n    seedBuffer = hashResult;\n    console.log(\"Seed buffer sau khi hash:\", Array.from(seedBuffer));\n  } else {\n    // Nếu không quá dài, tạo buffer mới với độ dài cố định 24 bytes, padding với 0\n    seedBuffer = new Uint8Array(24);\n    seedBuffer.set(credentialBuffer);\n    console.log(\"Seed buffer không hash (padded):\", Array.from(seedBuffer));\n  }\n  return seedBuffer;\n};\n\n/**\n * Lấy multisig PDA dựa vào credential ID\n */\nexport const getMultisigPDA = credentialId => {\n  const seedBuffer = processCredentialIdForPDA(credentialId);\n  const [pda] = PublicKey.findProgramAddressSync([Buffer.from(\"multisig\"), seedBuffer], PROGRAM_ID);\n  return pda;\n};\n\n/**\n * Lấy guardian PDA dựa vào multisig PDA và guardian ID\n */\nexport const getGuardianPDA = (multisigPDA, guardianId) => {\n  const guardianIdBytes = new Uint8Array(8);\n  const view = new DataView(guardianIdBytes.buffer);\n  view.setBigUint64(0, BigInt(guardianId), true);\n  const [pda] = PublicKey.findProgramAddressSync([Buffer.from(\"guardian\"), multisigPDA.toBuffer(), guardianIdBytes], PROGRAM_ID);\n  return pda;\n};\n\n/**\n * Lấy tất cả guardian PDAs cho một multisig\n */\nexport const getAllGuardianPDAs = (multisigPDA, numGuardians) => {\n  const guardianPDAs = [];\n  for (let i = 1; i <= numGuardians; i++) {\n    guardianPDAs.push(getGuardianPDA(multisigPDA, i));\n  }\n  return guardianPDAs;\n};","map":{"version":3,"names":["PublicKey","Buffer","PROGRAM_ID","processCredentialIdForPDA","credentialId","credentialBuffer","from","console","log","length","Array","seedBuffer","hashResult","Uint8Array","i","set","getMultisigPDA","pda","findProgramAddressSync","getGuardianPDA","multisigPDA","guardianId","guardianIdBytes","view","DataView","buffer","setBigUint64","BigInt","toBuffer","getAllGuardianPDAs","numGuardians","guardianPDAs","push"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/frontend_test/src/utils/credentialUtils.ts"],"sourcesContent":["import { PublicKey } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport { PROGRAM_ID } from '../App';\n\n/**\n * Xử lý credential ID để tạo seed cho PDA\n * Cách xử lý này phải khớp với hàm process_credential_id_seed trong smart contract\n */\nexport const processCredentialIdForPDA = (credentialId: string): Uint8Array => {\n  const credentialBuffer = Buffer.from(credentialId);\n  \n  console.log(\"FRONTEND - processCredentialIdForPDA\");\n  console.log(\"Input credential ID:\", credentialId);\n  console.log(\"Credential buffer length:\", credentialBuffer.length);\n  console.log(\"Credential buffer bytes:\", Array.from(credentialBuffer));\n  \n  // Seed tối đa cho PDA là 32 bytes, trừ đi \"multisig\" (8 bytes) còn 24 bytes\n  let seedBuffer: Uint8Array;\n  \n  if (credentialBuffer.length > 24) {\n    console.log(\"Credential ID dài quá 24 bytes, thực hiện hash để đảm bảo đồng nhất với smart contract\");\n    \n    // Dùng cách XOR hash giống như trong smart contract\n    const hashResult = new Uint8Array(24);\n    for (let i = 0; i < credentialBuffer.length; i++) {\n      hashResult[i % 24] ^= credentialBuffer[i];\n    }\n    \n    seedBuffer = hashResult;\n    console.log(\"Seed buffer sau khi hash:\", Array.from(seedBuffer));\n  } else {\n    // Nếu không quá dài, tạo buffer mới với độ dài cố định 24 bytes, padding với 0\n    seedBuffer = new Uint8Array(24);\n    seedBuffer.set(credentialBuffer);\n    console.log(\"Seed buffer không hash (padded):\", Array.from(seedBuffer));\n  }\n  \n  return seedBuffer;\n};\n\n/**\n * Lấy multisig PDA dựa vào credential ID\n */\nexport const getMultisigPDA = (credentialId: string): PublicKey => {\n  const seedBuffer = processCredentialIdForPDA(credentialId);\n  \n  const [pda] = PublicKey.findProgramAddressSync(\n    [Buffer.from(\"multisig\"), seedBuffer],\n    PROGRAM_ID\n  );\n  \n  return pda;\n};\n\n/**\n * Lấy guardian PDA dựa vào multisig PDA và guardian ID\n */\nexport const getGuardianPDA = (multisigPDA: PublicKey, guardianId: number): PublicKey => {\n  const guardianIdBytes = new Uint8Array(8);\n  const view = new DataView(guardianIdBytes.buffer);\n  view.setBigUint64(0, BigInt(guardianId), true);\n  \n  const [pda] = PublicKey.findProgramAddressSync(\n    [\n      Buffer.from(\"guardian\"),\n      multisigPDA.toBuffer(),\n      guardianIdBytes\n    ],\n    PROGRAM_ID\n  );\n  \n  return pda;\n};\n\n/**\n * Lấy tất cả guardian PDAs cho một multisig\n */\nexport const getAllGuardianPDAs = (multisigPDA: PublicKey, numGuardians: number): PublicKey[] => {\n  const guardianPDAs: PublicKey[] = [];\n  for (let i = 1; i <= numGuardians; i++) {\n    guardianPDAs.push(getGuardianPDA(multisigPDA, i));\n  }\n  return guardianPDAs;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}