{"ast":null,"code":"import { BaseSignInMessageSignerWalletAdapter, WalletReadyState, WalletPublicKeyError, WalletNotReadyError, WalletConnectionError, WalletDisconnectedError, WalletNotConnectedError, WalletSignTransactionError, WalletSendTransactionError, WalletSignMessageError, isVersionedTransaction as isVersionedTransaction$1 } from '@solana/wallet-adapter-base';\nimport { PublicKey } from '@solana/web3.js';\nimport { transact, transactRemote } from '@solana-mobile/mobile-wallet-adapter-protocol-web3js';\nimport QRCode from 'qrcode';\nimport { toUint8Array as toUint8Array$1 } from 'js-base64';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction toUint8Array(base64EncodedByteArray) {\n  return new Uint8Array(window.atob(base64EncodedByteArray).split('').map(c => c.charCodeAt(0)));\n}\nfunction getIsSupported$1() {\n  return typeof window !== 'undefined' && window.isSecureContext && typeof document !== 'undefined' && /android/i.test(navigator.userAgent);\n}\nconst SolanaMobileWalletAdapterWalletName = 'Mobile Wallet Adapter';\nconst SIGNATURE_LENGTH_IN_BYTES$1 = 64;\nfunction getPublicKeyFromAddress$1(address) {\n  const publicKeyByteArray = toUint8Array(address);\n  return new PublicKey(publicKeyByteArray);\n}\nfunction isVersionedTransaction(transaction) {\n  return 'version' in transaction;\n}\nfunction clusterToChainId(cluster) {\n  switch (cluster) {\n    case 'mainnet-beta':\n      return 'solana:mainnet';\n    case 'testnet':\n      return 'solana:testnet';\n    case 'devnet':\n      return 'solana:devnet';\n  }\n}\nclass SolanaMobileWalletAdapter extends BaseSignInMessageSignerWalletAdapter {\n  constructor(config) {\n    var _a;\n    super();\n    this.supportedTransactionVersions = new Set(\n    // FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.\n    ['legacy', 0]);\n    this.name = SolanaMobileWalletAdapterWalletName;\n    this.url = 'https://solanamobile.com/wallets';\n    this.icon = 'data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==';\n    this._connecting = false;\n    /**\n     * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n     * increment this and use it to make sure that `transact` calls from the previous\n     * 'generation' don't continue to do work and throw exceptions.\n     */\n    this._connectionGeneration = 0;\n    this._readyState = getIsSupported$1() ? WalletReadyState.Loadable : WalletReadyState.Unsupported;\n    this._authorizationResultCache = config.authorizationResultCache;\n    this._addressSelector = config.addressSelector;\n    this._appIdentity = config.appIdentity;\n    this._chain = (_a = config.chain) !== null && _a !== void 0 ? _a : clusterToChainId(config.cluster);\n    this._hostAuthority = config.remoteHostAuthority;\n    this._onWalletNotFound = config.onWalletNotFound;\n    if (this._readyState !== WalletReadyState.Unsupported) {\n      this._authorizationResultCache.get().then(authorizationResult => {\n        if (authorizationResult) {\n          // Having a prior authorization result is, right now, the best\n          // indication that a mobile wallet is installed. There is no API\n          // we can use to test for whether the association URI is supported.\n          this.declareWalletAsInstalled();\n        }\n      });\n    }\n  }\n  get publicKey() {\n    if (this._publicKey == null && this._selectedAddress != null) {\n      try {\n        this._publicKey = getPublicKeyFromAddress$1(this._selectedAddress);\n      } catch (e) {\n        throw new WalletPublicKeyError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || 'Unknown error', e);\n      }\n    }\n    return this._publicKey ? this._publicKey : null;\n  }\n  get connected() {\n    return !!this._authorizationResult;\n  }\n  get connecting() {\n    return this._connecting;\n  }\n  get readyState() {\n    return this._readyState;\n  }\n  declareWalletAsInstalled() {\n    if (this._readyState !== WalletReadyState.Installed) {\n      this.emit('readyStateChange', this._readyState = WalletReadyState.Installed);\n    }\n  }\n  runWithGuard(callback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield callback();\n      } catch (e) {\n        this.emit('error', e);\n        throw e;\n      }\n    });\n  }\n  /** @deprecated Use `autoConnect()` instead. */\n  autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.autoConnect();\n    });\n  }\n  autoConnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.connecting || this.connected) {\n        return;\n      }\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        if (this._readyState !== WalletReadyState.Installed && this._readyState !== WalletReadyState.Loadable) {\n          throw new WalletNotReadyError();\n        }\n        this._connecting = true;\n        try {\n          const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n          if (cachedAuthorizationResult) {\n            // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n            this.handleAuthorizationResult(cachedAuthorizationResult);\n          }\n        } catch (e) {\n          throw new WalletConnectionError(e instanceof Error && e.message || 'Unknown error', e);\n        } finally {\n          this._connecting = false;\n        }\n      }));\n    });\n  }\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.connecting || this.connected) {\n        return;\n      }\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        if (this._readyState !== WalletReadyState.Installed && this._readyState !== WalletReadyState.Loadable) {\n          throw new WalletNotReadyError();\n        }\n        this._connecting = true;\n        try {\n          yield this.performAuthorization();\n        } catch (e) {\n          throw new WalletConnectionError(e instanceof Error && e.message || 'Unknown error', e);\n        } finally {\n          this._connecting = false;\n        }\n      }));\n    });\n  }\n  performAuthorization(signInPayload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n        if (cachedAuthorizationResult) {\n          // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n          this.handleAuthorizationResult(cachedAuthorizationResult);\n          return cachedAuthorizationResult;\n        }\n        return yield this.transact(wallet => __awaiter(this, void 0, void 0, function* () {\n          const authorizationResult = yield wallet.authorize({\n            chain: this._chain,\n            identity: this._appIdentity,\n            sign_in_payload: signInPayload\n          });\n          // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n          Promise.all([this._authorizationResultCache.set(authorizationResult), this.handleAuthorizationResult(authorizationResult)]);\n          return authorizationResult;\n        }));\n      } catch (e) {\n        throw new WalletConnectionError(e instanceof Error && e.message || 'Unknown error', e);\n      }\n    });\n  }\n  handleAuthorizationResult(authorizationResult) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const didPublicKeysChange =\n      // Case 1: We started from having no authorization.\n      this._authorizationResult == null ||\n      // Case 2: The number of authorized accounts changed.\n      ((_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorizationResult.accounts.length ||\n      // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n      this._authorizationResult.accounts.some((account, ii) => account.address !== authorizationResult.accounts[ii].address);\n      this._authorizationResult = authorizationResult;\n      this.declareWalletAsInstalled();\n      if (didPublicKeysChange) {\n        const nextSelectedAddress = yield this._addressSelector.select(authorizationResult.accounts.map(({\n          address\n        }) => address));\n        if (nextSelectedAddress !== this._selectedAddress) {\n          this._selectedAddress = nextSelectedAddress;\n          delete this._publicKey;\n          this.emit('connect',\n          // Having just set `this._selectedAddress`, `this.publicKey` is definitely non-null\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this.publicKey);\n        }\n      }\n    });\n  }\n  performReauthorization(wallet, authToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const authorizationResult = yield wallet.authorize({\n          auth_token: authToken,\n          identity: this._appIdentity\n        });\n        // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n        Promise.all([this._authorizationResultCache.set(authorizationResult), this.handleAuthorizationResult(authorizationResult)]);\n      } catch (e) {\n        this.disconnect();\n        throw new WalletDisconnectedError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || 'Unknown error', e);\n      }\n    });\n  }\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._authorizationResultCache.clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n      this._connecting = false;\n      this._connectionGeneration++;\n      delete this._authorizationResult;\n      delete this._publicKey;\n      delete this._selectedAddress;\n      this.emit('disconnect');\n    });\n  }\n  transact(callback) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const walletUriBase = (_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.wallet_uri_base;\n      const config = walletUriBase ? {\n        baseUri: walletUriBase\n      } : undefined;\n      const remoteConfig = this._hostAuthority ? {\n        remoteHostAuthority: this._hostAuthority\n      } : undefined;\n      const currentConnectionGeneration = this._connectionGeneration;\n      try {\n        return yield transact(callback, Object.assign(Object.assign({}, config), remoteConfig));\n      } catch (e) {\n        if (this._connectionGeneration !== currentConnectionGeneration) {\n          yield new Promise(() => {}); // Never resolve.\n        }\n        if (e instanceof Error && e.name === 'SolanaMobileWalletAdapterError' && e.code === 'ERROR_WALLET_NOT_FOUND') {\n          yield this._onWalletNotFound(this);\n        }\n        throw e;\n      }\n    });\n  }\n  assertIsAuthorized() {\n    if (!this._authorizationResult || !this._selectedAddress) throw new WalletNotConnectedError();\n    return {\n      authToken: this._authorizationResult.auth_token,\n      selectedAddress: this._selectedAddress\n    };\n  }\n  performSignTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        authToken\n      } = this.assertIsAuthorized();\n      try {\n        return yield this.transact(wallet => __awaiter(this, void 0, void 0, function* () {\n          yield this.performReauthorization(wallet, authToken);\n          const signedTransactions = yield wallet.signTransactions({\n            transactions\n          });\n          return signedTransactions;\n        }));\n      } catch (error) {\n        throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n      }\n    });\n  }\n  sendTransaction(transaction, connection, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        const {\n          authToken\n        } = this.assertIsAuthorized();\n        const minContextSlot = options === null || options === void 0 ? void 0 : options.minContextSlot;\n        try {\n          return yield this.transact(wallet => __awaiter(this, void 0, void 0, function* () {\n            function getTargetCommitment() {\n              let targetCommitment;\n              switch (connection.commitment) {\n                case 'confirmed':\n                case 'finalized':\n                case 'processed':\n                  targetCommitment = connection.commitment;\n                  break;\n                default:\n                  targetCommitment = 'finalized';\n              }\n              let targetPreflightCommitment;\n              switch (options === null || options === void 0 ? void 0 : options.preflightCommitment) {\n                case 'confirmed':\n                case 'finalized':\n                case 'processed':\n                  targetPreflightCommitment = options.preflightCommitment;\n                  break;\n                case undefined:\n                  targetPreflightCommitment = targetCommitment;\n                  break;\n                default:\n                  targetPreflightCommitment = 'finalized';\n              }\n              const preflightCommitmentScore = targetPreflightCommitment === 'finalized' ? 2 : targetPreflightCommitment === 'confirmed' ? 1 : 0;\n              const targetCommitmentScore = targetCommitment === 'finalized' ? 2 : targetCommitment === 'confirmed' ? 1 : 0;\n              return preflightCommitmentScore < targetCommitmentScore ? targetPreflightCommitment : targetCommitment;\n            }\n            const [capabilities, _1, _2] = yield Promise.all([wallet.getCapabilities(), this.performReauthorization(wallet, authToken), isVersionedTransaction(transaction) ? null :\n            /**\n             * Unlike versioned transactions, legacy `Transaction` objects\n             * may not have an associated `feePayer` or `recentBlockhash`.\n             * This code exists to patch them up in case they are missing.\n             */\n            (() => __awaiter(this, void 0, void 0, function* () {\n              var _a;\n              transaction.feePayer || (transaction.feePayer = (_a = this.publicKey) !== null && _a !== void 0 ? _a : undefined);\n              if (transaction.recentBlockhash == null) {\n                const {\n                  blockhash\n                } = yield connection.getLatestBlockhash({\n                  commitment: getTargetCommitment()\n                });\n                transaction.recentBlockhash = blockhash;\n              }\n            }))()]);\n            if (capabilities.supports_sign_and_send_transactions) {\n              const signatures = yield wallet.signAndSendTransactions({\n                minContextSlot,\n                transactions: [transaction]\n              });\n              return signatures[0];\n            } else {\n              const [signedTransaction] = yield wallet.signTransactions({\n                transactions: [transaction]\n              });\n              if (isVersionedTransaction(signedTransaction)) {\n                return yield connection.sendTransaction(signedTransaction);\n              } else {\n                const serializedTransaction = signedTransaction.serialize();\n                return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), {\n                  preflightCommitment: getTargetCommitment()\n                }));\n              }\n            }\n          }));\n        } catch (error) {\n          throw new WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      }));\n    });\n  }\n  signTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        const [signedTransaction] = yield this.performSignTransactions([transaction]);\n        return signedTransaction;\n      }));\n    });\n  }\n  signAllTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        const signedTransactions = yield this.performSignTransactions(transactions);\n        return signedTransactions;\n      }));\n    });\n  }\n  signMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        const {\n          authToken,\n          selectedAddress\n        } = this.assertIsAuthorized();\n        try {\n          return yield this.transact(wallet => __awaiter(this, void 0, void 0, function* () {\n            yield this.performReauthorization(wallet, authToken);\n            const [signedMessage] = yield wallet.signMessages({\n              addresses: [selectedAddress],\n              payloads: [message]\n            });\n            const signature = signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES$1);\n            return signature;\n          }));\n        } catch (error) {\n          throw new WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      }));\n    });\n  }\n  signIn(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        if (this._readyState !== WalletReadyState.Installed && this._readyState !== WalletReadyState.Loadable) {\n          throw new WalletNotReadyError();\n        }\n        this._connecting = true;\n        try {\n          const authorizationResult = yield this.performAuthorization(Object.assign(Object.assign({}, input), {\n            domain: (_a = input === null || input === void 0 ? void 0 : input.domain) !== null && _a !== void 0 ? _a : window.location.host\n          }));\n          if (!authorizationResult.sign_in_result) {\n            throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n          }\n          const signedInAddress = authorizationResult.sign_in_result.address;\n          const signedInAccount = Object.assign(Object.assign({}, (_b = authorizationResult.accounts.find(acc => acc.address == signedInAddress)) !== null && _b !== void 0 ? _b : {\n            address: signedInAddress\n          }), {\n            publicKey: toUint8Array(signedInAddress)\n          });\n          return {\n            account: signedInAccount,\n            signedMessage: toUint8Array(authorizationResult.sign_in_result.signed_message),\n            signature: toUint8Array(authorizationResult.sign_in_result.signature)\n          };\n        } catch (e) {\n          throw new WalletConnectionError(e instanceof Error && e.message || 'Unknown error', e);\n        } finally {\n          this._connecting = false;\n        }\n      }));\n    });\n  }\n}\nconst BluetoothHtml = `\n    <div class=\"mobile-wallet-adapter-embedded-modal-content\">\n    <button id=\"mobile-wallet-adapter-embedded-modal-close\" class=\"mobile-wallet-adapter-embedded-modal-close\">\n        <svg width=\"14\" height=\"14\">\n        <path d=\"M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z\" />\n        </svg>\n    </button>\n    <h1><b>Jupiter</b> wants to connect</h1>\n    <p class=\"mobile-wallet-adapter-embedded-modal-subtitle\">Connect to your mobile wallet app through Bluetooth.</p>\n    <div class=\"mobile-wallet-adapter-embedded-modal-connection-status-container\">\n        <div id=\"status-not-connected\" class=\"connection-status\">\n        <svg class=\"bluetooth-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n            <path fill=\"#a0a0a0\" d=\"M14.24 12.01l2.32 2.32c.28-.72.44-1.51.44-2.33 0-.82-.16-1.59-.43-2.31l-2.33 2.32zm5.29-5.3l-1.26 1.26c.63 1.21.98 2.57.98 4.02s-.36 2.82-.98 4.02l1.2 1.2c.97-1.54 1.54-3.36 1.54-5.31-.01-1.89-.55-3.67-1.48-5.19zm-3.82 1L10 2H9v7.59L4.41 5 3 6.41 8.59 12 3 17.59 4.41 19 9 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM11 5.83l1.88 1.88L11 9.59V5.83zm1.88 10.46L11 18.17v-3.76l1.88 1.88z\"/>\n        </svg>\n        <p>Not connected</p>\n        </div>\n        <div id=\"status-connecting\" class=\"connection-status\" style=\"display:none;\">\n        <div class=\"spinner\"></div>\n        <p>Connecting...</p>\n        </div>\n        <div id=\"status-connected\" class=\"connection-status\" style=\"display:none;\">\n        <svg class=\"checkmark-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n            <path fill=\"#4CAF50\" d=\"M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z\"/>\n        </svg>\n        <p>Connected</p>\n        </div>\n    </div>\n    <div class=\"button-group\">\n        <button id=\"cancel-btn\" class=\"cancel-btn\">Cancel</button>\n        <button id=\"connect-btn\" class=\"connect-btn\">Connect</button>\n    </div>\n    </div>\n`;\nconst QRCodeHtml = `\n<div class=\"mobile-wallet-adapter-embedded-modal-content\">\n  <button id=\"mobile-wallet-adapter-embedded-modal-close\" class=\"mobile-wallet-adapter-embedded-modal-close\">\n    <svg width=\"14\" height=\"14\">\n      <path d=\"M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z\" />\n    </svg>\n  </button>\n  <h1>Scan to connect</h1>\n  <p class=\"mobile-wallet-adapter-embedded-modal-subtitle\">Use your wallet app to scan the QR Code and connect.</p>\n  <div id=\"mobile-wallet-adapter-embedded-modal-qr-code-container\" />\n</div>\n`;\nconst css = `\n.mobile-wallet-adapter-embedded-modal {\n    display: flex; /* Use flexbox to center content */\n    flex-direction: column;\n    justify-content: center; /* Center horizontally */\n    align-items: center; /* Center vertically */\n    position: fixed; /* Stay in place */\n    z-index: 1; /* Sit on top */\n    left: 0;\n    top: 0;\n    width: 100%; /* Full width */\n    height: 100%; /* Full height */\n    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */\n}\n\n.mobile-wallet-adapter-embedded-modal-content {\n    background: #10141f;\n    padding: 20px;\n    border-radius: 10px;\n    width: 80%;\n    max-width: 500px;\n    text-align: center;\n    position: relative;\n    display: flex;\n    flex-direction: column;\n    align-items: center; /* Center children horizontally */\n}\n\n.mobile-wallet-adapter-embedded-modal-subtitle {\n    color: #D8D8D8;\n}\n\n.mobile-wallet-adapter-embedded-modal-close {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    position: absolute;\n    top: 18px;\n    right: 18px;\n    padding: 12px;\n    cursor: pointer;\n    background: #1a1f2e;\n    border: none;\n    border-radius: 50%;\n}\n\n.mobile-wallet-adapter-embedded-modal-close:focus-visible {\n    outline-color: white;\n}\n\n.mobile-wallet-adapter-embedded-modal-close svg {\n    fill: #777;\n    transition: fill 200ms ease 0s;\n}\n\n.mobile-wallet-adapter-embedded-modal-close:hover svg {\n    fill: #fff;\n}\n\n.icon-container {\n    display: flex;\n    justify-content: center;\n    margin-bottom: 20px;\n}\n\n.icon {\n    width: 80px;\n    height: 80px;\n    border-radius: 50%;\n    background-color: #ddd; /* Placeholder for icon background */\n}\n\n/* Modal Title */\n.mobile-wallet-adapter-embedded-modal-content h1 {\n    color: white;\n    font-size: 24px;   \n}\n\n.button-group {\n    display: flex;\n    width: 100%;\n    gap: 10px;\n}\n\n.connect-btn, .cancel-btn {\n    flex: 1;\n    padding: 12px 20px;\n    font-size: 16px;\n    cursor: pointer;\n    border-radius: 10px;\n    transition: all 0.3s ease;\n}\n\n.connect-btn {\n    background-color: #007bff;\n    color: white;\n    border: none;\n}\n\n.connect-btn:hover {\n    background-color: #0056b3;\n}\n\n.cancel-btn {\n    background-color: transparent;\n    color: #a0a0a0;\n    border: 1px solid #a0a0a0;\n}\n\n.cancel-btn:hover {\n    background-color: rgba(160, 160, 160, 0.1);\n}\n\n/* BT Connection Status */\n\n.mobile-wallet-adapter-embedded-modal-connection-status-container {\n    margin: 20px 0px 20px 0px;\n}\n\n.connection-status {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    margin: 20px 0;\n}\n  \n.connection-status p {\n    margin-top: 10px;\n    color: #a0a0a0;\n}\n  \n.bluetooth-icon, .checkmark-icon {\n    width: 48px;\n    height: 48px;\n}\n  \n.spinner {\n    border: 4px solid #f3f3f3;\n    border-top: 4px solid #3498db;\n    border-radius: 50%;\n    width: 40px;\n    height: 40px;\n    animation: spin 1s linear infinite;\n}\n  \n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* QR Code */\n\n#mobile-wallet-adapter-embedded-modal-qr-code-container {\n    width: 500px;\n    height: 500px;\n    align-content: center;\n}\n`;\nclass EmbeddedModal {\n  constructor(title) {\n    this._root = null;\n    this._title = title;\n    // Bind methods to ensure `this` context is correct\n    this.init = this.init.bind(this);\n    this.injectQRCodeHTML = this.injectQRCodeHTML.bind(this);\n    this.injectBluetoothHTML = this.injectBluetoothHTML.bind(this);\n    this.open = this.open.bind(this);\n    this.close = this.close.bind(this);\n    this.connect = this.connect.bind(this);\n    this._root = document.getElementById('mobile-wallet-adapter-embedded-root-ui');\n  }\n  init(qrCode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      console.log('Injecting modal');\n      this.injectStyles();\n      this.injectQRCodeHTML(qrCode);\n    });\n  }\n  setConnectionStatus(status) {\n    if (!this._root) return;\n    const statuses = ['not-connected', 'connecting', 'connected'];\n    statuses.forEach(s => {\n      const el = this._root.querySelector(`#status-${s}`);\n      if (el instanceof HTMLElement) {\n        el.style.display = s === status ? 'flex' : 'none';\n      }\n    });\n  }\n  injectStyles() {\n    // Check if the styles have already been injected\n    if (document.getElementById('mobile-wallet-adapter-styles')) {\n      return;\n    }\n    const styleElement = document.createElement('style');\n    styleElement.id = 'mobile-wallet-adapter-styles';\n    styleElement.textContent = css;\n    document.head.appendChild(styleElement);\n  }\n  populateQRCode(qrUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const qrcodeContainer = document.getElementById('mobile-wallet-adapter-embedded-modal-qr-code-container');\n      if (qrcodeContainer) {\n        const qrCodeElement = yield QRCode.toCanvas(qrUrl, {\n          width: 400\n        });\n        if (qrcodeContainer.firstElementChild !== null) {\n          qrcodeContainer.replaceChild(qrCodeElement, qrcodeContainer.firstElementChild);\n        } else qrcodeContainer.appendChild(qrCodeElement);\n      } else {\n        console.error('QRCode Container not found');\n      }\n    });\n  }\n  injectQRCodeHTML(qrCode) {\n    // Check if the HTML has already been injected\n    if (document.getElementById('mobile-wallet-adapter-embedded-root-ui')) {\n      if (!this._root) this._root = document.getElementById('mobile-wallet-adapter-embedded-root-ui');\n      this.populateQRCode(qrCode);\n      return;\n    }\n    // Create a container for the modal\n    this._root = document.createElement('div');\n    this._root.id = 'mobile-wallet-adapter-embedded-root-ui';\n    this._root.className = 'mobile-wallet-adapter-embedded-modal';\n    this._root.innerHTML = QRCodeHtml;\n    this._root.style.display = 'none';\n    // Append the modal to the body\n    document.body.appendChild(this._root);\n    // Render the QRCode\n    this.populateQRCode(qrCode);\n    this.attachEventListeners();\n  }\n  injectBluetoothHTML() {\n    // Check if the HTML has already been injected\n    if (document.getElementById('mobile-wallet-adapter-embedded-root-ui')) {\n      return;\n    }\n    this._root = document.createElement('div');\n    this._root.id = 'mobile-wallet-adapter-embedded-root-ui';\n    this._root.className = 'mobile-wallet-adapter-embedded-modal';\n    this._root.innerHTML = BluetoothHtml;\n    document.body.appendChild(this._root);\n    this.attachEventListeners();\n  }\n  attachEventListeners() {\n    if (!this._root) return;\n    const closeBtn = this._root.querySelector('#mobile-wallet-adapter-embedded-modal-close');\n    const cancelBtn = this._root.querySelector('#cancel-btn');\n    const connectBtn = this._root.querySelector('#connect-btn');\n    closeBtn === null || closeBtn === void 0 ? void 0 : closeBtn.addEventListener('click', () => this.close());\n    cancelBtn === null || cancelBtn === void 0 ? void 0 : cancelBtn.addEventListener('click', () => this.close());\n    connectBtn === null || connectBtn === void 0 ? void 0 : connectBtn.addEventListener('click', () => this.connect());\n  }\n  open() {\n    console.debug('Modal open');\n    if (this._root) {\n      this._root.style.display = 'flex';\n      this.setConnectionStatus('not-connected'); // Reset status when opening\n    }\n  }\n  close() {\n    console.debug('Modal close');\n    if (this._root) {\n      this._root.style.display = 'none';\n      this.setConnectionStatus('not-connected'); // Reset status when closing\n    }\n  }\n  connect() {\n    console.log('Connecting...');\n    // Mock connection\n    this.setConnectionStatus('connecting');\n    // Simulate connection process\n    setTimeout(() => {\n      this.setConnectionStatus('connected');\n      console.log('Connected!');\n    }, 5000); // 5 seconds delay\n  }\n}\nconst SolanaMobileWalletAdapterRemoteWalletName = 'MWA (Remote)';\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nfunction getPublicKeyFromAddress(address) {\n  const publicKeyByteArray = toUint8Array$1(address);\n  return new PublicKey(publicKeyByteArray);\n}\n/**\n * Determine the mobile operating system.\n * Returns true if running on a mobile operating system, or false otherwise.\n *\n * @returns {boolean}\n */\nfunction isMobileOperatingSystem() {\n  var userAgent = navigator.userAgent;\n  // Windows Phone must come first because its UA also contains \"Android\"\n  if (/windows phone/i.test(userAgent)) {\n    return true;\n  }\n  if (/android/i.test(userAgent)) {\n    return true;\n  }\n  // iOS detection from: http://stackoverflow.com/a/9039885/177710\n  if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {\n    return true;\n  }\n  return false;\n}\nfunction getIsSupported() {\n  return typeof window !== 'undefined' && window.isSecureContext && typeof document !== 'undefined' && !isMobileOperatingSystem();\n}\n/**\n * This burner wallet adapter is unsafe to use and is only included to provide an easy way for applications to test\n * Wallet Adapter without using a third-party wallet.\n */\nclass SolanaMobileWalletAdapterRemote extends BaseSignInMessageSignerWalletAdapter {\n  constructor(config) {\n    super();\n    this.supportedTransactionVersions = new Set(\n    // FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.\n    ['legacy', 0]);\n    this.name = SolanaMobileWalletAdapterRemoteWalletName;\n    this.url = 'https://solanamobile.com/wallets';\n    this.icon = 'data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==';\n    this._connecting = false;\n    /**\n     * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n     * increment this and use it to make sure that `transact` calls from the previous\n     * 'generation' don't continue to do work and throw exceptions.\n     */\n    this._connectionGeneration = 0;\n    this._readyState = getIsSupported() ? WalletReadyState.Loadable : WalletReadyState.Unsupported;\n    this._authorizationResultCache = config.authorizationResultCache;\n    this._addressSelector = config.addressSelector;\n    this._appIdentity = config.appIdentity;\n    this._chain = config.chain;\n    this._hostAuthority = config.remoteHostAuthority;\n    this._onWalletNotFound = config.onWalletNotFound;\n    if (this._readyState !== WalletReadyState.Unsupported) {\n      this._authorizationResultCache.get().then(authorizationResult => {\n        if (authorizationResult) {\n          // Having a prior authorization result is, right now, the best\n          // indication that a mobile wallet is installed. There is no API\n          // we can use to test for whether the association URI is supported.\n          this.declareWalletAsInstalled();\n        }\n      });\n    }\n  }\n  get publicKey() {\n    if (this._publicKey == null && this._selectedAddress != null) {\n      try {\n        this._publicKey = getPublicKeyFromAddress(this._selectedAddress);\n      } catch (e) {\n        throw new WalletPublicKeyError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || 'Unknown error', e);\n      }\n    }\n    return this._publicKey ? this._publicKey : null;\n  }\n  get connected() {\n    return !!this._authorizationResult;\n  }\n  get connecting() {\n    return this._connecting;\n  }\n  get readyState() {\n    return this._readyState;\n  }\n  declareWalletAsInstalled() {\n    if (this._readyState !== WalletReadyState.Installed) {\n      this.emit('readyStateChange', this._readyState = WalletReadyState.Installed);\n    }\n  }\n  runWithGuard(callback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield callback();\n      } catch (e) {\n        this.emit('error', e);\n        throw e;\n      }\n    });\n  }\n  autoConnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.connecting || this.connected) {\n        return;\n      }\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        if (this._readyState !== WalletReadyState.Installed && this._readyState !== WalletReadyState.Loadable) {\n          throw new WalletNotReadyError();\n        }\n        this._connecting = true;\n        try {\n          const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n          if (cachedAuthorizationResult) {\n            // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n            this.handleAuthorizationResult(cachedAuthorizationResult);\n          }\n        } catch (e) {\n          throw new WalletConnectionError(e instanceof Error && e.message || 'Unknown error', e);\n        } finally {\n          this._connecting = false;\n        }\n      }));\n    });\n  }\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.connecting || this.connected) {\n        return;\n      }\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        if (this._readyState !== WalletReadyState.Installed && this._readyState !== WalletReadyState.Loadable) {\n          throw new WalletNotReadyError();\n        }\n        this._connecting = true;\n        try {\n          yield this.performAuthorization();\n        } catch (e) {\n          throw new WalletConnectionError(e instanceof Error && e.message || 'Unknown error', e);\n        } finally {\n          this._connecting = false;\n        }\n      }));\n    });\n  }\n  performAuthorization(signInPayload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n        if (cachedAuthorizationResult) {\n          // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n          this.handleAuthorizationResult(cachedAuthorizationResult);\n          return cachedAuthorizationResult;\n        }\n        if (this._wallet) delete this._wallet;\n        return yield this.transact(wallet => __awaiter(this, void 0, void 0, function* () {\n          this._wallet = wallet;\n          const authorizationResult = yield wallet.authorize({\n            chain: this._chain,\n            identity: this._appIdentity,\n            sign_in_payload: signInPayload\n          });\n          // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n          Promise.all([this._authorizationResultCache.set(authorizationResult), this.handleAuthorizationResult(authorizationResult)]);\n          return authorizationResult;\n        }));\n      } catch (e) {\n        throw new WalletConnectionError(e instanceof Error && e.message || 'Unknown error', e);\n      }\n    });\n  }\n  handleAuthorizationResult(authorizationResult) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const didPublicKeysChange =\n      // Case 1: We started from having no authorization.\n      this._authorizationResult == null ||\n      // Case 2: The number of authorized accounts changed.\n      ((_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorizationResult.accounts.length ||\n      // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n      this._authorizationResult.accounts.some((account, ii) => account.address !== authorizationResult.accounts[ii].address);\n      this._authorizationResult = authorizationResult;\n      this.declareWalletAsInstalled();\n      if (didPublicKeysChange) {\n        const nextSelectedAddress = yield this._addressSelector.select(authorizationResult.accounts.map(({\n          address\n        }) => address));\n        if (nextSelectedAddress !== this._selectedAddress) {\n          this._selectedAddress = nextSelectedAddress;\n          delete this._publicKey;\n          this.emit('connect',\n          // Having just set `this._selectedAddress`, `this.publicKey` is definitely non-null\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this.publicKey);\n        }\n      }\n    });\n  }\n  performReauthorization(wallet, authToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const authorizationResult = yield wallet.authorize({\n          auth_token: authToken,\n          identity: this._appIdentity\n        });\n        // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n        Promise.all([this._authorizationResultCache.set(authorizationResult), this.handleAuthorizationResult(authorizationResult)]);\n      } catch (e) {\n        this.disconnect();\n        throw new WalletDisconnectedError(e instanceof Error && (e === null || e === void 0 ? void 0 : e.message) || 'Unknown error', e);\n      }\n    });\n  }\n  disconnect() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO: figure out why this call throws \"TypeError: _a.terminateSession is not a function\"\n      //  even though the session termination is actually executed (websocket closes). \n      try {\n        (_a = this._wallet) === null || _a === void 0 ? void 0 : _a.terminateSession();\n      } catch (e) {}\n      this._authorizationResultCache.clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n      this._connecting = false;\n      this._connectionGeneration++;\n      delete this._authorizationResult;\n      delete this._publicKey;\n      delete this._selectedAddress;\n      delete this._wallet;\n      this.emit('disconnect');\n    });\n  }\n  transact(callback) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const walletUriBase = (_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.wallet_uri_base;\n      const baseConfig = walletUriBase ? {\n        baseUri: walletUriBase\n      } : undefined;\n      const remoteConfig = Object.assign(Object.assign({}, baseConfig), {\n        remoteHostAuthority: this._hostAuthority\n      });\n      const currentConnectionGeneration = this._connectionGeneration;\n      const modal = new EmbeddedModal('MWA QR');\n      if (this._wallet) {\n        return callback(this._wallet);\n      }\n      try {\n        const {\n          associationUrl,\n          result: promise\n        } = yield transactRemote(wallet => __awaiter(this, void 0, void 0, function* () {\n          const result = yield callback(wallet);\n          modal.close();\n          return result;\n        }), remoteConfig);\n        modal.init(associationUrl.toString());\n        modal.open();\n        return yield promise;\n      } catch (e) {\n        modal.close();\n        if (this._connectionGeneration !== currentConnectionGeneration) {\n          yield new Promise(() => {}); // Never resolve.\n        }\n        if (e instanceof Error && e.name === 'SolanaMobileWalletAdapterError' && e.code === 'ERROR_WALLET_NOT_FOUND') {\n          yield this._onWalletNotFound(this);\n        }\n        throw e;\n      }\n    });\n  }\n  assertIsAuthorized() {\n    if (!this._authorizationResult || !this._selectedAddress) throw new WalletNotConnectedError();\n    return {\n      authToken: this._authorizationResult.auth_token,\n      selectedAddress: this._selectedAddress\n    };\n  }\n  performSignTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        authToken\n      } = this.assertIsAuthorized();\n      try {\n        return yield this.transact(wallet => __awaiter(this, void 0, void 0, function* () {\n          yield this.performReauthorization(wallet, authToken);\n          const signedTransactions = yield wallet.signTransactions({\n            transactions\n          });\n          return signedTransactions;\n        }));\n      } catch (error) {\n        throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n      }\n    });\n  }\n  sendTransaction(transaction, connection, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        const {\n          authToken\n        } = this.assertIsAuthorized();\n        const minContextSlot = options === null || options === void 0 ? void 0 : options.minContextSlot;\n        try {\n          return yield this.transact(wallet => __awaiter(this, void 0, void 0, function* () {\n            function getTargetCommitment() {\n              let targetCommitment;\n              switch (connection.commitment) {\n                case 'confirmed':\n                case 'finalized':\n                case 'processed':\n                  targetCommitment = connection.commitment;\n                  break;\n                default:\n                  targetCommitment = 'finalized';\n              }\n              let targetPreflightCommitment;\n              switch (options === null || options === void 0 ? void 0 : options.preflightCommitment) {\n                case 'confirmed':\n                case 'finalized':\n                case 'processed':\n                  targetPreflightCommitment = options.preflightCommitment;\n                  break;\n                case undefined:\n                  targetPreflightCommitment = targetCommitment;\n                  break;\n                default:\n                  targetPreflightCommitment = 'finalized';\n              }\n              const preflightCommitmentScore = targetPreflightCommitment === 'finalized' ? 2 : targetPreflightCommitment === 'confirmed' ? 1 : 0;\n              const targetCommitmentScore = targetCommitment === 'finalized' ? 2 : targetCommitment === 'confirmed' ? 1 : 0;\n              return preflightCommitmentScore < targetCommitmentScore ? targetPreflightCommitment : targetCommitment;\n            }\n            const [capabilities, _1, _2] = yield Promise.all([wallet.getCapabilities(), this.performReauthorization(wallet, authToken), isVersionedTransaction$1(transaction) ? null :\n            /**\n             * Unlike versioned transactions, legacy `Transaction` objects\n             * may not have an associated `feePayer` or `recentBlockhash`.\n             * This code exists to patch them up in case they are missing.\n             */\n            (() => __awaiter(this, void 0, void 0, function* () {\n              var _a;\n              transaction.feePayer || (transaction.feePayer = (_a = this.publicKey) !== null && _a !== void 0 ? _a : undefined);\n              if (transaction.recentBlockhash == null) {\n                const {\n                  blockhash\n                } = yield connection.getLatestBlockhash({\n                  commitment: getTargetCommitment()\n                });\n                transaction.recentBlockhash = blockhash;\n              }\n            }))()]);\n            if (capabilities.supports_sign_and_send_transactions) {\n              const signatures = yield wallet.signAndSendTransactions({\n                minContextSlot,\n                transactions: [transaction]\n              });\n              return signatures[0];\n            } else {\n              const [signedTransaction] = yield wallet.signTransactions({\n                transactions: [transaction]\n              });\n              if (isVersionedTransaction$1(signedTransaction)) {\n                return yield connection.sendTransaction(signedTransaction);\n              } else {\n                const serializedTransaction = signedTransaction.serialize();\n                return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), {\n                  preflightCommitment: getTargetCommitment()\n                }));\n              }\n            }\n          }));\n        } catch (error) {\n          throw new WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      }));\n    });\n  }\n  signTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        const [signedTransaction] = yield this.performSignTransactions([transaction]);\n        return signedTransaction;\n      }));\n    });\n  }\n  signAllTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        const signedTransactions = yield this.performSignTransactions(transactions);\n        return signedTransactions;\n      }));\n    });\n  }\n  signMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        const {\n          authToken,\n          selectedAddress\n        } = this.assertIsAuthorized();\n        try {\n          return yield this.transact(wallet => __awaiter(this, void 0, void 0, function* () {\n            yield this.performReauthorization(wallet, authToken);\n            const [signedMessage] = yield wallet.signMessages({\n              addresses: [selectedAddress],\n              payloads: [message]\n            });\n            const signature = signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES);\n            return signature;\n          }));\n        } catch (error) {\n          throw new WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      }));\n    });\n  }\n  signIn(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        if (this._readyState !== WalletReadyState.Installed && this._readyState !== WalletReadyState.Loadable) {\n          throw new WalletNotReadyError();\n        }\n        this._connecting = true;\n        try {\n          const authorizationResult = yield this.performAuthorization(Object.assign(Object.assign({}, input), {\n            domain: (_a = input === null || input === void 0 ? void 0 : input.domain) !== null && _a !== void 0 ? _a : window.location.host\n          }));\n          if (!authorizationResult.sign_in_result) {\n            throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n          }\n          const signedInAddress = authorizationResult.sign_in_result.address;\n          const signedInAccount = Object.assign(Object.assign({}, (_b = authorizationResult.accounts.find(acc => acc.address == signedInAddress)) !== null && _b !== void 0 ? _b : {\n            address: signedInAddress\n          }), {\n            publicKey: toUint8Array$1(signedInAddress)\n          });\n          return {\n            account: signedInAccount,\n            signedMessage: toUint8Array$1(authorizationResult.sign_in_result.signed_message),\n            signature: toUint8Array$1(authorizationResult.sign_in_result.signature)\n          };\n        } catch (e) {\n          throw new WalletConnectionError(e instanceof Error && e.message || 'Unknown error', e);\n        } finally {\n          this._connecting = false;\n        }\n      }));\n    });\n  }\n}\nfunction createDefaultAddressSelector() {\n  return {\n    select(addresses) {\n      return __awaiter(this, void 0, void 0, function* () {\n        return addresses[0];\n      });\n    }\n  };\n}\nconst CACHE_KEY = 'SolanaMobileWalletAdapterDefaultAuthorizationCache';\nfunction createDefaultAuthorizationResultCache() {\n  let storage;\n  try {\n    storage = window.localStorage;\n    // eslint-disable-next-line no-empty\n  } catch (_a) {}\n  return {\n    clear() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!storage) {\n          return;\n        }\n        try {\n          storage.removeItem(CACHE_KEY);\n          // eslint-disable-next-line no-empty\n        } catch (_a) {}\n      });\n    },\n    get() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!storage) {\n          return;\n        }\n        try {\n          return JSON.parse(storage.getItem(CACHE_KEY)) || undefined;\n          // eslint-disable-next-line no-empty\n        } catch (_a) {}\n      });\n    },\n    set(authorizationResult) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!storage) {\n          return;\n        }\n        try {\n          storage.setItem(CACHE_KEY, JSON.stringify(authorizationResult));\n          // eslint-disable-next-line no-empty\n        } catch (_a) {}\n      });\n    }\n  };\n}\nfunction defaultWalletNotFoundHandler(mobileWalletAdapter) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (typeof window !== 'undefined') {\n      window.location.assign(mobileWalletAdapter.url);\n    }\n  });\n}\nfunction createDefaultWalletNotFoundHandler() {\n  return defaultWalletNotFoundHandler;\n}\nexport { SolanaMobileWalletAdapter, SolanaMobileWalletAdapterRemote, SolanaMobileWalletAdapterRemoteWalletName, SolanaMobileWalletAdapterWalletName, createDefaultAddressSelector, createDefaultAuthorizationResultCache, createDefaultWalletNotFoundHandler };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}