{"ast":null,"code":"import { web3 } from '@coral-xyz/anchor';\nimport { PublicKey, Transaction, Keypair, SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport idlFile from '../idl/moon_wallet_program.json';\n\n// Export programID để có thể import được từ các file khác\nexport const programID = new PublicKey('HN8JJdo8c9iLQPzbTqjoioW61BDgyevHaGkCPSYLuDy');\n\n// Lấy discriminator từ IDL mới\nfunction getDiscriminatorFromIdl(instructionName) {\n  const instruction = idlFile.instructions.find(ix => ix.name === instructionName);\n  if (!instruction || !instruction.discriminator) {\n    throw new Error(`Không tìm thấy discriminator cho instruction: ${instructionName}`);\n  }\n  return Buffer.from(instruction.discriminator);\n}\n\n// Sửa lỗi type cho IDL\nconst idl = idlFile;\n\n// Cập nhật lại hàm tạo transaction\nexport const createInitializeMultisigTx = async (threshold, multisigPDA, owner, feePayer, recoveryHash, credentialId) => {\n  try {\n    const ownerPubkey = owner instanceof Keypair ? owner.publicKey : owner;\n\n    // Sử dụng discriminator chính xác từ IDL\n    const discriminator = Buffer.from([220, 130, 117, 21, 27, 227, 78, 213]);\n\n    // Đảm bảo recoveryHash có đúng 32 bytes\n    if (recoveryHash.length !== 32) {\n      throw new Error(\"Recovery hash phải đúng 32 bytes\");\n    }\n    const thresholdBuffer = Buffer.from([threshold]);\n    const recoveryHashBuffer = Buffer.from(recoveryHash);\n\n    // Tạo buffer cho độ dài credential ID\n    const credentialIdLenBuffer = Buffer.alloc(4);\n    credentialIdLenBuffer.writeUInt32LE(credentialId.length, 0);\n\n    // Nối tất cả lại với nhau\n    const data = Buffer.concat([new Uint8Array(discriminator), new Uint8Array(thresholdBuffer), new Uint8Array(recoveryHashBuffer), new Uint8Array(credentialIdLenBuffer), new Uint8Array(credentialId)]);\n\n    // Tạo transaction instruction\n    const instruction = new TransactionInstruction({\n      keys: [{\n        pubkey: multisigPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: feePayer.publicKey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: programID,\n      data\n    });\n    const tx = new Transaction().add(instruction);\n    return tx;\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction initialize multisig:\", error);\n    throw error;\n  }\n};\n\n// Thêm hàm compressPublicKey cho việc nén khóa công khai\nfunction compressPublicKey(uncompressedKey) {\n  // Đảm bảo khóa bắt đầu với byte 0x04 (không nén)\n  if (uncompressedKey[0] !== 0x04 || uncompressedKey.length !== 65) {\n    throw new Error('Khóa không đúng định dạng không nén ECDSA');\n  }\n\n  // Sử dụng Uint8Array để tránh lỗi type\n  const x = Buffer.from(uncompressedKey.subarray(1, 33));\n  const y = Buffer.from(uncompressedKey.subarray(33, 65));\n\n  // Tính prefix: 0x02 nếu y chẵn, 0x03 nếu y lẻ\n  const prefix = (y[31] & 1) === 0 ? 0x02 : 0x03;\n\n  // Tạo khóa nén: prefix (1 byte) + x (32 bytes)\n  const compressedKey = Buffer.alloc(33);\n  compressedKey[0] = prefix;\n  new Uint8Array(compressedKey).set(new Uint8Array(x), 1);\n  return compressedKey;\n}\n\n// Cập nhật hàm configure_webauthn với discriminator chính xác từ IDL\nexport const createConfigureWebAuthnTx = async (webauthnPubkey, multisigPDA, owner) => {\n  try {\n    // Lấy từ IDL: discriminator chính xác cho hàm configure_webauthn\n    const discriminator = Buffer.from([40, 149, 116, 224, 148, 48, 159, 54]);\n\n    // Nén khóa công khai từ 65 bytes xuống 33 bytes\n    let compressedKey;\n    if (webauthnPubkey.length === 65 && webauthnPubkey[0] === 0x04) {\n      // Khóa không nén, cần nén lại\n      compressedKey = compressPublicKey(webauthnPubkey);\n      console.log(\"Đã nén khóa từ 65 bytes xuống 33 bytes\");\n    } else if (webauthnPubkey.length === 33 && (webauthnPubkey[0] === 0x02 || webauthnPubkey[0] === 0x03)) {\n      // Khóa đã nén, sử dụng trực tiếp\n      compressedKey = webauthnPubkey;\n      console.log(\"Khóa đã ở định dạng nén (33 bytes)\");\n    } else {\n      console.warn(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPubkey.length} bytes`);\n      // Nếu không thể xử lý, tạo khóa giả\n      compressedKey = Buffer.alloc(33);\n      compressedKey[0] = 0x02; // Prefix cho khóa nén\n      if (webauthnPubkey.length > 0) {\n        // Sao chép dữ liệu nếu có\n        new Uint8Array(compressedKey).set(new Uint8Array(webauthnPubkey.subarray(0, Math.min(webauthnPubkey.length, 32))), 1);\n      }\n    }\n    console.log(\"Khóa công khai WebAuthn (nén):\", compressedKey.toString('hex'));\n    console.log(\"Độ dài khóa (bytes):\", compressedKey.length);\n\n    // Tạo dữ liệu instruction\n    const data = Buffer.concat([new Uint8Array(discriminator), new Uint8Array(compressedKey)]);\n\n    // Tạo instruction với đúng accounts theo IDL\n    const instruction = new TransactionInstruction({\n      keys: [{\n        pubkey: multisigPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: programID,\n      data\n    });\n    const tx = new Transaction().add(instruction);\n    return tx;\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction configure webauthn:\", error);\n    throw error;\n  }\n};\n\n/**\n * Tạo transaction cho storePasswordHash\n */\nexport const createStorePasswordHashTx = async (passwordHash, multisigPDA, ownerPubkey) => {\n  const tx = new web3.Transaction();\n\n  // Sửa lỗi Buffer.from\n  const discriminator = Buffer.from([\n  // Thay thế với giá trị discriminator thực tế\n  125, 106, 39, 42, 99, 108, 43, 50]);\n\n  // Sửa lại cách tạo data buffer\n  const data = Buffer.concat([new Uint8Array(discriminator), new Uint8Array(Buffer.from(Array.from(passwordHash)))]);\n\n  // Thêm instruction để lưu password hash\n  tx.add(new web3.TransactionInstruction({\n    keys: [{\n      pubkey: multisigPDA,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: ownerPubkey,\n      isSigner: true,\n      isWritable: false\n    }],\n    programId: programID,\n    data: data\n  }));\n  return tx;\n};\n\n/**\n * Tạo transaction xác thực WebAuthn\n */\nexport const createWebAuthnAuthTx = async (multisigPDA, ownerPubkey, webauthnSignature, authenticatorData, clientDataJSON) => {\n  const tx = new web3.Transaction();\n\n  // Thêm discriminator đúng cho verify_webauthn_auth\n  const instructionData = Buffer.concat([new Uint8Array(Buffer.from([234, 182, 165, 23, 186, 223, 208, 119])),\n  // discriminator từ IDL\n  new Uint8Array(Buffer.from(webauthnSignature)), new Uint8Array(Buffer.from(authenticatorData)), new Uint8Array(Buffer.from(clientDataJSON))]);\n  const instruction = new web3.TransactionInstruction({\n    keys: [{\n      pubkey: multisigPDA,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: ownerPubkey,\n      isSigner: false,\n      isWritable: false\n    }],\n    programId: programID,\n    data: instructionData\n  });\n  tx.add(instruction);\n  return tx;\n};\n\n// Tạo hàm mới createAddGuardianTx\nexport const createAddGuardianTx = (multisigPDA, guardianPDA, guardianPubkey, guardianName, recoveryHash, isOwner, webauthnPubkey) => {\n  try {\n    // Discriminator cho add_guardian\n    const discriminator = Buffer.from([167, 189, 170, 27, 74, 240, 201, 241]);\n\n    // Tạo buffer cho tên guardian\n    const nameBuffer = Buffer.from(guardianName);\n    const nameLenBuffer = Buffer.alloc(4);\n    nameLenBuffer.writeUInt32LE(nameBuffer.length, 0);\n\n    // Tạo buffer cho các tham số\n    const isOwnerByte = Buffer.from([isOwner ? 1 : 0]);\n\n    // Tạo buffers cho instruction data\n    const dataBuffers = [discriminator, guardianPubkey.toBuffer(), nameLenBuffer, nameBuffer, Buffer.from(recoveryHash)];\n\n    // Thêm isOwner\n    dataBuffers.push(isOwnerByte);\n\n    // Xử lý webauthn_pubkey (option)\n    if (webauthnPubkey && isOwner) {\n      // Some variant (1)\n      dataBuffers.push(Buffer.from([1]));\n\n      // Nén khóa công khai nếu cần\n      let compressedKey;\n      if (webauthnPubkey.length === 65 && webauthnPubkey[0] === 0x04) {\n        // Khóa không nén, cần nén lại\n        compressedKey = compressPublicKey(webauthnPubkey);\n      } else if (webauthnPubkey.length === 33 && (webauthnPubkey[0] === 0x02 || webauthnPubkey[0] === 0x03)) {\n        // Khóa đã nén, sử dụng trực tiếp\n        compressedKey = webauthnPubkey;\n      } else {\n        throw new Error(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPubkey.length} bytes`);\n      }\n      dataBuffers.push(compressedKey);\n    } else {\n      // None variant (0)\n      dataBuffers.push(Buffer.from([0]));\n    }\n\n    // Nối tất cả buffer lại với nhau\n    const data = Buffer.concat(dataBuffers.map(buffer => new Uint8Array(buffer)));\n\n    // Tạo instruction\n    const instruction = new TransactionInstruction({\n      keys: [{\n        pubkey: multisigPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: guardianPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: guardianPubkey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: programID,\n      data\n    });\n    return new Transaction().add(instruction);\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction add guardian:\", error);\n    throw error;\n  }\n};\n\n/**\n * Tạo transaction cho chức năng chuyển tiền (transfer)\n * @param multisigPDA PDA của ví đa chữ ký\n * @param guardian Thông tin guardian có quyền ký\n * @param destination Địa chỉ đích để chuyển tiền\n * @param amountLamports Số lượng lamports cần chuyển\n * @param nonce Nonce giao dịch\n * @param timestamp Thời gian giao dịch (unix timestamp)\n * @param message Thông điệp đã ký\n * @param payer Người trả phí giao dịch\n */\nexport const createTransferTx = (multisigPDA, guardianPDA, destination, amountLamports, nonce, timestamp, message, payer) => {\n  try {\n    // Discriminator cho verify_and_execute\n    const discriminator = Buffer.from([80, 118, 102, 72, 125, 57, 218, 137]);\n\n    // Tham số cho 'action' - chuỗi \"transfer\"\n    const action = \"transfer\";\n    const actionBuffer = Buffer.from(action);\n    const actionLenBuffer = Buffer.alloc(4);\n    actionLenBuffer.writeUInt32LE(actionBuffer.length, 0);\n\n    // Encode ActionParams\n    const amountBuffer = Buffer.alloc(9); // 1 byte cho Option + 8 bytes cho u64\n    amountBuffer.writeUInt8(1, 0); // 1 = Some\n    const amountBigInt = BigInt(amountLamports);\n    for (let i = 0; i < 8; i++) {\n      amountBuffer.writeUInt8(Number(amountBigInt >> BigInt(8 * i) & BigInt(0xFF)), i + 1);\n    }\n\n    // Encode destination\n    const destinationBuffer = Buffer.alloc(33); // 1 byte cho Option + 32 bytes cho PublicKey\n    destinationBuffer.writeUInt8(1, 0); // 1 = Some\n    Buffer.from(destination.toBuffer()).copy(destinationBuffer, 1);\n\n    // Encode token_mint (None)\n    const tokenMintBuffer = Buffer.alloc(1);\n    tokenMintBuffer.writeUInt8(0, 0); // 0 = None\n\n    // Encode nonce (u64, little-endian)\n    const nonceBuffer = Buffer.alloc(8);\n    const nonceBigInt = BigInt(nonce);\n    for (let i = 0; i < 8; i++) {\n      nonceBuffer.writeUInt8(Number(nonceBigInt >> BigInt(8 * i) & BigInt(0xFF)), i);\n    }\n\n    // Encode timestamp (i64, little-endian)\n    const timestampBuffer = Buffer.alloc(8);\n    const timestampBigInt = BigInt(timestamp);\n    for (let i = 0; i < 8; i++) {\n      timestampBuffer.writeUInt8(Number(timestampBigInt >> BigInt(8 * i) & BigInt(0xFF)), i);\n    }\n\n    // Encode message (vec<u8>)\n    const messageLenBuffer = Buffer.alloc(4);\n    messageLenBuffer.writeUInt32LE(message.length, 0);\n    const messageBuffer = Buffer.from(message);\n\n    // Nối tất cả buffer lại với nhau\n    const data = Buffer.concat([discriminator, actionLenBuffer, actionBuffer, amountBuffer, destinationBuffer, tokenMintBuffer, nonceBuffer, timestampBuffer, messageLenBuffer, messageBuffer]);\n\n    // Tạo instruction verify_and_execute\n    const ix = new TransactionInstruction({\n      keys: [{\n        pubkey: multisigPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: guardianPDA,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: new PublicKey('SysvarC1ock11111111111111111111111111111111'),\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: new PublicKey('Sysvar1nstructions1111111111111111111111111'),\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: payer,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: destination,\n        isSigner: false,\n        isWritable: true\n      }],\n      programId: programID,\n      data\n    });\n\n    // Tạo transaction mới\n    return new Transaction().add(ix);\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction chuyển tiền:\", error);\n    throw error;\n  }\n};\n\n/**\n * Tạo instruction data cho chương trình Secp256r1SigVerify\n * @param publicKey Khóa công khai của guardian (nén)\n * @param signature Chữ ký cho message\n * @param message Message đã hash bằng SHA-256\n */\nexport const createSecp256r1Instruction = (publicKey, signature, message) => {\n  // Constants\n  const SECP256R1_PROGRAM_ID = new PublicKey('Secp256r1SigVerify1111111111111111111111111');\n  const SIGNATURE_OFFSETS_SERIALIZED_SIZE = 14;\n  const SIGNATURE_OFFSETS_START = 2;\n  const DATA_START = SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START;\n  const SIGNATURE_SERIALIZED_SIZE = 64;\n  const COMPRESSED_PUBKEY_SERIALIZED_SIZE = 33;\n\n  // Tính toán tổng kích thước instruction data\n  const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + message.length;\n  const instructionData = Buffer.alloc(totalSize);\n\n  // Header\n  instructionData.writeUInt8(1, 0); // num_signatures = 1\n  instructionData.writeUInt8(0, 1); // padding\n\n  // Offsets\n  const publicKeyOffset = DATA_START;\n  const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n  const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n\n  // Write offsets\n  instructionData.writeUInt16LE(signatureOffset, SIGNATURE_OFFSETS_START);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 2);\n  instructionData.writeUInt16LE(publicKeyOffset, SIGNATURE_OFFSETS_START + 4);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 6);\n  instructionData.writeUInt16LE(messageDataOffset, SIGNATURE_OFFSETS_START + 8);\n  instructionData.writeUInt16LE(message.length, SIGNATURE_OFFSETS_START + 10);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 12);\n\n  // Write data\n  publicKey.copy(instructionData, publicKeyOffset);\n  signature.copy(instructionData, signatureOffset);\n  message.copy(instructionData, messageDataOffset);\n\n  // Tạo instruction\n  return new TransactionInstruction({\n    keys: [],\n    programId: SECP256R1_PROGRAM_ID,\n    data: instructionData\n  });\n};","map":{"version":3,"names":["web3","PublicKey","Transaction","Keypair","SystemProgram","TransactionInstruction","Buffer","idlFile","programID","getDiscriminatorFromIdl","instructionName","instruction","instructions","find","ix","name","discriminator","Error","from","idl","createInitializeMultisigTx","threshold","multisigPDA","owner","feePayer","recoveryHash","credentialId","ownerPubkey","publicKey","length","thresholdBuffer","recoveryHashBuffer","credentialIdLenBuffer","alloc","writeUInt32LE","data","concat","Uint8Array","keys","pubkey","isSigner","isWritable","programId","tx","add","error","console","compressPublicKey","uncompressedKey","x","subarray","y","prefix","compressedKey","set","createConfigureWebAuthnTx","webauthnPubkey","log","warn","Math","min","toString","createStorePasswordHashTx","passwordHash","Array","createWebAuthnAuthTx","webauthnSignature","authenticatorData","clientDataJSON","instructionData","createAddGuardianTx","guardianPDA","guardianPubkey","guardianName","isOwner","nameBuffer","nameLenBuffer","isOwnerByte","dataBuffers","toBuffer","push","map","buffer","createTransferTx","destination","amountLamports","nonce","timestamp","message","payer","action","actionBuffer","actionLenBuffer","amountBuffer","writeUInt8","amountBigInt","BigInt","i","Number","destinationBuffer","copy","tokenMintBuffer","nonceBuffer","nonceBigInt","timestampBuffer","timestampBigInt","messageLenBuffer","messageBuffer","createSecp256r1Instruction","signature","SECP256R1_PROGRAM_ID","SIGNATURE_OFFSETS_SERIALIZED_SIZE","SIGNATURE_OFFSETS_START","DATA_START","SIGNATURE_SERIALIZED_SIZE","COMPRESSED_PUBKEY_SERIALIZED_SIZE","totalSize","publicKeyOffset","signatureOffset","messageDataOffset","writeUInt16LE"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/frontend_test/src/utils/transactionUtils.ts"],"sourcesContent":["import { web3, BN } from '@coral-xyz/anchor';\nimport { PublicKey, Transaction, Keypair, SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport idlFile from '../idl/moon_wallet_program.json';\n\n// Export programID để có thể import được từ các file khác\nexport const programID = new PublicKey('HN8JJdo8c9iLQPzbTqjoioW61BDgyevHaGkCPSYLuDy');\n\n// Lấy discriminator từ IDL mới\nfunction getDiscriminatorFromIdl(instructionName: string): Buffer {\n  const instruction = idlFile.instructions.find(ix => ix.name === instructionName);\n  if (!instruction || !instruction.discriminator) {\n    throw new Error(`Không tìm thấy discriminator cho instruction: ${instructionName}`);\n  }\n  return Buffer.from(instruction.discriminator);\n}\n\n// Sửa lỗi type cho IDL\nconst idl: any = idlFile;\n\n// Cập nhật lại hàm tạo transaction\nexport const createInitializeMultisigTx = async (\n  threshold: number,\n  multisigPDA: PublicKey,\n  owner: PublicKey | Keypair,\n  feePayer: Keypair,\n  recoveryHash: Uint8Array,\n  credentialId: Buffer\n): Promise<Transaction> => {\n  try {\n    const ownerPubkey = owner instanceof Keypair ? owner.publicKey : owner;\n    \n    // Sử dụng discriminator chính xác từ IDL\n    const discriminator = Buffer.from([\n      220, 130, 117, 21, 27, 227, 78, 213\n    ]);\n    \n    // Đảm bảo recoveryHash có đúng 32 bytes\n    if (recoveryHash.length !== 32) {\n      throw new Error(\"Recovery hash phải đúng 32 bytes\");\n    }\n    \n    const thresholdBuffer = Buffer.from([threshold]);\n    const recoveryHashBuffer = Buffer.from(recoveryHash);\n    \n    // Tạo buffer cho độ dài credential ID\n    const credentialIdLenBuffer = Buffer.alloc(4);\n    credentialIdLenBuffer.writeUInt32LE(credentialId.length, 0);\n    \n    // Nối tất cả lại với nhau\n    const data = Buffer.concat([\n      new Uint8Array(discriminator),\n      new Uint8Array(thresholdBuffer),\n      new Uint8Array(recoveryHashBuffer),\n      new Uint8Array(credentialIdLenBuffer),\n      new Uint8Array(credentialId)\n    ]);\n    \n    // Tạo transaction instruction\n    const instruction = new TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: feePayer.publicKey, isSigner: true, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n      ],\n      programId: programID,\n      data\n    });\n    \n    const tx = new Transaction().add(instruction);\n    return tx;\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction initialize multisig:\", error);\n    throw error;\n  }\n};\n\n// Thêm hàm compressPublicKey cho việc nén khóa công khai\nfunction compressPublicKey(uncompressedKey: Buffer): Buffer {\n  // Đảm bảo khóa bắt đầu với byte 0x04 (không nén)\n  if (uncompressedKey[0] !== 0x04 || uncompressedKey.length !== 65) {\n    throw new Error('Khóa không đúng định dạng không nén ECDSA');\n  }\n  \n  // Sử dụng Uint8Array để tránh lỗi type\n  const x = Buffer.from(uncompressedKey.subarray(1, 33));\n  const y = Buffer.from(uncompressedKey.subarray(33, 65));\n  \n  // Tính prefix: 0x02 nếu y chẵn, 0x03 nếu y lẻ\n  const prefix = (y[31] & 1) === 0 ? 0x02 : 0x03;\n  \n  // Tạo khóa nén: prefix (1 byte) + x (32 bytes)\n  const compressedKey = Buffer.alloc(33);\n  compressedKey[0] = prefix;\n  new Uint8Array(compressedKey).set(new Uint8Array(x), 1);\n  \n  return compressedKey;\n}\n\n// Cập nhật hàm configure_webauthn với discriminator chính xác từ IDL\nexport const createConfigureWebAuthnTx = async (\n  webauthnPubkey: Buffer,\n  multisigPDA: PublicKey,\n  owner: PublicKey\n): Promise<Transaction> => {\n  try {\n    // Lấy từ IDL: discriminator chính xác cho hàm configure_webauthn\n    const discriminator = Buffer.from([\n      40, 149, 116, 224, 148, 48, 159, 54\n    ]);\n    \n    // Nén khóa công khai từ 65 bytes xuống 33 bytes\n    let compressedKey: Buffer;\n    \n    if (webauthnPubkey.length === 65 && webauthnPubkey[0] === 0x04) {\n      // Khóa không nén, cần nén lại\n      compressedKey = compressPublicKey(webauthnPubkey);\n      console.log(\"Đã nén khóa từ 65 bytes xuống 33 bytes\");\n    } else if (webauthnPubkey.length === 33 && (webauthnPubkey[0] === 0x02 || webauthnPubkey[0] === 0x03)) {\n      // Khóa đã nén, sử dụng trực tiếp\n      compressedKey = webauthnPubkey;\n      console.log(\"Khóa đã ở định dạng nén (33 bytes)\");\n    } else {\n      console.warn(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPubkey.length} bytes`);\n      // Nếu không thể xử lý, tạo khóa giả\n      compressedKey = Buffer.alloc(33);\n      compressedKey[0] = 0x02; // Prefix cho khóa nén\n      if (webauthnPubkey.length > 0) {\n        // Sao chép dữ liệu nếu có\n        new Uint8Array(compressedKey).set(\n          new Uint8Array(webauthnPubkey.subarray(0, Math.min(webauthnPubkey.length, 32))),\n          1\n        );\n      }\n    }\n    \n    console.log(\"Khóa công khai WebAuthn (nén):\", compressedKey.toString('hex'));\n    console.log(\"Độ dài khóa (bytes):\", compressedKey.length);\n    \n    // Tạo dữ liệu instruction\n    const data = Buffer.concat([\n      new Uint8Array(discriminator),\n      new Uint8Array(compressedKey)\n    ]);\n    \n    // Tạo instruction với đúng accounts theo IDL\n    const instruction = new TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: owner, isSigner: true, isWritable: false },\n      ],\n      programId: programID,\n      data\n    });\n    \n    const tx = new Transaction().add(instruction);\n    return tx;\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction configure webauthn:\", error);\n    throw error;\n  }\n};\n\n/**\n * Tạo transaction cho storePasswordHash\n */\nexport const createStorePasswordHashTx = async (\n  passwordHash: Uint8Array,\n  multisigPDA: web3.PublicKey,\n  ownerPubkey: web3.PublicKey\n) => {\n  const tx = new web3.Transaction();\n  \n  // Sửa lỗi Buffer.from\n  const discriminator = Buffer.from([\n    // Thay thế với giá trị discriminator thực tế\n    125, 106, 39, 42, 99, 108, 43, 50\n  ]);\n  \n  // Sửa lại cách tạo data buffer\n  const data = Buffer.concat([\n    new Uint8Array(discriminator),\n    new Uint8Array(Buffer.from(Array.from(passwordHash)))\n  ]);\n  \n  // Thêm instruction để lưu password hash\n  tx.add(\n    new web3.TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: ownerPubkey, isSigner: true, isWritable: false },\n      ],\n      programId: programID,\n      data: data\n    })\n  );\n  \n  return tx;\n};\n\n/**\n * Tạo transaction xác thực WebAuthn\n */\nexport const createWebAuthnAuthTx = async (\n  multisigPDA: web3.PublicKey,\n  ownerPubkey: web3.PublicKey,\n  webauthnSignature: Uint8Array,\n  authenticatorData: Uint8Array,\n  clientDataJSON: Uint8Array\n): Promise<web3.Transaction> => {\n  const tx = new web3.Transaction();\n  \n  // Thêm discriminator đúng cho verify_webauthn_auth\n  const instructionData = Buffer.concat([\n    new Uint8Array(Buffer.from([234, 182, 165, 23, 186, 223, 208, 119])), // discriminator từ IDL\n    new Uint8Array(Buffer.from(webauthnSignature)),\n    new Uint8Array(Buffer.from(authenticatorData)),\n    new Uint8Array(Buffer.from(clientDataJSON))\n  ]);\n  \n  const instruction = new web3.TransactionInstruction({\n    keys: [\n      { pubkey: multisigPDA, isSigner: false, isWritable: true },\n      { pubkey: ownerPubkey, isSigner: false, isWritable: false }\n    ],\n    programId: programID,\n    data: instructionData\n  });\n  \n  tx.add(instruction);\n  return tx;\n};\n\n// Tạo hàm mới createAddGuardianTx\nexport const createAddGuardianTx = (\n  multisigPDA: PublicKey,\n  guardianPDA: PublicKey,\n  guardianPubkey: PublicKey,\n  guardianName: string,\n  recoveryHash: Uint8Array,\n  isOwner: boolean,\n  webauthnPubkey?: Buffer\n): Transaction => {\n  try {\n    // Discriminator cho add_guardian\n    const discriminator = Buffer.from([167, 189, 170, 27, 74, 240, 201, 241]);\n    \n    // Tạo buffer cho tên guardian\n    const nameBuffer = Buffer.from(guardianName);\n    const nameLenBuffer = Buffer.alloc(4);\n    nameLenBuffer.writeUInt32LE(nameBuffer.length, 0);\n    \n    // Tạo buffer cho các tham số\n    const isOwnerByte = Buffer.from([isOwner ? 1 : 0]);\n    \n    // Tạo buffers cho instruction data\n    const dataBuffers = [\n      discriminator,\n      guardianPubkey.toBuffer(),\n      nameLenBuffer,\n      nameBuffer,\n      Buffer.from(recoveryHash)\n    ];\n    \n    // Thêm isOwner\n    dataBuffers.push(isOwnerByte);\n    \n    // Xử lý webauthn_pubkey (option)\n    if (webauthnPubkey && isOwner) {\n      // Some variant (1)\n      dataBuffers.push(Buffer.from([1]));\n      \n      // Nén khóa công khai nếu cần\n      let compressedKey: Buffer;\n      if (webauthnPubkey.length === 65 && webauthnPubkey[0] === 0x04) {\n        // Khóa không nén, cần nén lại\n        compressedKey = compressPublicKey(webauthnPubkey);\n      } else if (webauthnPubkey.length === 33 && (webauthnPubkey[0] === 0x02 || webauthnPubkey[0] === 0x03)) {\n        // Khóa đã nén, sử dụng trực tiếp\n        compressedKey = webauthnPubkey;\n      } else {\n        throw new Error(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPubkey.length} bytes`);\n      }\n      \n      dataBuffers.push(compressedKey);\n    } else {\n      // None variant (0)\n      dataBuffers.push(Buffer.from([0]));\n    }\n    \n    // Nối tất cả buffer lại với nhau\n    const data = Buffer.concat(dataBuffers.map(buffer => new Uint8Array(buffer)));\n    \n    // Tạo instruction\n    const instruction = new TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: guardianPDA, isSigner: false, isWritable: true },\n        { pubkey: guardianPubkey, isSigner: true, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n      ],\n      programId: programID,\n      data\n    });\n    \n    return new Transaction().add(instruction);\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction add guardian:\", error);\n    throw error;\n  }\n};\n\n/**\n * Tạo transaction cho chức năng chuyển tiền (transfer)\n * @param multisigPDA PDA của ví đa chữ ký\n * @param guardian Thông tin guardian có quyền ký\n * @param destination Địa chỉ đích để chuyển tiền\n * @param amountLamports Số lượng lamports cần chuyển\n * @param nonce Nonce giao dịch\n * @param timestamp Thời gian giao dịch (unix timestamp)\n * @param message Thông điệp đã ký\n * @param payer Người trả phí giao dịch\n */\nexport const createTransferTx = (\n  multisigPDA: PublicKey,\n  guardianPDA: PublicKey,\n  destination: PublicKey,\n  amountLamports: number,\n  nonce: number,\n  timestamp: number,\n  message: Uint8Array,\n  payer: PublicKey\n): Transaction => {\n  try {\n    // Discriminator cho verify_and_execute\n    const discriminator = Buffer.from([80, 118, 102, 72, 125, 57, 218, 137]);\n    \n    // Tham số cho 'action' - chuỗi \"transfer\"\n    const action = \"transfer\";\n    const actionBuffer = Buffer.from(action);\n    const actionLenBuffer = Buffer.alloc(4);\n    actionLenBuffer.writeUInt32LE(actionBuffer.length, 0);\n    \n    // Encode ActionParams\n    const amountBuffer = Buffer.alloc(9); // 1 byte cho Option + 8 bytes cho u64\n    amountBuffer.writeUInt8(1, 0); // 1 = Some\n    const amountBigInt = BigInt(amountLamports);\n    for (let i = 0; i < 8; i++) {\n      amountBuffer.writeUInt8(Number((amountBigInt >> BigInt(8 * i)) & BigInt(0xFF)), i + 1);\n    }\n    \n    // Encode destination\n    const destinationBuffer = Buffer.alloc(33); // 1 byte cho Option + 32 bytes cho PublicKey\n    destinationBuffer.writeUInt8(1, 0); // 1 = Some\n    Buffer.from(destination.toBuffer()).copy(destinationBuffer, 1);\n    \n    // Encode token_mint (None)\n    const tokenMintBuffer = Buffer.alloc(1);\n    tokenMintBuffer.writeUInt8(0, 0); // 0 = None\n    \n    // Encode nonce (u64, little-endian)\n    const nonceBuffer = Buffer.alloc(8);\n    const nonceBigInt = BigInt(nonce);\n    for (let i = 0; i < 8; i++) {\n      nonceBuffer.writeUInt8(Number((nonceBigInt >> BigInt(8 * i)) & BigInt(0xFF)), i);\n    }\n    \n    // Encode timestamp (i64, little-endian)\n    const timestampBuffer = Buffer.alloc(8);\n    const timestampBigInt = BigInt(timestamp);\n    for (let i = 0; i < 8; i++) {\n      timestampBuffer.writeUInt8(Number((timestampBigInt >> BigInt(8 * i)) & BigInt(0xFF)), i);\n    }\n    \n    // Encode message (vec<u8>)\n    const messageLenBuffer = Buffer.alloc(4);\n    messageLenBuffer.writeUInt32LE(message.length, 0);\n    const messageBuffer = Buffer.from(message);\n    \n    // Nối tất cả buffer lại với nhau\n    const data = Buffer.concat([\n      discriminator,\n      actionLenBuffer,\n      actionBuffer,\n      amountBuffer,\n      destinationBuffer,\n      tokenMintBuffer,\n      nonceBuffer,\n      timestampBuffer,\n      messageLenBuffer,\n      messageBuffer\n    ]);\n    \n    // Tạo instruction verify_and_execute\n    const ix = new TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: guardianPDA, isSigner: false, isWritable: false },\n        { pubkey: new PublicKey('SysvarC1ock11111111111111111111111111111111'), isSigner: false, isWritable: false },\n        { pubkey: new PublicKey('Sysvar1nstructions1111111111111111111111111'), isSigner: false, isWritable: false },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: destination, isSigner: false, isWritable: true }\n      ],\n      programId: programID,\n      data\n    });\n    \n    // Tạo transaction mới\n    return new Transaction().add(ix);\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction chuyển tiền:\", error);\n    throw error;\n  }\n};\n\n/**\n * Tạo instruction data cho chương trình Secp256r1SigVerify\n * @param publicKey Khóa công khai của guardian (nén)\n * @param signature Chữ ký cho message\n * @param message Message đã hash bằng SHA-256\n */\nexport const createSecp256r1Instruction = (\n  publicKey: Buffer, \n  signature: Buffer, \n  message: Buffer\n): TransactionInstruction => {\n  // Constants\n  const SECP256R1_PROGRAM_ID = new PublicKey('Secp256r1SigVerify1111111111111111111111111');\n  const SIGNATURE_OFFSETS_SERIALIZED_SIZE = 14;\n  const SIGNATURE_OFFSETS_START = 2;\n  const DATA_START = SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START;\n  const SIGNATURE_SERIALIZED_SIZE = 64;\n  const COMPRESSED_PUBKEY_SERIALIZED_SIZE = 33;\n  \n  // Tính toán tổng kích thước instruction data\n  const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + message.length;\n  const instructionData = Buffer.alloc(totalSize);\n  \n  // Header\n  instructionData.writeUInt8(1, 0); // num_signatures = 1\n  instructionData.writeUInt8(0, 1); // padding\n  \n  // Offsets\n  const publicKeyOffset = DATA_START;\n  const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n  const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n  \n  // Write offsets\n  instructionData.writeUInt16LE(signatureOffset, SIGNATURE_OFFSETS_START);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 2);\n  instructionData.writeUInt16LE(publicKeyOffset, SIGNATURE_OFFSETS_START + 4);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 6);\n  instructionData.writeUInt16LE(messageDataOffset, SIGNATURE_OFFSETS_START + 8);\n  instructionData.writeUInt16LE(message.length, SIGNATURE_OFFSETS_START + 10);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 12);\n  \n  // Write data\n  publicKey.copy(instructionData, publicKeyOffset);\n  signature.copy(instructionData, signatureOffset);\n  message.copy(instructionData, messageDataOffset);\n  \n  // Tạo instruction\n  return new TransactionInstruction({\n    keys: [],\n    programId: SECP256R1_PROGRAM_ID,\n    data: instructionData\n  });\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}