{"ast":null,"code":"import { TransactionInstruction } from '@solana/web3.js';\nimport { getWebAuthnAssertion } from './webauthnUtils';\nimport { derToRaw } from './secp256r1Utils';\n\n/**\n * Băm thông điệp thành một mảng 32-byte\n */\nconst hashMessage = async message => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  return new Uint8Array(hashBuffer);\n};\n\n/**\n * Tạo dữ liệu instruction để xác minh chữ ký secp256r1 trên Solana\n */\nconst createInstructionDataForSecp256r1Verification = (messageHash, publicKey, signature) => {\n  // 1 byte cho instruction type + 32 byte cho message hash + 65 byte cho public key + 64 byte cho signature\n  const dataLength = 1 + 32 + 65 + 64;\n  const data = Buffer.alloc(dataLength);\n\n  // Instruction type (0 = xác minh)\n  data.writeUInt8(0, 0);\n\n  // Copy message hash\n  Buffer.from(messageHash).copy(data, 1);\n\n  // Copy public key\n  Buffer.from(publicKey).copy(data, 1 + 32);\n\n  // Copy signature\n  Buffer.from(signature).copy(data, 1 + 32 + 65);\n  return data;\n};\n\n/**\n * Ký một thông điệp bằng WebAuthn và tạo transaction instruction để xác minh trên Solana\n */\nexport const signWithWebAuthnAndCreateInstruction = async (message, programId) => {\n  try {\n    console.log(\"Bắt đầu quá trình ký bằng WebAuthn cho thông điệp:\", message);\n\n    // Ký thông điệp bằng WebAuthn\n    const {\n      signature: derSignature,\n      authenticatorData,\n      clientDataJSON\n    } = await getWebAuthnAssertion();\n    console.log(\"Đã nhận chữ ký WebAuthn:\", Buffer.from(derSignature).toString('hex'));\n    console.log(\"Authenticator data length:\", authenticatorData.length);\n    console.log(\"Authenticator data:\", Buffer.from(authenticatorData).toString('hex'));\n\n    // Convert chữ ký từ định dạng DER sang raw (r,s)\n    const rawSignature = derToRaw(derSignature);\n    console.log(\"Raw signature:\", Buffer.from(rawSignature).toString('hex'));\n\n    // Băm thông điệp\n    const messageHash = await hashMessage(message);\n    console.log(\"Message hash:\", Buffer.from(messageHash).toString('hex'));\n\n    // Trích xuất public key từ authenticator data\n    const publicKey = extractP256PublicKeyFromAuthData(authenticatorData);\n    console.log(\"Extracted public key:\", Buffer.from(publicKey).toString('hex'));\n\n    // Tạo instruction data\n    const instructionData = createInstructionDataForSecp256r1Verification(messageHash, publicKey, rawSignature);\n\n    // Tạo transaction instruction\n    return new TransactionInstruction({\n      keys: [],\n      programId,\n      data: instructionData\n    });\n  } catch (error) {\n    console.error(\"Lỗi khi ký bằng WebAuthn:\", error);\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    throw new Error(`Không thể ký giao dịch: ${errorMessage}`);\n  }\n};\n\n/**\n * Trích xuất public key từ authenticator data\n */\nfunction extractP256PublicKeyFromAuthData(authData) {\n  try {\n    // In ra dữ liệu để debug\n    console.log(\"Raw auth data (hex):\", Buffer.from(authData).toString('hex'));\n    if (authData.length < 37) {\n      throw new Error('Authenticator data quá ngắn, không thể trích xuất CBOR data');\n    }\n\n    // Bỏ qua 32 byte rpIdHash + 1 byte flags + 4 byte counter\n    let offset = 37;\n\n    // Kiểm tra xem còn dữ liệu hay không\n    if (authData.length <= offset) {\n      throw new Error('Authenticator data không chứa attestation data hoặc extension data');\n    }\n\n    // TODO: Phân tích CBOR data để trích xuất public key\n    // Đây là phiên bản đơn giản, cần cải thiện để hỗ trợ các định dạng khác\n\n    // Giả định public key là dạng không nén với format:\n    // 0x04 + x-coordinate (32 bytes) + y-coordinate (32 bytes)\n    const publicKey = new Uint8Array(65);\n    publicKey[0] = 0x04; // Uncompressed point format\n\n    // Đọc x và y từ authenticator data\n    // Đây là vị trí ước tính, cần xác định chính xác dựa trên CBOR parsing\n    const xStart = offset + 10; // Vị trí tạm thời, cần xác định chính xác\n    const yStart = xStart + 32;\n    if (authData.length < yStart + 32) {\n      throw new Error('Authenticator data không đủ dài để chứa public key');\n    }\n\n    // Copy các tọa độ x và y\n    for (let i = 0; i < 32; i++) {\n      publicKey[1 + i] = authData[xStart + i];\n      publicKey[33 + i] = authData[yStart + i];\n    }\n    return publicKey;\n  } catch (error) {\n    console.error(\"Lỗi khi trích xuất public key từ authenticator data:\", error);\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    throw new Error(`Không thể trích xuất public key: ${errorMessage}`);\n  }\n}","map":{"version":3,"names":["TransactionInstruction","getWebAuthnAssertion","derToRaw","hashMessage","message","encoder","TextEncoder","data","encode","hashBuffer","crypto","subtle","digest","Uint8Array","createInstructionDataForSecp256r1Verification","messageHash","publicKey","signature","dataLength","Buffer","alloc","writeUInt8","from","copy","signWithWebAuthnAndCreateInstruction","programId","console","log","derSignature","authenticatorData","clientDataJSON","toString","length","rawSignature","extractP256PublicKeyFromAuthData","instructionData","keys","error","errorMessage","Error","String","authData","offset","xStart","yStart","i"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/acacac/src/utils/webauthnSigningUtils.ts"],"sourcesContent":["import { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { getWebAuthnAssertion } from './webauthnUtils';\nimport { derToRaw } from './secp256r1Utils';\n\n/**\n * Băm thông điệp thành một mảng 32-byte\n */\nconst hashMessage = async (message: string): Promise<Uint8Array> => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  return new Uint8Array(hashBuffer);\n};\n\n/**\n * Tạo dữ liệu instruction để xác minh chữ ký secp256r1 trên Solana\n */\nconst createInstructionDataForSecp256r1Verification = (\n  messageHash: Uint8Array,\n  publicKey: Uint8Array,\n  signature: Uint8Array\n): Buffer => {\n  // 1 byte cho instruction type + 32 byte cho message hash + 65 byte cho public key + 64 byte cho signature\n  const dataLength = 1 + 32 + 65 + 64;\n  const data = Buffer.alloc(dataLength);\n  \n  // Instruction type (0 = xác minh)\n  data.writeUInt8(0, 0);\n  \n  // Copy message hash\n  Buffer.from(messageHash).copy(data, 1);\n  \n  // Copy public key\n  Buffer.from(publicKey).copy(data, 1 + 32);\n  \n  // Copy signature\n  Buffer.from(signature).copy(data, 1 + 32 + 65);\n  \n  return data;\n};\n\n/**\n * Ký một thông điệp bằng WebAuthn và tạo transaction instruction để xác minh trên Solana\n */\nexport const signWithWebAuthnAndCreateInstruction = async (\n  message: string,\n  programId: PublicKey\n): Promise<TransactionInstruction> => {\n  try {\n    console.log(\"Bắt đầu quá trình ký bằng WebAuthn cho thông điệp:\", message);\n    \n    // Ký thông điệp bằng WebAuthn\n    const { signature: derSignature, authenticatorData, clientDataJSON } = \n      await getWebAuthnAssertion();\n    \n    console.log(\"Đã nhận chữ ký WebAuthn:\", \n      Buffer.from(derSignature).toString('hex'));\n    console.log(\"Authenticator data length:\", authenticatorData.length);\n    console.log(\"Authenticator data:\", Buffer.from(authenticatorData).toString('hex'));\n    \n    // Convert chữ ký từ định dạng DER sang raw (r,s)\n    const rawSignature = derToRaw(derSignature);\n    console.log(\"Raw signature:\", Buffer.from(rawSignature).toString('hex'));\n    \n    // Băm thông điệp\n    const messageHash = await hashMessage(message);\n    console.log(\"Message hash:\", Buffer.from(messageHash).toString('hex'));\n    \n    // Trích xuất public key từ authenticator data\n    const publicKey = extractP256PublicKeyFromAuthData(authenticatorData);\n    console.log(\"Extracted public key:\", Buffer.from(publicKey).toString('hex'));\n    \n    // Tạo instruction data\n    const instructionData = createInstructionDataForSecp256r1Verification(\n      messageHash,\n      publicKey,\n      rawSignature\n    );\n    \n    // Tạo transaction instruction\n    return new TransactionInstruction({\n      keys: [],\n      programId,\n      data: instructionData,\n    });\n  } catch (error: unknown) {\n    console.error(\"Lỗi khi ký bằng WebAuthn:\", error);\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    throw new Error(`Không thể ký giao dịch: ${errorMessage}`);\n  }\n};\n\n/**\n * Trích xuất public key từ authenticator data\n */\nfunction extractP256PublicKeyFromAuthData(authData: Uint8Array): Uint8Array {\n  try {\n    // In ra dữ liệu để debug\n    console.log(\"Raw auth data (hex):\", Buffer.from(authData).toString('hex'));\n    \n    if (authData.length < 37) {\n      throw new Error('Authenticator data quá ngắn, không thể trích xuất CBOR data');\n    }\n    \n    // Bỏ qua 32 byte rpIdHash + 1 byte flags + 4 byte counter\n    let offset = 37;\n    \n    // Kiểm tra xem còn dữ liệu hay không\n    if (authData.length <= offset) {\n      throw new Error('Authenticator data không chứa attestation data hoặc extension data');\n    }\n    \n    // TODO: Phân tích CBOR data để trích xuất public key\n    // Đây là phiên bản đơn giản, cần cải thiện để hỗ trợ các định dạng khác\n    \n    // Giả định public key là dạng không nén với format:\n    // 0x04 + x-coordinate (32 bytes) + y-coordinate (32 bytes)\n    const publicKey = new Uint8Array(65);\n    publicKey[0] = 0x04; // Uncompressed point format\n    \n    // Đọc x và y từ authenticator data\n    // Đây là vị trí ước tính, cần xác định chính xác dựa trên CBOR parsing\n    const xStart = offset + 10; // Vị trí tạm thời, cần xác định chính xác\n    const yStart = xStart + 32;\n    \n    if (authData.length < yStart + 32) {\n      throw new Error('Authenticator data không đủ dài để chứa public key');\n    }\n    \n    // Copy các tọa độ x và y\n    for (let i = 0; i < 32; i++) {\n      publicKey[1 + i] = authData[xStart + i];\n      publicKey[33 + i] = authData[yStart + i];\n    }\n    \n    return publicKey;\n  } catch (error: unknown) {\n    console.error(\"Lỗi khi trích xuất public key từ authenticator data:\", error);\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    throw new Error(`Không thể trích xuất public key: ${errorMessage}`);\n  }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}