{"ast":null,"code":"import { Transaction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport { createSecp256r1Instruction } from './transactionUtils';\nimport { convertDERtoRaw } from './webauthnUtils';\n\n// Định nghĩa kiểu wallet tương thích\n\n/**\n * Kiểm tra và chuyển đổi signature nếu cần\n * @param signature Signature cần kiểm tra\n * @returns Signature đã xử lý\n */\nfunction prepareSignature(signature) {\n  // Kiểm tra xem signature có phải định dạng DER không (thường bắt đầu bằng 0x30)\n  if (signature.length > 70 && signature[0] === 0x30) {\n    console.log('Phát hiện signature DER format, đang chuyển đổi sang raw format...');\n    try {\n      const rawSignature = convertDERtoRaw(new Uint8Array(signature));\n      return Buffer.from(rawSignature);\n    } catch (error) {\n      console.error('Lỗi khi chuyển đổi signature DER:', error);\n      return signature;\n    }\n  }\n\n  // Trả về signature nguyên bản nếu đã là raw format\n  return signature;\n}\n\n/**\n * Kiểm tra instruction secp256r1 độc lập\n * @param connection Kết nối Solana\n * @param message Message gốc cần xác thực\n * @param publicKey Public key đã nén (33 bytes)\n * @param signature Chữ ký raw (64 bytes)\n * @param wallet Wallet để ký giao dịch\n */\nexport async function testSecp256r1(connection, message, publicKey, signature, wallet) {\n  try {\n    console.log('Kiểm tra secp256r1 với:', {\n      publicKey: publicKey.toString('hex'),\n      publicKeyLength: publicKey.length,\n      signature: signature.toString('hex'),\n      signatureLength: signature.length,\n      message: message.toString(),\n      messageBytes: message.toString('hex'),\n      messageLength: message.length\n    });\n\n    // Chuẩn bị signature\n    const preparedSignature = prepareSignature(signature);\n    if (preparedSignature !== signature) {\n      console.log('Signature đã được chuyển đổi, độ dài mới:', preparedSignature.length);\n      console.log('Signature sau khi chuyển đổi:', preparedSignature.toString('hex'));\n    }\n\n    // Tạo instruction secp256r1\n    const instruction = createSecp256r1Instruction(message, publicKey, preparedSignature);\n\n    // Tạo và gửi transaction\n    const transaction = new Transaction().add(instruction);\n    transaction.feePayer = wallet.publicKey;\n    const {\n      blockhash\n    } = await connection.getLatestBlockhash();\n    transaction.recentBlockhash = blockhash;\n    const signedTx = await wallet.signTransaction(transaction);\n    const txSignature = await connection.sendRawTransaction(signedTx.serialize());\n    console.log('Giao dịch đã được gửi với signature:', txSignature);\n    await connection.confirmTransaction(txSignature, 'confirmed');\n    console.log('Giao dịch đã được xác nhận');\n    return true;\n  } catch (error) {\n    console.error('Lỗi khi kiểm tra secp256r1:', error);\n    return false;\n  }\n}\n\n/**\n * Tạo các biến thể khác nhau của public key để kiểm tra\n * @param publicKey Public key gốc\n */\nexport function generatePublicKeyVariants(publicKey) {\n  const variants = [];\n\n  // Biến thể 1: Giữ nguyên public key gốc\n  variants.push(Buffer.from(publicKey));\n  console.log('Biến thể 1 (Gốc):', publicKey.toString('hex'));\n\n  // Biến thể 2: Đảo ngược tất cả các byte\n  const fullReversedPubKey = Buffer.from(publicKey);\n  fullReversedPubKey.reverse();\n  variants.push(fullReversedPubKey);\n  console.log('Biến thể 2 (Đảo ngược tất cả):', fullReversedPubKey.toString('hex'));\n\n  // Biến thể 3: Đảo ngược tất cả các byte trừ byte đầu tiên\n  const partialReversedPubKey = Buffer.alloc(33);\n  partialReversedPubKey[0] = publicKey[0]; // Giữ nguyên byte đầu tiên\n  for (let i = 1; i < 33; i++) {\n    partialReversedPubKey[i] = publicKey[34 - i]; // Đảo ngược các byte còn lại\n  }\n  variants.push(partialReversedPubKey);\n  console.log('Biến thể 3 (Đảo ngược trừ byte đầu):', partialReversedPubKey.toString('hex'));\n\n  // Biến thể 4: Chuyển đổi byte đầu tiên giữa 0x02 và 0x03 (thay đổi dấu của y)\n  const prefixChangedPubKey = Buffer.from(publicKey);\n  if (prefixChangedPubKey[0] === 0x02) {\n    prefixChangedPubKey[0] = 0x03;\n  } else if (prefixChangedPubKey[0] === 0x03) {\n    prefixChangedPubKey[0] = 0x02;\n  }\n  variants.push(prefixChangedPubKey);\n  console.log('Biến thể 4 (Đổi dấu y):', prefixChangedPubKey.toString('hex'));\n  return variants;\n}\n\n/**\n * Kiểm tra với nhiều biến thể của public key\n */\nexport async function testMultiplePublicKeys(connection, message, signature, wallet, publicKeyVariants) {\n  console.log(`Bắt đầu kiểm tra với ${publicKeyVariants.length} biến thể của public key...`);\n  for (let i = 0; i < publicKeyVariants.length; i++) {\n    const variant = publicKeyVariants[i];\n    console.log(`Kiểm tra biến thể #${i + 1}:`, variant.toString('hex'));\n    const success = await testSecp256r1(connection, message, variant, signature, wallet);\n    if (success) {\n      console.log(`Biến thể #${i + 1} thành công!`);\n    } else {\n      console.log(`Biến thể #${i + 1} thất bại.`);\n    }\n  }\n  console.log('Đã hoàn tất việc kiểm tra các biến thể.');\n}","map":{"version":3,"names":["Transaction","Buffer","createSecp256r1Instruction","convertDERtoRaw","prepareSignature","signature","length","console","log","rawSignature","Uint8Array","from","error","testSecp256r1","connection","message","publicKey","wallet","toString","publicKeyLength","signatureLength","messageBytes","messageLength","preparedSignature","instruction","transaction","add","feePayer","blockhash","getLatestBlockhash","recentBlockhash","signedTx","signTransaction","txSignature","sendRawTransaction","serialize","confirmTransaction","generatePublicKeyVariants","variants","push","fullReversedPubKey","reverse","partialReversedPubKey","alloc","i","prefixChangedPubKey","testMultiplePublicKeys","publicKeyVariants","variant","success"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/frontend_test/src/utils/testUtils.ts"],"sourcesContent":["import { Connection, PublicKey, Transaction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport { createSecp256r1Instruction } from './transactionUtils';\nimport { convertDERtoRaw } from './webauthnUtils';\n\n// Định nghĩa kiểu wallet tương thích\ninterface WalletAdapter {\n  publicKey: PublicKey;\n  signTransaction: (transaction: Transaction) => Promise<Transaction>;\n}\n\n/**\n * Kiểm tra và chuyển đổi signature nếu cần\n * @param signature Signature cần kiểm tra\n * @returns Signature đã xử lý\n */\nfunction prepareSignature(signature: Buffer): Buffer {\n  // Kiểm tra xem signature có phải định dạng DER không (thường bắt đầu bằng 0x30)\n  if (signature.length > 70 && signature[0] === 0x30) {\n    console.log('Phát hiện signature DER format, đang chuyển đổi sang raw format...');\n    try {\n      const rawSignature = convertDERtoRaw(new Uint8Array(signature));\n      return Buffer.from(rawSignature);\n    } catch (error) {\n      console.error('Lỗi khi chuyển đổi signature DER:', error);\n      return signature;\n    }\n  }\n  \n  // Trả về signature nguyên bản nếu đã là raw format\n  return signature;\n}\n\n/**\n * Kiểm tra instruction secp256r1 độc lập\n * @param connection Kết nối Solana\n * @param message Message gốc cần xác thực\n * @param publicKey Public key đã nén (33 bytes)\n * @param signature Chữ ký raw (64 bytes)\n * @param wallet Wallet để ký giao dịch\n */\nexport async function testSecp256r1(\n  connection: Connection,\n  message: Buffer,\n  publicKey: Buffer,\n  signature: Buffer,\n  wallet: WalletAdapter\n): Promise<boolean> {\n  try {\n    console.log('Kiểm tra secp256r1 với:', {\n      publicKey: publicKey.toString('hex'),\n      publicKeyLength: publicKey.length,\n      signature: signature.toString('hex'),\n      signatureLength: signature.length,\n      message: message.toString(),\n      messageBytes: message.toString('hex'),\n      messageLength: message.length\n    });\n\n    // Chuẩn bị signature\n    const preparedSignature = prepareSignature(signature);\n    if (preparedSignature !== signature) {\n      console.log('Signature đã được chuyển đổi, độ dài mới:', preparedSignature.length);\n      console.log('Signature sau khi chuyển đổi:', preparedSignature.toString('hex'));\n    }\n\n    // Tạo instruction secp256r1\n    const instruction = createSecp256r1Instruction(\n      message,\n      publicKey,\n      preparedSignature\n    );\n\n    // Tạo và gửi transaction\n    const transaction = new Transaction().add(instruction);\n    transaction.feePayer = wallet.publicKey;\n    const { blockhash } = await connection.getLatestBlockhash();\n    transaction.recentBlockhash = blockhash;\n\n    const signedTx = await wallet.signTransaction(transaction);\n    const txSignature = await connection.sendRawTransaction(signedTx.serialize());\n\n    console.log('Giao dịch đã được gửi với signature:', txSignature);\n    await connection.confirmTransaction(txSignature, 'confirmed');\n    console.log('Giao dịch đã được xác nhận');\n    \n    return true;\n  } catch (error) {\n    console.error('Lỗi khi kiểm tra secp256r1:', error);\n    return false;\n  }\n}\n\n/**\n * Tạo các biến thể khác nhau của public key để kiểm tra\n * @param publicKey Public key gốc\n */\nexport function generatePublicKeyVariants(publicKey: Buffer): Buffer[] {\n  const variants: Buffer[] = [];\n  \n  // Biến thể 1: Giữ nguyên public key gốc\n  variants.push(Buffer.from(publicKey));\n  console.log('Biến thể 1 (Gốc):', publicKey.toString('hex'));\n  \n  // Biến thể 2: Đảo ngược tất cả các byte\n  const fullReversedPubKey = Buffer.from(publicKey);\n  fullReversedPubKey.reverse();\n  variants.push(fullReversedPubKey);\n  console.log('Biến thể 2 (Đảo ngược tất cả):', fullReversedPubKey.toString('hex'));\n  \n  // Biến thể 3: Đảo ngược tất cả các byte trừ byte đầu tiên\n  const partialReversedPubKey = Buffer.alloc(33);\n  partialReversedPubKey[0] = publicKey[0]; // Giữ nguyên byte đầu tiên\n  for (let i = 1; i < 33; i++) {\n    partialReversedPubKey[i] = publicKey[34 - i]; // Đảo ngược các byte còn lại\n  }\n  variants.push(partialReversedPubKey);\n  console.log('Biến thể 3 (Đảo ngược trừ byte đầu):', partialReversedPubKey.toString('hex'));\n  \n  // Biến thể 4: Chuyển đổi byte đầu tiên giữa 0x02 và 0x03 (thay đổi dấu của y)\n  const prefixChangedPubKey = Buffer.from(publicKey);\n  if (prefixChangedPubKey[0] === 0x02) {\n    prefixChangedPubKey[0] = 0x03;\n  } else if (prefixChangedPubKey[0] === 0x03) {\n    prefixChangedPubKey[0] = 0x02;\n  }\n  variants.push(prefixChangedPubKey);\n  console.log('Biến thể 4 (Đổi dấu y):', prefixChangedPubKey.toString('hex'));\n\n  return variants;\n}\n\n/**\n * Kiểm tra với nhiều biến thể của public key\n */\nexport async function testMultiplePublicKeys(\n  connection: Connection,\n  message: Buffer,\n  signature: Buffer,\n  wallet: WalletAdapter,\n  publicKeyVariants: Buffer[]\n): Promise<void> {\n  console.log(`Bắt đầu kiểm tra với ${publicKeyVariants.length} biến thể của public key...`);\n  \n  for (let i = 0; i < publicKeyVariants.length; i++) {\n    const variant = publicKeyVariants[i];\n    console.log(`Kiểm tra biến thể #${i + 1}:`, variant.toString('hex'));\n    \n    const success = await testSecp256r1(\n      connection,\n      message,\n      variant,\n      signature,\n      wallet\n    );\n    \n    if (success) {\n      console.log(`Biến thể #${i + 1} thành công!`);\n    } else {\n      console.log(`Biến thể #${i + 1} thất bại.`);\n    }\n  }\n  \n  console.log('Đã hoàn tất việc kiểm tra các biến thể.');\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}