{"ast":null,"code":"var _jsxFileName = \"/Users/tai/Documents/MoonWallet/moonwallet/acacac/src/App.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport { Connection, PublicKey, Keypair, Transaction, SystemProgram, TransactionInstruction, LAMPORTS_PER_SOL, sendAndConfirmTransaction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport './App.css';\nimport { createWebAuthnCredential, getWebAuthnAssertionForLogin, calculateMultisigAddress } from './utils/webauthnUtils';\nimport { processCredentialIdForPDA, getMultisigPDA, getGuardianPDA } from './utils/credentialUtils';\nimport { saveInvitation, getInvitation, getGuardianData, updateGuardianStatus, getPendingInvites, deleteGuardianData } from './firebase/guardianService';\nimport { getWalletByCredentialId } from './firebase/webAuthnService';\nimport TransferForm from './components/TransferForm';\n\n// Lấy các biến môi trường hoặc sử dụng giá trị mặc định\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst RPC_ENDPOINT = process.env.REACT_APP_RPC_ENDPOINT || 'http://127.0.0.1:8899'; // Localhost validator\nconst PROGRAM_ID_STRING = process.env.REACT_APP_PROGRAM_ID || 'DeN1rBfabZezHPvrq9q7BbzUbZkrjnHE1kQDrPK8kWQ3'; // Program ID mới triển khai\n\n// Địa chỉ Program ID từ smart contract\nexport const PROGRAM_ID = new PublicKey(PROGRAM_ID_STRING);\n\n// Log biến môi trường để debug\nconsole.log(\"Biến môi trường RPC_ENDPOINT:\", process.env.REACT_APP_RPC_ENDPOINT);\nconsole.log(\"Biến môi trường PROGRAM_ID:\", process.env.REACT_APP_PROGRAM_ID);\nconsole.log(\"Biến môi trường FEE_PAYER_SECRET_KEY tồn tại:\", !!process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\nif (process.env.REACT_APP_FEE_PAYER_SECRET_KEY) {\n  console.log(\"Độ dài FEE_PAYER_SECRET_KEY:\", process.env.REACT_APP_FEE_PAYER_SECRET_KEY.split(',').length);\n}\n\n// Tùy chọn kết nối\nconst connectionOptions = {\n  commitment: 'confirmed',\n  confirmTransactionInitialTimeout: 60000,\n  disableRetryOnRateLimit: false,\n  fetch: fetch\n};\n\n// Connection với validator\nconst connection = new Connection(RPC_ENDPOINT, connectionOptions);\n\n// Schema cho các struct của chương trình\nclass ActionParams {\n  constructor(props) {\n    this.amount = void 0;\n    this.destination = void 0;\n    this.tokenMint = void 0;\n    this.amount = props.amount;\n    this.destination = props.destination;\n    this.tokenMint = props.tokenMint;\n  }\n}\n\n// Ví tạm thời đã được tạo và nhận SOL trước đó\nconst TEMP_WALLET_PUBKEY = '9Q8iZnAvCQP3uaDTuYbrvYSRDWB7Kk19u4TS1MDRSStJ';\n\n// Hàm chuyển đổi Buffer sang Uint8Array\nfunction bufferToUint8Array(buffer) {\n  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n}\n\n// Hàm concat cho Uint8Array\nfunction concatUint8Arrays(...arrays) {\n  // Tính tổng độ dài\n  const totalLength = arrays.reduce((acc, arr) => acc + arr.length, 0);\n\n  // Tạo mảng mới với tổng độ dài\n  const result = new Uint8Array(totalLength);\n\n  // Copy dữ liệu vào mảng mới\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\n\n// Hàm chuyển đổi từ BigInt (u64) sang bytes theo thứ tự little-endian\nconst bigIntToLeBytes = (value, bytesLength = 8) => {\n  const result = new Uint8Array(bytesLength);\n  for (let i = 0; i < bytesLength; i++) {\n    result[i] = Number(value >> BigInt(8 * i) & BigInt(0xff));\n  }\n  return result;\n};\n\n// Helper function để tính toán MultisigPDA một cách nhất quán\nconst calculateMultisigPDA = async (programId, credentialId) => {\n  // Sử dụng hàm processCredentialIdForPDA từ helpers.ts để xử lý credential ID\n  // đảm bảo nhất quán với smart contract\n  const seedBuffer = processCredentialIdForPDA(credentialId);\n  console.log(\"Xử lý credential ID:\", credentialId);\n  console.log(\"Seed buffer để tính PDA:\", Buffer.from(seedBuffer).toString('hex'));\n  return PublicKey.findProgramAddressSync([Buffer.from(\"multisig\"), seedBuffer], programId);\n};\n\n// Hàm nén khóa công khai từ dạng uncompressed (65 bytes) sang compressed (33 bytes)\nconst compressPublicKey = uncompressedKey => {\n  // Đảm bảo khóa bắt đầu với byte 0x04 (không nén)\n  if (uncompressedKey[0] !== 0x04 || uncompressedKey.length !== 65) {\n    console.warn('Khóa không đúng định dạng không nén ECDSA, tạo khóa ngẫu nhiên');\n    // Tạo khóa random nếu không đúng định dạng\n    const randomKey = Buffer.alloc(33);\n    randomKey[0] = 0x02; // compressed, y is even\n\n    // Tạo dữ liệu ngẫu nhiên cho 32 bytes còn lại\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n\n    // Sao chép vào buffer\n    for (let i = 0; i < 32; i++) {\n      randomKey[i + 1] = randomBytes[i];\n    }\n    return randomKey;\n  }\n\n  // Lấy tọa độ x và y\n  const x = new Uint8Array(uncompressedKey.slice(1, 33));\n  const y = new Uint8Array(uncompressedKey.slice(33, 65));\n\n  // Tính prefix: 0x02 nếu y chẵn, 0x03 nếu y lẻ\n  const prefix = (y[31] & 1) === 0 ? 0x02 : 0x03;\n\n  // Tạo khóa nén: prefix (1 byte) + x (32 bytes)\n  const compressedKey = Buffer.alloc(33);\n  compressedKey[0] = prefix;\n\n  // Copy x vào compressedKey từ vị trí 1\n  for (let i = 0; i < 32; i++) {\n    compressedKey[i + 1] = x[i];\n  }\n  return compressedKey;\n};\n\n// Hàm hash recovery phrase tại frontend\nconst hashRecoveryPhrase = async phrase => {\n  // Chuyển recovery phrase thành bytes\n  const phraseBytes = new TextEncoder().encode(phrase);\n\n  // Tạo buffer 32 bytes để lưu dữ liệu\n  const inputBytes = new Uint8Array(32);\n\n  // Sao chép dữ liệu từ phrase, đảm bảo không vượt quá 32 bytes\n  inputBytes.set(phraseBytes.slice(0, Math.min(phraseBytes.length, 32)));\n\n  // Hash bằng SHA-256\n  const hashBuffer = await crypto.subtle.digest('SHA-256', inputBytes);\n\n  // Chuyển kết quả thành Uint8Array\n  return new Uint8Array(hashBuffer);\n};\n\n// Chuyển đổi secret key từ chuỗi trong .env thành mảng số\nconst convertSecretKeyStringToUint8Array = secretKeyString => {\n  if (!secretKeyString) {\n    throw new Error('Fee payer secret key không được định nghĩa trong biến môi trường');\n  }\n\n  // Chuyển đổi chuỗi \"1,2,3,...\" thành mảng số\n  const numbers = secretKeyString.split(',').map(s => parseInt(s.trim(), 10));\n\n  // Kiểm tra kích thước hợp lệ (64 bytes cho ed25519)\n  if (numbers.length !== 64 && numbers.length !== 65) {\n    throw new Error(`Secret key phải có 64 hoặc 65 bytes, nhưng có ${numbers.length} bytes`);\n  }\n\n  // Nếu có 65 bytes, bỏ qua byte cuối cùng (thường là checksum)\n  const bytes = numbers.length === 65 ? numbers.slice(0, 64) : numbers;\n  return new Uint8Array(bytes);\n};\n\n// Add this function near the top with other utility functions\nconst hashCredentialId = async credentialId => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(credentialId);\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  return new Uint8Array(hashBuffer);\n};\nfunction App() {\n  _s();\n  const [walletKeypair, setWalletKeypair] = useState(null);\n  const [walletBalance, setWalletBalance] = useState(0);\n  const [multisigAddress, setMultisigAddress] = useState(null);\n  const [threshold, setThreshold] = useState(1);\n  const [guardianName, setGuardianName] = useState('Owner');\n  const [recoveryPhrase, setRecoveryPhrase] = useState('');\n  const [transactionStatus, setTransactionStatus] = useState('');\n  const [guardianPDA, setGuardianPDA] = useState(null);\n  const [isLoadingBalance, setIsLoadingBalance] = useState(false);\n  const [credentialId, setCredentialId] = useState('');\n  const [webauthnPubkey, setWebauthnPubkey] = useState('');\n  const [walletName, setWalletName] = useState('My Moon Wallet');\n  const [isUsingTempWallet, setIsUsingTempWallet] = useState(false);\n  // Thêm state cho new guardian\n  const [newGuardianName, setNewGuardianName] = useState('');\n  const [newRecoveryPhrase, setNewRecoveryPhrase] = useState('');\n  const [existingGuardians, setExistingGuardians] = useState([]); // Lưu các guardian ID đã tồn tại\n  const [showAddGuardianForm, setShowAddGuardianForm] = useState(false);\n  // Thêm state cho fee payer của dự án\n  const [projectFeePayerKeypair, setProjectFeePayerKeypair] = useState(null);\n  const [usingProjectFeePayer, setUsingProjectFeePayer] = useState(true);\n  const [feePayerBalance, setFeePayerBalance] = useState(0);\n  const [isLoadingFeePayerBalance, setIsLoadingFeePayerBalance] = useState(false);\n  // Thêm state cho số dư PDA\n  const [pdaBalance, setPdaBalance] = useState(0);\n  const [isLoadingPdaBalance, setIsLoadingPdaBalance] = useState(false);\n  // Thêm state cho việc chọn guardian ID\n  const [selectedGuardianId, setSelectedGuardianId] = useState(1);\n  // State cho form nạp tiền\n  const [depositAmount, setDepositAmount] = useState(0.1);\n  // State cho form rút tiền\n  const [withdrawAmount, setWithdrawAmount] = useState(0.05);\n  const [recipientAddress, setRecipientAddress] = useState('');\n  // State cho form đăng nhập ví\n  const [loginCredentialId, setLoginCredentialId] = useState('');\n  const [isLoggingIn, setIsLoggingIn] = useState(false);\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [showLoginForm, setShowLoginForm] = useState(false);\n\n  // Thêm state cho chức năng tạo invitation\n  const [inviteLink, setInviteLink] = useState('');\n  const [inviteCode, setInviteCode] = useState('');\n  const [showQRCode, setShowQRCode] = useState(false);\n  const [showInviteInput, setShowInviteInput] = useState(false);\n  const [pendingInvites, setPendingInvites] = useState([]);\n\n  // Thêm state cho màn hình Transfer\n  const [showTransferScreen, setShowTransferScreen] = useState(false);\n  const [isProcessingTransfer, setIsProcessingTransfer] = useState(false);\n\n  // Tạo keypair mới khi component được mount\n  useEffect(() => {\n    // Tạo keypair ngẫu nhiên mới cho user\n    const newKeypair = Keypair.generate();\n    setWalletKeypair(newKeypair);\n\n    // Tạo keypair cố định cho dự án để trả phí\n    // Trong môi trường thực tế, bạn có thể lấy keypair này từ server hoặc một nguồn an toàn\n    const projectPayerPrivateKey = convertSecretKeyStringToUint8Array(process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\n\n    // Sử dụng keypair cố định cho fee payer\n    const feePayerKeypair = Keypair.fromSecretKey(projectPayerPrivateKey);\n    setProjectFeePayerKeypair(feePayerKeypair);\n\n    // Load balance cho fee payer\n    loadFeePayerBalance(feePayerKeypair);\n\n    // Không tính PDA ngay vì chưa có credential ID\n    // findMultisigAddress sẽ được gọi sau khi người dùng tạo WebAuthn credential\n  }, []);\n\n  // Thêm hàm để load balance của fee payer\n  const loadFeePayerBalance = async keypair => {\n    try {\n      setIsLoadingFeePayerBalance(true);\n      const balance = await connection.getBalance(keypair.publicKey);\n      console.log(`Fee payer balance: ${balance / 1000000000} SOL`);\n\n      // Nếu balance quá thấp, có thể gửi thông báo cảnh báo\n      if (balance < 100000000) {\n        // dưới 0.1 SOL\n        console.warn(\"Fee payer balance thấp, cần nạp thêm SOL\");\n      }\n      setFeePayerBalance(balance / 1000000000);\n    } catch (error) {\n      console.error(\"Lỗi khi load balance của fee payer:\", error);\n    } finally {\n      setIsLoadingFeePayerBalance(false);\n    }\n  };\n\n  // Sử dụng ví tạm thời đã có SOL\n  const useTempWallet = async () => {\n    try {\n      setTransactionStatus('Đang tải ví tạm thời với SOL...');\n\n      // Sử dụng cùng secret key của fee payer\n      const tempWalletPrivateKey = convertSecretKeyStringToUint8Array(process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\n\n      // Tạo Keypair từ private key\n      const keypair = Keypair.fromSecretKey(tempWalletPrivateKey);\n      setWalletKeypair(keypair);\n      setIsUsingTempWallet(true);\n\n      // Tính PDA mới dựa trên keypair mới\n      findMultisigAddress();\n\n      // Tải balance của ví tạm thời\n      await loadBalance(keypair);\n      setTransactionStatus(`Đã chuyển sang ví tạm thời: ${keypair.publicKey.toString()}. Ví này đã có sẵn SOL để giao dịch.`);\n    } catch (error) {\n      console.error('Lỗi khi tải ví tạm thời:', error);\n      setTransactionStatus(`Lỗi khi tải ví tạm thời: ${error.message}`);\n    }\n  };\n\n  // Tải balance với xử lý lỗi tốt hơn\n  const loadBalance = async keypair => {\n    const publicKey = (keypair === null || keypair === void 0 ? void 0 : keypair.publicKey) || (walletKeypair === null || walletKeypair === void 0 ? void 0 : walletKeypair.publicKey);\n    if (!publicKey) return;\n    setIsLoadingBalance(true);\n    try {\n      console.log(\"Đang tải balance cho địa chỉ:\", publicKey.toString());\n      const balance = await connection.getBalance(publicKey);\n      console.log(\"Balance đã tải thành công:\", balance / 1000000000);\n      setWalletBalance(balance / 1000000000); // Chuyển từ lamports sang SOL\n    } catch (error) {\n      console.error('Lỗi khi tải balance:', error);\n      // Không hiển thị lỗi cho người dùng, chỉ log ra console\n    } finally {\n      setIsLoadingBalance(false);\n    }\n  };\n\n  // Tạo ví với WebAuthn\n  const createWalletWithWebAuthn = async () => {\n    try {\n      // Kiểm tra xem người dùng đã nhập recovery phrase chưa\n      if (!recoveryPhrase || recoveryPhrase.trim().length < 8) {\n        setTransactionStatus('Vui lòng nhập recovery phrase (ít nhất 8 ký tự) trước khi tạo ví');\n        return;\n      }\n\n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n      setTransactionStatus('Đang tạo ví Moon Wallet...\\n\\nBước 1: Đang tạo khóa WebAuthn...');\n\n      // 1. Tạo khóa WebAuthn\n      const walletAddress = projectFeePayerKeypair.publicKey.toString(); // Sử dụng địa chỉ của fee payer\n      const result = await createWebAuthnCredential(walletAddress, walletName);\n\n      // Chuyển đổi rawId thành base64 để lưu trữ và sử dụng\n      const rawIdBase64 = Buffer.from(result.rawId).toString('base64');\n\n      // Lưu thông tin WebAuthn\n      setCredentialId(rawIdBase64); // Lưu base64 thay vì hex\n      setWebauthnPubkey(result.publicKey);\n      setTransactionStatus(prev => prev + `\\nĐã tạo khóa WebAuthn thành công!\\nCredential ID (base64): ${rawIdBase64.slice(0, 10)}...\\nPublic Key: ${result.publicKey.slice(0, 10)}...`);\n\n      // 2. Tính PDA cho Multisig\n      const multisigPDA = getMultisigPDA(rawIdBase64);\n      console.log(\"Multisig PDA:\", multisigPDA.toString());\n      setMultisigAddress(multisigPDA);\n      setTransactionStatus(prev => prev + `\\n\\nBước 2: Đang khởi tạo ví multisig tại địa chỉ: ${multisigPDA.toString()}...`);\n\n      // Kiểm tra xem multisig account đã tồn tại chưa\n      const existingAccount = await connection.getAccountInfo(multisigPDA);\n      if (existingAccount) {\n        setTransactionStatus(prev => prev + `\\n\\nLỖI: Ví multisig với credential ID này đã tồn tại. Điều này gần như không thể xảy ra vì credential ID luôn duy nhất.`);\n        return;\n      }\n\n      // 3. Tính PDA address cho guardian\n      // Tạo ID dạng u64 cho guardian\n      const guardianId = BigInt(1); // Owner có ID = 1\n\n      // Chuyển đổi guardianId sang bytes (little-endian)\n      const guardianIdBytes = bigIntToLeBytes(guardianId);\n      const [guardianPDAAddress] = PublicKey.findProgramAddressSync([Buffer.from(\"guardian\").subarray(0), multisigPDA.toBuffer(), guardianIdBytes], PROGRAM_ID);\n      setGuardianPDA(guardianPDAAddress);\n\n      // 4. Tạo transaction tích hợp để khởi tạo multisig và thêm guardian owner\n      const transaction = new Transaction();\n\n      // 4.1 Khởi tạo Multisig\n      // Đây là discriminator cho initialize_multisig (sử dụng giá trị chính xác từ Anchor IDL)\n      const initMultisigDiscriminator = new Uint8Array([220, 130, 117, 21, 27, 227, 78, 213]);\n      const thresholdBytes = new Uint8Array([threshold]);\n\n      // LƯU Ý QUAN TRỌNG: credential_id trong smart contract sử dụng as_bytes() trực tiếp, \n      // nên chúng ta phải gửi chính xác chuỗi rawIdBase64 như một chuỗi UTF-8\n      // không phải decode nó sang dạng binary\n      const credentialIdString = rawIdBase64;\n      const credentialIdBuffer = Buffer.from(credentialIdString);\n      console.log(\"Credential ID gửi đi (chuỗi gốc):\", credentialIdString);\n      const credentialIdLenBuffer = Buffer.alloc(4);\n      credentialIdLenBuffer.writeUInt32LE(credentialIdBuffer.length, 0);\n      const credentialIdLenBytes = bufferToUint8Array(credentialIdLenBuffer);\n      const credentialIdDataBytes = bufferToUint8Array(credentialIdBuffer);\n\n      // Tạo dữ liệu instruction theo đúng cấu trúc contract yêu cầu\n      const initData = concatUint8Arrays(initMultisigDiscriminator, thresholdBytes, credentialIdLenBytes, credentialIdDataBytes);\n\n      // Thêm instruction khởi tạo multisig vào transaction\n      transaction.add(new TransactionInstruction({\n        keys: [{\n          pubkey: multisigPDA,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: projectFeePayerKeypair.publicKey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: SystemProgram.programId,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: PROGRAM_ID,\n        data: Buffer.from(initData)\n      }));\n\n      // Sign và gửi transaction\n      transaction.feePayer = projectFeePayerKeypair.publicKey;\n      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n\n      // Thông báo cho người dùng\n      setTransactionStatus(prev => prev + '\\nĐang gửi transaction để khởi tạo ví và thêm guardian owner...');\n\n      // Log dữ liệu transaction để debug\n      console.log(\"Transaction data:\", {\n        instructions: transaction.instructions.map((ix, index) => ({\n          programId: ix.programId.toString(),\n          keys: ix.keys.map(k => ({\n            pubkey: k.pubkey.toString(),\n            isSigner: k.isSigner,\n            isWritable: k.isWritable\n          })),\n          data: index === 1 ? {\n            discriminator: Array.from(initMultisigDiscriminator),\n            threshold: threshold,\n            credentialIdLength: credentialIdBuffer.length,\n            credentialId: Array.from(credentialIdBuffer),\n            isOwner: true,\n            hasWebauthn: true,\n            webauthnPubkeyLength: result.publicKey.length\n          } : \"initMultisig\"\n        }))\n      });\n      const signature = await connection.sendTransaction(transaction, [projectFeePayerKeypair]);\n      await connection.confirmTransaction(signature);\n      setTransactionStatus(prev => prev + `\\nVí multisig đã được khởi tạo thành công! Signature: ${signature}`);\n\n      // 5. Thêm guardian đầu tiên (owner)\n      setTransactionStatus(prev => prev + '\\n\\nBước 3: Đang thêm guardian owner đầu tiên...');\n      try {\n        // Tính PDA cho guardian\n        const guardianId = BigInt(1); // Owner có ID = 1\n        const guardianIdBytes = bigIntToLeBytes(guardianId);\n\n        // 5.1 Tính PDA cho multisig với credential_id\n        const guardianMultisigPDA = multisigPDA;\n        console.log(\"Sử dụng PDA cho guardian với multisig PDA:\", guardianMultisigPDA.toString());\n\n        // 5.2 Tính PDA cho guardian\n        const guardianPDA = getGuardianPDA(guardianMultisigPDA, 1); // Owner có ID = 1\n\n        setGuardianPDA(guardianPDA);\n\n        // Hash recovery phrase tại frontend\n        console.log(\"Recovery phrase gốc:\", recoveryPhrase);\n        const hashedRecoveryBytes = await hashRecoveryPhrase(recoveryPhrase);\n        console.log(\"Recovery phrase sau khi hash tại frontend:\", Buffer.from(hashedRecoveryBytes).toString('hex'));\n\n        // Tạo discriminator cho add_guardian\n        const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n\n        // Chuyển guardian ID thành bytes\n        const guardianIdBigIntBytes = bigIntToLeBytes(guardianId);\n\n        // Chuẩn bị tên guardian\n        const guardianNameBuffer = Buffer.from(guardianName || 'Owner');\n        const guardianNameLenBuffer = Buffer.alloc(4);\n        guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n\n        // Chuẩn bị recovery hash - sử dụng giá trị đã hash\n        const recoveryHashIntermediateBytes = hashedRecoveryBytes;\n\n        // Chuẩn bị các tham số khác\n        const isOwnerByte = new Uint8Array([1]); // true = 1\n\n        // WebAuthn pubkey - nén khóa từ 65 bytes (uncompressed) thành 33 bytes (compressed)\n        // Smart contract yêu cầu webauthn_pubkey: Option<[u8; 33]>\n        const uncompressedKeyBuffer = Buffer.from(result.publicKey, 'hex');\n        console.log(\"WebAuthn key (uncompressed, 65 bytes):\", result.publicKey);\n\n        // Nén khóa thành 33 bytes\n        const compressedKeyBuffer = compressPublicKey(uncompressedKeyBuffer);\n        console.log(\"WebAuthn key (compressed, 33 bytes):\", compressedKeyBuffer.toString('hex'));\n\n        // Nối tất cả lại với nhau\n        const addGuardianData = concatUint8Arrays(addGuardianDiscriminator,\n        // guardian_id (u64)\n        bufferToUint8Array(Buffer.from(guardianIdBigIntBytes)),\n        // guardian_name (string)\n        bufferToUint8Array(guardianNameLenBuffer), bufferToUint8Array(guardianNameBuffer),\n        // recovery_hash_intermediate ([u8; 32])\n        recoveryHashIntermediateBytes,\n        // is_owner (bool)\n        isOwnerByte,\n        // webauthn_pubkey (Option<[u8; 33]>)\n        new Uint8Array([1]),\n        // Some variant\n        bufferToUint8Array(compressedKeyBuffer) // Sử dụng khóa đã được nén\n        );\n\n        // Tạo transaction add guardian\n        const addGuardianTransaction = new Transaction();\n        addGuardianTransaction.add(new TransactionInstruction({\n          keys: [{\n            pubkey: multisigPDA,\n            isSigner: false,\n            isWritable: true\n          }, {\n            pubkey: guardianPDA,\n            isSigner: false,\n            isWritable: true\n          }, {\n            pubkey: projectFeePayerKeypair.publicKey,\n            isSigner: false,\n            isWritable: false\n          }, {\n            pubkey: projectFeePayerKeypair.publicKey,\n            isSigner: true,\n            isWritable: true\n          }, {\n            pubkey: SystemProgram.programId,\n            isSigner: false,\n            isWritable: false\n          }],\n          programId: PROGRAM_ID,\n          data: Buffer.from(addGuardianData)\n        }));\n\n        // Sign và gửi transaction\n        addGuardianTransaction.feePayer = projectFeePayerKeypair.publicKey;\n        addGuardianTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n        const addGuardianSignature = await connection.sendTransaction(addGuardianTransaction, [projectFeePayerKeypair]);\n        await connection.confirmTransaction(addGuardianSignature);\n        setTransactionStatus(prev => prev + `\\nGuardian owner đã được thêm thành công! Signature: ${addGuardianSignature}`);\n      } catch (error) {\n        console.error(\"Lỗi khi thêm guardian owner:\", error);\n        setTransactionStatus(prev => prev + `\\nLỗi khi thêm guardian owner: ${error.message}`);\n      }\n\n      // 6. Hoàn thành quá trình tạo ví\n      setTransactionStatus(prev => prev + '\\n\\n✅ VÍ MOON WALLET ĐÃ ĐƯỢC TẠO THÀNH CÔNG!\\n' + `Địa chỉ ví Multisig: ${multisigPDA.toString()}\\n` + `Recovery Phrase: ${recoveryPhrase}\\n` + 'Vui lòng lưu lại thông tin này để sử dụng sau này!');\n\n      // Kiểm tra số dư của ví PDA sau khi tạo\n      await loadPdaBalance(multisigPDA);\n    } catch (error) {\n      console.error('Lỗi trong quá trình tạo ví:', error);\n      setTransactionStatus(`Lỗi: ${error.message}`);\n    }\n  };\n\n  // Sửa lại hàm tính PDA cho multisig wallet\n  const findMultisigAddress = async () => {\n    // Sử dụng credential ID (nếu có) hoặc một giá trị tạm thời nếu chưa có\n    if (!credentialId) {\n      // Nếu chưa có credential ID, không thể tính PDA chính xác\n      setMultisigAddress(null);\n      return;\n    }\n    console.log(\"findMultisigAddress - credential ID:\", credentialId);\n\n    // Sử dụng helper function để tính PDA một cách nhất quán\n    const [pda, bump] = await calculateMultisigAddress(PROGRAM_ID, credentialId);\n    console.log(\"findMultisigAddress - PDA:\", pda.toString(), \"bump:\", bump);\n    setMultisigAddress(pda);\n\n    // Load balance cho PDA\n    await loadPdaBalance(pda);\n  };\n\n  // Tải balance với xử lý lỗi tốt hơn\n  const loadPdaBalance = async pdaAddress => {\n    try {\n      setIsLoadingPdaBalance(true);\n      const balance = await connection.getBalance(pdaAddress);\n      console.log(`PDA balance: ${balance / 1000000000} SOL`);\n      setPdaBalance(balance / 1000000000);\n    } catch (error) {\n      console.error(\"Lỗi khi load balance của PDA:\", error);\n    } finally {\n      setIsLoadingPdaBalance(false);\n    }\n  };\n\n  // Tính PDA address cho guardian\n  const findGuardianAddress = async (guardianId = 1) => {\n    if (!multisigAddress) return null;\n    try {\n      // Chuyển đổi guardianId sang bytes (little-endian)\n      const guardianIdBigInt = BigInt(guardianId);\n      const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n\n      // Tính PDA cho guardian trực tiếp từ multisigAddress\n      const [guardianPDA] = PublicKey.findProgramAddressSync([Buffer.from(\"guardian\"), multisigAddress.toBuffer(), guardianIdBytes], PROGRAM_ID);\n      console.log(`Tính PDA cho guardian ID ${guardianId} với multisig: ${multisigAddress.toString()}`);\n      console.log(`Guardian PDA: ${guardianPDA.toString()}`);\n      if (guardianId === 1) {\n        setGuardianPDA(guardianPDA); // Chỉ set state cho guardian chính (ID=1)\n      }\n      return guardianPDA;\n    } catch (error) {\n      console.error(`Lỗi khi tính PDA cho guardian ID ${guardianId}:`, error);\n      return null;\n    }\n  };\n\n  // Airdrop SOL cho testing\n  const requestAirdrop = async () => {\n    if (!projectFeePayerKeypair) {\n      setTransactionStatus('Không tìm thấy fee payer của dự án.');\n      return;\n    }\n    try {\n      setTransactionStatus('Đang yêu cầu airdrop cho fee payer của dự án...');\n      const signature = await connection.requestAirdrop(projectFeePayerKeypair.publicKey, 2000000000 // 2 SOL\n      );\n      await connection.confirmTransaction(signature);\n      // Tải lại số dư của fee payer\n      await loadFeePayerBalance(projectFeePayerKeypair);\n      setTransactionStatus('Airdrop thành công! 2 SOL đã được thêm vào ví fee payer của dự án.');\n    } catch (error) {\n      console.error('Lỗi khi thực hiện airdrop:', error);\n      setTransactionStatus(`Lỗi airdrop: ${error.message}. Đang thử phương thức chuyển tiền trực tiếp...`);\n\n      // Thử phương pháp khác nếu airdrop thất bại\n      fundFromValidator(projectFeePayerKeypair);\n    }\n  };\n\n  // Chuyển tiền từ validator wallet sang ví người dùng \n  const fundFromValidator = async keypair => {\n    try {\n      setTransactionStatus('Đang chuyển tiền từ validator vào fee payer...');\n\n      // Tạo kết nối với validator wallet (địa chỉ mặc định của validator)\n      const validatorKey = new PublicKey('E6mJJmCvg4PDhanmaBxxeyTczza9vKpMgirRUD6Qz5kv');\n\n      // Tạo transaction chuyển tiền\n      const transaction = new Transaction().add(SystemProgram.transfer({\n        fromPubkey: validatorKey,\n        toPubkey: keypair.publicKey,\n        lamports: 2000000000 // 2 SOL\n      }));\n\n      // Lấy các thông tin cần thiết cho transaction\n      transaction.feePayer = validatorKey;\n      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n\n      // Không thể ký transaction vì không có private key của validator\n      // Thay vào đó, sử dụng phương thức sendTransactionWithRetry không cần chữ ký\n      const signature = await connection.sendTransaction(transaction, [] // Không cần signers khi gửi đến validator local\n      );\n      await connection.confirmTransaction(signature);\n\n      // Tải lại số dư\n      if (keypair === projectFeePayerKeypair) {\n        await loadFeePayerBalance(keypair);\n        setTransactionStatus('Chuyển tiền thành công! 2 SOL đã được thêm vào ví fee payer của dự án.');\n      } else {\n        await loadBalance(keypair);\n        setTransactionStatus('Chuyển tiền thành công! 2 SOL đã được thêm vào ví.');\n      }\n    } catch (error) {\n      console.error('Lỗi khi chuyển tiền từ validator:', error);\n      setTransactionStatus(`Lỗi khi chuyển tiền: ${error.message}. Hãy thử khởi động lại validator.`);\n    }\n  };\n\n  // Xem thông tin wallet\n  const getWalletInfo = async () => {\n    if (!multisigAddress) return;\n    try {\n      setTransactionStatus('Đang truy vấn thông tin ví...');\n\n      // Load balance trước\n      await loadPdaBalance(multisigAddress);\n      const multisigAccount = await connection.getAccountInfo(multisigAddress);\n      if (!multisigAccount) {\n        setTransactionStatus('Ví chưa được khởi tạo');\n        return;\n      }\n\n      // Bỏ qua 8 byte discriminator\n      const data = multisigAccount.data.slice(8);\n\n      // Parse dữ liệu dựa trên struct MultiSigWallet mới\n      // MultiSigWallet: threshold, guardian_count, recovery_nonce, bump, transaction_nonce, last_transaction_timestamp\n      const threshold = data[0];\n      const guardian_count = data[1];\n      const recovery_nonce = new DataView(data.buffer, data.byteOffset + 2, 8).getBigUint64(0, true);\n      const bump = data[10];\n      const transaction_nonce = new DataView(data.buffer, data.byteOffset + 11, 8).getBigUint64(0, true);\n      const last_transaction_timestamp = new DataView(data.buffer, data.byteOffset + 19, 8).getBigInt64(0, true);\n\n      // Hiển thị thông tin\n      setTransactionStatus(`Thông tin ví:\\n` + `- Threshold: ${threshold}\\n` + `- Guardian Count: ${guardian_count}\\n` + `- Recovery Nonce: ${recovery_nonce}\\n` + `- Bump: ${bump}\\n` + `- Transaction Nonce: ${transaction_nonce}\\n` + `- Last Transaction Timestamp: ${last_transaction_timestamp}`);\n    } catch (error) {\n      console.error('Lỗi khi truy vấn thông tin ví:', error);\n      setTransactionStatus(`Lỗi: ${error.message}`);\n    }\n  };\n\n  // Xem thông tin guardian\n  const getGuardianInfo = async () => {\n    if (!multisigAddress) {\n      setTransactionStatus('Vui lòng tạo ví trước khi xem thông tin guardian');\n      return;\n    }\n    try {\n      setTransactionStatus(`Đang truy vấn thông tin guardian ID=${selectedGuardianId}...`);\n\n      // Tính guardian PDA dựa trên ID được chọn\n      const guardianPDA = await findGuardianAddress(selectedGuardianId);\n      if (!guardianPDA) {\n        setTransactionStatus('Không thể tìm thấy địa chỉ Guardian');\n        return;\n      }\n      console.log(`Đang truy vấn thông tin guardian ID=${selectedGuardianId} với PDA: ${guardianPDA.toString()}`);\n      const guardianAccount = await connection.getAccountInfo(guardianPDA);\n      if (!guardianAccount) {\n        console.log(`Không tìm thấy thông tin account tại địa chỉ: ${guardianPDA.toString()}`);\n        setTransactionStatus(`Guardian với ID=${selectedGuardianId} chưa được khởi tạo hoặc không tồn tại`);\n        return;\n      }\n      console.log(`Đã tìm thấy account tại địa chỉ: ${guardianPDA.toString()}`);\n      console.log(`Data size: ${guardianAccount.data.length} bytes`);\n      console.log(`Owner: ${guardianAccount.owner.toString()}`);\n\n      // Kiểm tra xem account có thuộc về program của chúng ta không\n      if (!guardianAccount.owner.equals(PROGRAM_ID)) {\n        console.error(`Account không thuộc về program của chúng ta. Owner: ${guardianAccount.owner.toString()}`);\n        setTransactionStatus(`Guardian với ID=${selectedGuardianId} không thuộc về program của chúng ta`);\n        return;\n      }\n\n      // Bỏ qua 8 byte discriminator\n      const data = guardianAccount.data.slice(8);\n      console.log(`Data sau khi bỏ qua discriminator: ${data.length} bytes`);\n      console.log(`Raw data: ${Buffer.from(data).toString('hex').substring(0, 100)}...`);\n      try {\n        // Parse dữ liệu dựa trên struct Guardian\n        // Guardian struct trên Rust: \n        // pub struct Guardian {\n        //     pub wallet: Pubkey,                  // 32 bytes\n        //     pub guardian_id: u64,                // 8 bytes\n        //     pub name: String,                    // 4 bytes length + n bytes string\n        //     pub is_active: bool,                 // 1 byte\n        //     pub recovery_hash_intermediate: [u8; 32], // 32 bytes\n        //     pub is_owner: bool,                  // 1 byte\n        //     pub webauthn_pubkey: Option<[u8; 33]>, // 1 byte discriminator + 33 bytes if Some\n        //     pub bump: u8,                        // 1 byte\n        // }\n\n        // Đọc wallet address (32 bytes)\n        const walletBytes = data.slice(0, 32);\n        const wallet = new PublicKey(walletBytes);\n        console.log(`Wallet address parsed: ${wallet.toString()}`);\n\n        // Đọc guardian_id (8 bytes - u64)\n        const guardianIdBytes = data.slice(32, 40);\n        let guardianId = BigInt(0);\n        for (let i = 0; i < 8; i++) {\n          guardianId |= BigInt(guardianIdBytes[i]) << BigInt(8 * i);\n        }\n        console.log(`Guardian ID parsed: ${guardianId}`);\n\n        // Đọc name (string dài tối đa 32 bytes)\n        const nameLength = new DataView(data.buffer, data.byteOffset + 40, 4).getUint32(0, true);\n        console.log(`Guardian name length: ${nameLength}`);\n        if (nameLength > 100) {\n          console.error(`Name length quá lớn: ${nameLength}, có thể không đúng cấu trúc dữ liệu`);\n          throw new Error(\"Lỗi parse dữ liệu guardian: Name length không hợp lệ\");\n        }\n\n        // Vị trí bắt đầu của name bytes\n        const nameOffset = 44;\n        const nameBytes = data.slice(nameOffset, nameOffset + nameLength);\n        const name = new TextDecoder().decode(nameBytes);\n        console.log(`Guardian name parsed: ${name}`);\n\n        // Vị trí tiếp theo sau name\n        let currentOffset = nameOffset + nameLength;\n\n        // Đọc is_active (1 byte)\n        const isActive = data[currentOffset] === 1;\n        console.log(`Is active byte: ${data[currentOffset]} (offset: ${currentOffset})`);\n        currentOffset += 1;\n\n        // Đọc recovery_hash (32 bytes)\n        const recoveryHash = data.slice(currentOffset, currentOffset + 32);\n        const recoveryHashHex = Buffer.from(recoveryHash).toString('hex');\n        console.log(`Recovery hash (hex): ${recoveryHashHex} (offset: ${currentOffset})`);\n        currentOffset += 32;\n\n        // Đọc is_owner (1 byte)\n        const isOwner = data[currentOffset] === 1;\n        console.log(`Is owner byte: ${data[currentOffset]} (offset: ${currentOffset})`);\n        currentOffset += 1;\n\n        // Đọc webauthn_pubkey (option, 1 byte discriminator + 33 bytes if Some)\n        const hasWebauthn = data[currentOffset] === 1;\n        console.log(`Has webauthn byte: ${data[currentOffset]} (offset: ${currentOffset})`);\n        currentOffset += 1;\n        let webauthnPubkey = null;\n        if (hasWebauthn) {\n          webauthnPubkey = data.slice(currentOffset, currentOffset + 33);\n          const webauthnHex = Buffer.from(webauthnPubkey).toString('hex');\n          console.log(`WebAuthn pubkey: ${webauthnHex} (offset: ${currentOffset})`);\n          // Log thêm thông tin về format của key\n          console.log(`WebAuthn key format byte: 0x${webauthnHex.slice(0, 2)} (${webauthnPubkey[0]})`);\n          currentOffset += 33;\n        }\n\n        // Đọc bump (1 byte)\n        const bump = data[currentOffset];\n        console.log(`Bump: ${bump} (offset: ${currentOffset})`);\n\n        // Hiển thị thông tin\n        setTransactionStatus(`Thông tin Guardian (ID=${guardianId}):\\n` + `- Loại Guardian: ${isOwner ? 'Owner (Quản trị viên)' : 'Regular (Thành viên)'}\\n` + `- Wallet: ${wallet.toString()}\\n` + `- Guardian ID: ${guardianId}\\n` + `- Name: ${name}\\n` + `- Active: ${isActive ? 'Có' : 'Không'}\\n` + `- Recovery Hash: ${recoveryHashHex.slice(0, 10)}...${recoveryHashHex.slice(-10)}\\n` + (hasWebauthn ? `- WebAuthn Key: ${Buffer.from(webauthnPubkey).toString('hex')}\\n` : '') + (hasWebauthn ? `- WebAuthn Key Format: ${webauthnPubkey[0] === 2 ? '02 (even y)' : webauthnPubkey[0] === 3 ? '03 (odd y)' : webauthnPubkey[0].toString()}\\n` : '') + (hasWebauthn ? `- Công dụng: ${isOwner ? 'Dùng để ký giao dịch và quản lý ví' : 'Dùng để xác thực từ thiết bị này'}\\n` : '') + `- Bump: ${bump}\\n` + `- PDA: ${guardianPDA.toString()}`);\n      } catch (parseError) {\n        console.error(\"Lỗi khi parse dữ liệu guardian:\", parseError);\n\n        // Hiển thị thông tin thô nếu không thể parse\n        setTransactionStatus(`Không thể parse dữ liệu guardian chi tiết. Dữ liệu thô:\\n` + `- PDA: ${guardianPDA.toString()}\\n` + `- Data size: ${guardianAccount.data.length} bytes\\n` + `- Raw data: ${Buffer.from(guardianAccount.data).toString('hex').substring(0, 100)}...\\n` + `- Error: ${parseError}`);\n      }\n    } catch (error) {\n      console.error('Lỗi khi truy vấn thông tin guardian:', error);\n      setTransactionStatus(`Lỗi: ${error.message}`);\n    }\n  };\n\n  // Hàm để lấy danh sách guardian ID hiện có\n  const getExistingGuardianIds = async () => {\n    if (!multisigAddress) return [];\n    try {\n      setTransactionStatus('Đang kiểm tra danh sách Guardian ID...');\n      const guardianIds = [];\n\n      // Kiểm tra guardian từ ID 1 đến 8\n      for (let i = 1; i <= 8; i++) {\n        try {\n          // Tính PDA cho guardian với ID i sử dụng hàm đã sửa\n          const guardianPDA = await findGuardianAddress(i);\n          if (!guardianPDA) {\n            console.log(`Guardian ID ${i}: Không tính được PDA`);\n            continue;\n          }\n\n          // Kiểm tra xem guardian với ID này có tồn tại không\n          console.log(`Đang kiểm tra Guardian ID ${i} tại địa chỉ: ${guardianPDA.toString()}`);\n          const guardianAccount = await connection.getAccountInfo(guardianPDA);\n          if (guardianAccount) {\n            guardianIds.push(i);\n            console.log(`Guardian ID ${i} đã tồn tại - PDA: ${guardianPDA.toString()}`);\n            console.log(`  - Owner: ${guardianAccount.owner.toString()}`);\n            console.log(`  - Data size: ${guardianAccount.data.length} bytes`);\n\n            // Kiểm tra discriminator (8 bytes đầu)\n            const discriminator = guardianAccount.data.slice(0, 8);\n            console.log(`  - Discriminator: ${Buffer.from(discriminator).toString('hex')}`);\n          } else {\n            console.log(`Guardian ID ${i}: Account không tồn tại tại địa chỉ ${guardianPDA.toString()}`);\n          }\n        } catch (error) {\n          console.error(`Lỗi khi kiểm tra guardian ID ${i}:`, error);\n        }\n      }\n      console.log(\"Danh sách guardian ID hiện tại:\", guardianIds);\n\n      // Nếu không có guardian nào, thêm ID 1 vào danh sách để có thể chọn\n      if (guardianIds.length === 0) {\n        guardianIds.push(1);\n        console.log(\"Không tìm thấy guardian nào, thêm ID 1 mặc định vào danh sách\");\n      }\n      setExistingGuardians(guardianIds);\n\n      // Đảm bảo selectedGuardianId nằm trong danh sách các ID hiện có\n      if (!guardianIds.includes(selectedGuardianId)) {\n        console.log(`Selected Guardian ID ${selectedGuardianId} không tồn tại, chuyển sang ID ${guardianIds[0]}`);\n        setSelectedGuardianId(guardianIds[0]);\n      }\n      setTransactionStatus(`Đã tìm thấy ${guardianIds.length} guardian. IDs: ${guardianIds.join(', ')}`);\n      return guardianIds;\n    } catch (error) {\n      console.error(\"Lỗi khi lấy danh sách guardian:\", error);\n      return [];\n    }\n  };\n\n  // Hàm sinh guardian ID mới không bị trùng\n  const generateNewGuardianId = existingIds => {\n    // Nếu không có ID nào tồn tại, bắt đầu từ 2 (vì ID 1 thường là owner)\n    if (existingIds.length === 0) return 2;\n\n    // Tìm ID nhỏ nhất không bị trùng\n    let newId = 1;\n    while (existingIds.includes(newId)) {\n      newId++;\n    }\n    return newId;\n  };\n\n  // Hàm thêm guardian mới với chữ ký WebAuthn riêng\n  const addNewGuardian = async () => {\n    try {\n      // Kiểm tra xem ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi thêm guardian.');\n        return;\n      }\n\n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n\n      // Kiểm tra các trường bắt buộc\n      if (!newGuardianName || !newRecoveryPhrase || newRecoveryPhrase.length < 8) {\n        setTransactionStatus('Vui lòng nhập tên guardian và recovery phrase (ít nhất 8 ký tự).');\n        return;\n      }\n      setTransactionStatus('Đang thêm guardian mới...\\n\\nBước 1: Tạo khóa WebAuthn cho guardian mới...');\n\n      // Lấy danh sách guardian ID hiện tại\n      const existingIds = await getExistingGuardianIds();\n\n      // Sinh guardian ID mới không bị trùng\n      const newGuardianId = generateNewGuardianId(existingIds);\n      console.log(\"=== ADD GUARDIAN === Guardian ID mới được sinh:\", newGuardianId);\n\n      // 1. Tạo khóa WebAuthn cho guardian mới\n      try {\n        // Sử dụng một định danh duy nhất cho khóa mới\n        const guardianIdentifier = `${multisigAddress === null || multisigAddress === void 0 ? void 0 : multisigAddress.toString()}_guardian_${newGuardianId}`;\n        const webAuthnResult = await createWebAuthnCredential(guardianIdentifier, newGuardianName);\n\n        // Log thông tin WebAuthn\n        console.log(\"=== ADD GUARDIAN === WebAuthn credential mới đã được tạo:\");\n        console.log(\"=== ADD GUARDIAN === Credential ID:\", webAuthnResult.credentialId);\n        console.log(\"=== ADD GUARDIAN === Public Key:\", webAuthnResult.publicKey);\n        setTransactionStatus(prev => prev + `\\nĐã tạo khóa WebAuthn thành công!`);\n\n        // 2. Tính PDA cho guardian mới\n        const guardianPDA = await findGuardianAddress(newGuardianId);\n        if (!guardianPDA) {\n          setTransactionStatus('Không thể tính PDA cho guardian mới.');\n          return;\n        }\n        console.log(\"=== ADD GUARDIAN === Guardian PDA mới:\", guardianPDA.toString());\n\n        // Kiểm tra trước xem guardian account đã tồn tại chưa\n        const existingGuardian = await connection.getAccountInfo(guardianPDA);\n        if (existingGuardian) {\n          console.log(\"=== ADD GUARDIAN === Guardian account đã tồn tại!\", existingGuardian);\n          setTransactionStatus(`Guardian với ID=${newGuardianId} đã tồn tại rồi. Hãy chọn ID khác.`);\n          return;\n        }\n\n        // 3. Hash recovery phrase\n        const hashedRecoveryBytes = await hashRecoveryPhrase(newRecoveryPhrase);\n        console.log(\"=== ADD GUARDIAN === Recovery phrase sau khi hash:\", Buffer.from(hashedRecoveryBytes).toString('hex'));\n\n        // 4. Chuyển đổi guardian ID thành bytes (little-endian)\n        const guardianIdBigInt = BigInt(newGuardianId);\n        const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n\n        // 5. Nén khóa WebAuthn từ 65 bytes (uncompressed) thành 33 bytes (compressed)\n        const uncompressedKeyBuffer = Buffer.from(webAuthnResult.publicKey, 'hex');\n        console.log(\"=== ADD GUARDIAN === WebAuthn key (uncompressed, 65 bytes):\", webAuthnResult.publicKey);\n\n        // Nén khóa thành 33 bytes\n        const compressedKeyBuffer = compressPublicKey(uncompressedKeyBuffer);\n        console.log(\"=== ADD GUARDIAN === WebAuthn key (compressed, 33 bytes):\", compressedKeyBuffer.toString('hex'));\n\n        // 6. Tạo discriminator cho add_guardian\n        const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n\n        // 7. Chuẩn bị tên guardian\n        const guardianNameBuffer = Buffer.from(newGuardianName);\n        const guardianNameLenBuffer = Buffer.alloc(4);\n        guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n\n        // 8. Đặt is_owner = false vì đây là guardian member, không phải owner\n        const isOwnerByte = new Uint8Array([0]); // false = 0\n\n        // 9. Cấu hình webauthn_pubkey là Some(compressed_key)\n        const hasWebauthn = new Uint8Array([1]); // Some variant\n\n        // 10. Tạo dữ liệu instruction\n        const addGuardianData = concatUint8Arrays(addGuardianDiscriminator,\n        // guardian_id (u64)\n        bufferToUint8Array(Buffer.from(guardianIdBytes)),\n        // guardian_name (string)\n        bufferToUint8Array(guardianNameLenBuffer), bufferToUint8Array(guardianNameBuffer),\n        // recovery_hash_intermediate ([u8; 32])\n        hashedRecoveryBytes,\n        // is_owner (bool)\n        isOwnerByte,\n        // webauthn_pubkey (Option<[u8; 33]>) - Some variant + compressed key\n        hasWebauthn, bufferToUint8Array(compressedKeyBuffer));\n\n        // Log dữ liệu instruction để debug\n        console.log(\"=== ADD GUARDIAN === Dữ liệu instruction:\", {\n          discriminator: Buffer.from(addGuardianDiscriminator).toString('hex'),\n          guardianId: newGuardianId.toString(),\n          guardianIdBytes: Buffer.from(guardianIdBytes).toString('hex'),\n          nameLength: guardianNameBuffer.length,\n          name: newGuardianName,\n          recoveryHashHex: Buffer.from(hashedRecoveryBytes).toString('hex'),\n          isOwner: false,\n          hasWebauthn: true,\n          webauthnPubkey: compressedKeyBuffer.toString('hex')\n        });\n        setTransactionStatus(prev => prev + `\\n\\nBước 2: Đang thêm guardian vào blockchain...`);\n\n        // 11. Tạo transaction add guardian\n        const addGuardianTransaction = new Transaction();\n        addGuardianTransaction.add(new TransactionInstruction({\n          keys: [{\n            pubkey: multisigAddress,\n            isSigner: false,\n            isWritable: true\n          }, {\n            pubkey: guardianPDA,\n            isSigner: false,\n            isWritable: true\n          }, {\n            pubkey: projectFeePayerKeypair.publicKey,\n            isSigner: false,\n            isWritable: false\n          }, {\n            pubkey: projectFeePayerKeypair.publicKey,\n            isSigner: true,\n            isWritable: true\n          }, {\n            pubkey: SystemProgram.programId,\n            isSigner: false,\n            isWritable: false\n          }],\n          programId: PROGRAM_ID,\n          data: Buffer.from(addGuardianData)\n        }));\n\n        // Sign và gửi transaction với fee payer của dự án\n        addGuardianTransaction.feePayer = projectFeePayerKeypair.publicKey;\n        addGuardianTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n        console.log(\"=== ADD GUARDIAN === Đang gửi transaction...\");\n        const addGuardianSignature = await connection.sendTransaction(addGuardianTransaction, [projectFeePayerKeypair]);\n        console.log(\"=== ADD GUARDIAN === Transaction đã gửi. Signature:\", addGuardianSignature);\n        setTransactionStatus(prev => prev + `\\nĐang xác nhận transaction thêm guardian...`);\n        await connection.confirmTransaction(addGuardianSignature);\n        setTransactionStatus(`Guardian mới đã được thêm thành công với ID: ${newGuardianId}!\\n` + `Chữ ký WebAuthn đã được lưu cho guardian này.\\n` + `Signature: ${addGuardianSignature}`);\n\n        // Kiểm tra xem guardian đã được thêm thành công chưa\n        console.log(\"=== ADD GUARDIAN === Đang kiểm tra guardian vừa thêm...\");\n        await new Promise(resolve => setTimeout(resolve, 2000)); // Đợi 2 giây\n\n        const newGuardianAccount = await connection.getAccountInfo(guardianPDA);\n        if (newGuardianAccount) {\n          console.log(\"=== ADD GUARDIAN === Guardian đã được thêm thành công!\");\n          console.log(`=== ADD GUARDIAN === Data size: ${newGuardianAccount.data.length} bytes`);\n\n          // Kiểm tra discriminator\n          const discriminator = newGuardianAccount.data.slice(0, 8);\n          console.log(`=== ADD GUARDIAN === Discriminator: ${Buffer.from(discriminator).toString('hex')}`);\n        } else {\n          console.log(\"=== ADD GUARDIAN === Guardian không được tìm thấy sau khi thêm!\");\n          setTransactionStatus(prev => prev + '\\n\\nCẢNH BÁO: Guardian có vẻ như chưa được khởi tạo trên blockchain mặc dù transaction đã thành công!');\n        }\n\n        // Cập nhật danh sách guardian\n        await getExistingGuardianIds();\n\n        // Cập nhật số dư của ví PDA\n        await loadPdaBalance(multisigAddress);\n\n        // Reset form\n        setNewGuardianName('');\n        setNewRecoveryPhrase('');\n      } catch (webAuthnError) {\n        console.error(\"=== ADD GUARDIAN === Lỗi khi tạo khóa WebAuthn:\", webAuthnError);\n        setTransactionStatus(`Lỗi khi tạo khóa WebAuthn: ${webAuthnError.message || 'Không xác định'}. Vui lòng thử lại.`);\n        return;\n      }\n    } catch (error) {\n      console.error(\"=== ADD GUARDIAN === Lỗi khi thêm guardian mới:\", error);\n      setTransactionStatus(`Lỗi khi thêm guardian mới: ${error.message}`);\n    }\n  };\n\n  // Hàm để nạp SOL vào ví multisig\n  const depositToMultisig = async () => {\n    try {\n      // Kiểm tra xem ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi nạp tiền.');\n        return;\n      }\n\n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n\n      // Kiểm tra số tiền hợp lệ\n      if (!depositAmount || depositAmount <= 0) {\n        setTransactionStatus('Vui lòng nhập số tiền hợp lệ để nạp.');\n        return;\n      }\n\n      // Kiểm tra số dư của fee payer\n      const feePayerBalance = await connection.getBalance(projectFeePayerKeypair.publicKey);\n      const lamportsToSend = depositAmount * LAMPORTS_PER_SOL;\n      if (feePayerBalance < lamportsToSend + 5000) {\n        // 5000 lamports cho phí giao dịch\n        setTransactionStatus(`Số dư fee payer không đủ. Hiện tại: ${feePayerBalance / LAMPORTS_PER_SOL} SOL`);\n        return;\n      }\n      setTransactionStatus(`Đang nạp ${depositAmount} SOL vào ví...`);\n\n      // Tạo transaction chuyển tiền\n      const transaction = new Transaction().add(SystemProgram.transfer({\n        fromPubkey: projectFeePayerKeypair.publicKey,\n        toPubkey: multisigAddress,\n        lamports: lamportsToSend\n      }));\n\n      // Cấu hình transaction\n      transaction.feePayer = projectFeePayerKeypair.publicKey;\n      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n\n      // Ký và gửi transaction\n      const signature = await connection.sendTransaction(transaction, [projectFeePayerKeypair]);\n      await connection.confirmTransaction(signature);\n\n      // Cập nhật số dư\n      await loadPdaBalance(multisigAddress);\n      await loadFeePayerBalance(projectFeePayerKeypair);\n      setTransactionStatus(`Đã nạp thành công ${depositAmount} SOL vào ví! Signature: ${signature}`);\n    } catch (error) {\n      console.error('Lỗi khi nạp tiền vào ví:', error);\n      setTransactionStatus(`Lỗi khi nạp tiền: ${error.message}`);\n    }\n  };\n\n  // Hàm để rút tiền từ ví multisig\n  const withdrawFromMultisig = async () => {\n    try {\n      // Kiểm tra xem ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi rút tiền.');\n        return;\n      }\n\n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n\n      // Kiểm tra các trường bắt buộc\n      if (!recipientAddress || !withdrawAmount || withdrawAmount <= 0) {\n        setTransactionStatus('Vui lòng nhập địa chỉ người nhận và số tiền hợp lệ.');\n        return;\n      }\n      let recipient;\n      try {\n        recipient = new PublicKey(recipientAddress);\n      } catch (error) {\n        setTransactionStatus('Địa chỉ người nhận không hợp lệ.');\n        return;\n      }\n\n      // Kiểm tra số dư của ví multisig\n      const multisigBalance = await connection.getBalance(multisigAddress);\n      const lamportsToSend = withdrawAmount * LAMPORTS_PER_SOL;\n      if (multisigBalance < lamportsToSend) {\n        setTransactionStatus(`Số dư ví không đủ. Hiện tại: ${multisigBalance / LAMPORTS_PER_SOL} SOL`);\n        return;\n      }\n      setTransactionStatus(`Đang rút ${withdrawAmount} SOL từ ví...`);\n\n      // Tạo discriminator cho withdraw\n      const withdrawDiscriminator = new Uint8Array([54, 27, 38, 179, 114, 92, 92, 82]);\n\n      // Số tiền rút (u64)\n      const amountBigInt = BigInt(Math.floor(withdrawAmount * LAMPORTS_PER_SOL));\n      const amountBytes = bigIntToLeBytes(amountBigInt);\n\n      // Tạo dữ liệu instruction\n      const withdrawData = concatUint8Arrays(withdrawDiscriminator,\n      // amount (u64)\n      bufferToUint8Array(Buffer.from(amountBytes)));\n\n      // Tạo transaction rút tiền\n      const withdrawTransaction = new Transaction();\n      withdrawTransaction.add(new TransactionInstruction({\n        keys: [{\n          pubkey: multisigAddress,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: recipient,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: projectFeePayerKeypair.publicKey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: SystemProgram.programId,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: PROGRAM_ID,\n        data: Buffer.from(withdrawData)\n      }));\n\n      // Sign và gửi transaction\n      withdrawTransaction.feePayer = projectFeePayerKeypair.publicKey;\n      withdrawTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      const withdrawSignature = await connection.sendTransaction(withdrawTransaction, [projectFeePayerKeypair]);\n      await connection.confirmTransaction(withdrawSignature);\n\n      // Cập nhật số dư\n      await loadPdaBalance(multisigAddress);\n      setTransactionStatus(`Đã rút thành công ${withdrawAmount} SOL từ ví! Signature: ${withdrawSignature}`);\n\n      // Reset form\n      setWithdrawAmount(0.05);\n      setRecipientAddress('');\n    } catch (error) {\n      console.error('Lỗi khi rút tiền từ ví:', error);\n      setTransactionStatus(`Lỗi khi rút tiền: ${error.message}`);\n    }\n  };\n\n  // Tự động cập nhật danh sách guardians khi multisigAddress thay đổi\n  useEffect(() => {\n    if (multisigAddress) {\n      // Load lại danh sách guardian IDs\n      getExistingGuardianIds();\n\n      // Load số dư của PDA\n      loadPdaBalance(multisigAddress);\n    }\n  }, [multisigAddress]);\n\n  // Hàm để kiểm tra guardian ID cụ thể\n  const testGuardianInfo = async id => {\n    if (!multisigAddress) {\n      setTransactionStatus('Ví chưa được khởi tạo');\n      return;\n    }\n    setTransactionStatus(`Đang kiểm tra chi tiết Guardian ID ${id}...`);\n    try {\n      // Tính PDA \n      const guardianPDA = await findGuardianAddress(id);\n      if (!guardianPDA) {\n        setTransactionStatus(`Không thể tính PDA cho Guardian ID ${id}`);\n        return;\n      }\n      console.log(`=== TEST === Đang kiểm tra chi tiết Guardian ID ${id} tại ${guardianPDA.toString()}`);\n      const guardianAccount = await connection.getAccountInfo(guardianPDA);\n      if (!guardianAccount) {\n        console.log(`=== TEST === Account không tồn tại tại địa chỉ ${guardianPDA.toString()}`);\n        setTransactionStatus(`Guardian ID ${id} không tồn tại trên blockchain`);\n        return;\n      }\n      console.log(`=== TEST === Account tồn tại!`);\n      console.log(`=== TEST === Owner: ${guardianAccount.owner.toString()}`);\n      console.log(`=== TEST === Data size: ${guardianAccount.data.length} bytes`);\n\n      // Kiểm tra discriminator\n      const discriminator = guardianAccount.data.slice(0, 8);\n      console.log(`=== TEST === Discriminator: ${Buffer.from(discriminator).toString('hex')}`);\n\n      // Bỏ qua 8 byte discriminator\n      const data = guardianAccount.data.slice(8);\n      try {\n        // Wallet (32 bytes)\n        const walletBytes = data.slice(0, 32);\n        const wallet = new PublicKey(walletBytes);\n        console.log(`=== TEST === Wallet: ${wallet.toString()}`);\n\n        // Guardian ID (8 bytes)\n        const guardianIdBytes = data.slice(32, 40);\n        let guardianId = BigInt(0);\n        for (let i = 0; i < 8; i++) {\n          guardianId |= BigInt(guardianIdBytes[i]) << BigInt(8 * i);\n        }\n        console.log(`=== TEST === Guardian ID parsed: ${guardianId}`);\n\n        // Name\n        const nameLength = new DataView(data.buffer, data.byteOffset + 40, 4).getUint32(0, true);\n        console.log(`=== TEST === Name length: ${nameLength}`);\n\n        // Nếu name length hợp lệ, tiếp tục parse\n        if (nameLength <= 100) {\n          const nameBytes = data.slice(44, 44 + nameLength);\n          const name = new TextDecoder().decode(nameBytes);\n          console.log(`=== TEST === Name: ${name}`);\n          setTransactionStatus(`Guardian ID ${id} tồn tại!\\n- PDA: ${guardianPDA.toString()}\\n- Wallet: ${wallet.toString()}\\n- Name: ${name}\\n- Guardian ID: ${guardianId}`);\n        } else {\n          console.log(`=== TEST === Name length không hợp lệ`);\n          setTransactionStatus(`Guardian ID ${id} tồn tại nhưng có cấu trúc dữ liệu không hợp lệ`);\n        }\n      } catch (parseError) {\n        console.error(`=== TEST === Lỗi khi parse dữ liệu:`, parseError);\n        setTransactionStatus(`Guardian ID ${id} tồn tại nhưng không thể parse dữ liệu: ${parseError}`);\n      }\n    } catch (error) {\n      console.error(`=== TEST === Lỗi:`, error);\n      setTransactionStatus(`Lỗi khi kiểm tra: ${error.message}`);\n    }\n  };\n\n  // Hàm đăng nhập vào ví đã tạo\n  const loginToWallet = async () => {\n    try {\n      setIsLoggingIn(true);\n      setTransactionStatus('Đang đăng nhập vào ví...\\n\\nBước 1: Đang yêu cầu xác thực WebAuthn...');\n\n      // 1. Yêu cầu người dùng xác thực với thiết bị (không cần nhập credential ID cụ thể)\n      try {\n        // Gọi hàm getWebAuthnAssertionForLogin với allowEmpty=true để cho phép người dùng chọn từ bất kỳ credential nào\n        const assertionResult = await getWebAuthnAssertionForLogin('', true);\n        if (!assertionResult.success || !assertionResult.rawId) {\n          throw new Error(assertionResult.error || 'Không thể xác thực với thiết bị');\n        }\n\n        // Lấy thông tin credential từ phản hồi\n        const credentialRawData = assertionResult.rawId;\n\n        // Chuyển rawId thành hex để sử dụng làm key trong bảng webauthn_credentials\n        const credentialIdHex = Buffer.from(credentialRawData).toString('hex');\n        console.log(\"Credential ID (hex):\", credentialIdHex);\n\n        // Chuyển rawId thành base64 để sử dụng trong blockchain\n        const rawIdBase64 = Buffer.from(credentialRawData).toString('base64');\n        console.log(\"Raw credential ID (base64):\", rawIdBase64);\n        setTransactionStatus(prev => prev + '\\nXác thực WebAuthn thành công!\\n\\nBước 2: Đang tìm thông tin ví...');\n\n        // 2. Truy vấn thông tin ví từ bảng webauthn_credentials\n        const credentialMapping = await getWalletByCredentialId(credentialIdHex);\n        if (credentialMapping) {\n          // Nếu tìm thấy trong bảng ánh xạ\n          setTransactionStatus(prev => prev + `\\nĐã tìm thấy thông tin ví trong database!`);\n\n          // Chuyển đổi từ chuỗi sang PublicKey\n          const walletAddressFromDB = new PublicKey(credentialMapping.walletAddress);\n          console.log(\"Wallet address from database:\", walletAddressFromDB.toString());\n\n          // 3. Kiểm tra xem ví có tồn tại trên blockchain không\n          const walletAccount = await connection.getAccountInfo(walletAddressFromDB);\n          if (!walletAccount) {\n            setTransactionStatus(`Ví tìm thấy trong database không tồn tại trên blockchain. Địa chỉ: ${walletAddressFromDB.toString()}`);\n            setIsLoggingIn(false);\n            return;\n          }\n\n          // 4. Cập nhật state với thông tin ví\n          setMultisigAddress(walletAddressFromDB);\n          setCredentialId(rawIdBase64); // Lưu credential ID gốc\n\n          setTransactionStatus(prev => prev + `\\nĐã tìm thấy ví tại địa chỉ: ${walletAddressFromDB.toString()}\\n\\nBước 3: Đang tải thông tin ví...`);\n        } else {\n          // Nếu không tìm thấy trong bảng ánh xạ, sử dụng phương pháp tính toán cũ\n          setTransactionStatus(prev => prev + '\\nKhông tìm thấy thông tin trong database, đang tính toán địa chỉ ví...');\n\n          // Tính địa chỉ ví từ credential ID\n          const multisigPDA = getMultisigPDA(rawIdBase64);\n          console.log(\"Computed Multisig PDA:\", multisigPDA.toString());\n\n          // Kiểm tra xem ví có tồn tại không\n          const walletAccount = await connection.getAccountInfo(multisigPDA);\n          if (!walletAccount) {\n            setTransactionStatus(`Không tìm thấy ví với credential này. Có thể bạn cần tạo ví mới.`);\n            setIsLoggingIn(false);\n            return;\n          }\n          setTransactionStatus(prev => prev + `\\nĐã tìm thấy ví tại địa chỉ: ${multisigPDA.toString()}\\n\\nBước 3: Đang tải thông tin ví...`);\n\n          // Cập nhật state với thông tin ví\n          setMultisigAddress(multisigPDA);\n          setCredentialId(rawIdBase64); // Lưu credential ID gốc\n        }\n\n        // 5. Tìm guardian PDA\n        await findGuardianAddress(1); // Tìm guardian chính (owner)\n\n        // 6. Tải số dư và danh sách guardian\n        await loadPdaBalance(multisigAddress);\n        await getExistingGuardianIds();\n\n        // 7. Hoàn thành đăng nhập\n        setIsLoggedIn(true);\n        setIsLoggingIn(false);\n        setTransactionStatus(`Đăng nhập thành công!\\n\\nĐịa chỉ ví: ${multisigAddress.toString()}\\nSố guardian: ${existingGuardians.length}`);\n\n        // 8. Ẩn form đăng nhập\n        setShowLoginForm(false);\n      } catch (webAuthnError) {\n        console.error(\"Lỗi khi xác thực WebAuthn:\", webAuthnError);\n        setTransactionStatus(`Lỗi khi xác thực: ${webAuthnError.message}`);\n        setIsLoggingIn(false);\n      }\n    } catch (error) {\n      console.error('Lỗi khi đăng nhập:', error);\n      setTransactionStatus(`Lỗi khi đăng nhập: ${error.message}`);\n      setIsLoggingIn(false);\n    }\n  };\n\n  // Hàm tạo mã mời ngẫu nhiên\n  const generateRandomCode = length => {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let result = '';\n    const randomValues = new Uint8Array(length);\n    crypto.getRandomValues(randomValues);\n    for (let i = 0; i < length; i++) {\n      result += chars.charAt(randomValues[i] % chars.length);\n    }\n    return result;\n  };\n\n  // Hàm tạo link mời guardian mới\n  const generateGuardianInvite = async () => {\n    try {\n      // Kiểm tra ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi mời guardian.');\n        return;\n      }\n\n      // Lấy danh sách guardian ID hiện tại\n      const existingIds = await getExistingGuardianIds();\n\n      // Sinh guardian ID mới không bị trùng\n      const newGuardianId = generateNewGuardianId(existingIds);\n\n      // Tạo mã ngẫu nhiên cho link mời\n      const inviteCode = generateRandomCode(8);\n\n      // Tạo link mời với URL ngrok từ biến môi trường hoặc sử dụng địa chỉ hiện tại\n      const ngrokUrl = process.env.REACT_APP_NGROK_URL || window.location.origin;\n      const inviteLink = `${ngrokUrl}/#/guardian-signup/${inviteCode}`;\n\n      // Hiển thị link (đặt state trước khi lưu vào Firebase)\n      setInviteCode(inviteCode);\n      setInviteLink(inviteLink);\n      setShowQRCode(true);\n\n      // Lưu thông tin vào Firebase\n      try {\n        await saveInvitation({\n          multisigAddress: multisigAddress.toString(),\n          guardianId: newGuardianId,\n          inviteCode,\n          status: 'pending',\n          ownerId: (projectFeePayerKeypair === null || projectFeePayerKeypair === void 0 ? void 0 : projectFeePayerKeypair.publicKey.toString()) || ''\n        });\n      } catch (error) {\n        console.error(\"Lỗi khi lưu vào Firebase:\", error);\n        // Hiển thị lỗi nhưng vẫn tiếp tục hiển thị link mời\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        setTransactionStatus(`Đã tạo link mời guardian: ${inviteLink}\\nLưu ý: Có lỗi khi lưu thông tin: ${errorMessage}`);\n        return inviteLink;\n      }\n      setTransactionStatus(`Đã tạo link mời guardian: ${inviteLink}`);\n      return inviteLink;\n    } catch (error) {\n      console.error(\"Lỗi khi tạo link mời guardian:\", error);\n      setTransactionStatus(`Lỗi khi tạo link mời guardian: ${error.message}`);\n      return null;\n    }\n  };\n\n  // Tải danh sách mã mời đang chờ\n  const loadPendingInvites = async () => {\n    try {\n      if (!projectFeePayerKeypair || !multisigAddress) return;\n      const ownerId = projectFeePayerKeypair.publicKey.toString();\n      // Chỉ lọc guardian của chính ví multisig hiện tại\n      const multisigAddressStr = multisigAddress.toString();\n      const invitesList = await getPendingInvites(ownerId, multisigAddressStr);\n      setPendingInvites(invitesList);\n      if (invitesList.length > 0) {\n        console.log(`Tìm thấy ${invitesList.length} guardian đang chờ hoàn tất cho ví ${multisigAddressStr}. Mã mời: ${invitesList.join(', ')}`);\n      }\n    } catch (error) {\n      console.error(\"Lỗi khi tải danh sách mã mời:\", error);\n    }\n  };\n\n  // Load danh sách mã mời khi component được mount và mỗi khi projectFeePayerKeypair hoặc multisigAddress thay đổi\n  useEffect(() => {\n    if (projectFeePayerKeypair && multisigAddress) {\n      loadPendingInvites();\n    }\n  }, [projectFeePayerKeypair, multisigAddress]);\n\n  // Hàm để lấy thông tin guardian đã đăng ký\n  const fetchGuardianDataFromDatabase = async inviteCode => {\n    try {\n      return await getGuardianData(inviteCode);\n    } catch (error) {\n      console.error(\"Lỗi khi lấy dữ liệu guardian:\", error);\n      return null;\n    }\n  };\n\n  // Hàm để lấy thông tin invitation\n  const fetchInviteFromDatabase = async inviteCode => {\n    try {\n      return await getInvitation(inviteCode);\n    } catch (error) {\n      console.error(\"Lỗi khi lấy dữ liệu invite:\", error);\n      return null;\n    }\n  };\n\n  // Hàm để cập nhật trạng thái guardian\n  const updateGuardianStatusInDatabase = async (inviteCode, status, txSignature) => {\n    try {\n      await updateGuardianStatus(inviteCode, status, txSignature);\n    } catch (error) {\n      console.error(\"Lỗi khi cập nhật trạng thái guardian:\", error);\n    }\n  };\n\n  // Hàm hoàn tất đăng ký guardian từ dữ liệu đã lưu\n  const completeGuardianRegistration = async inviteCode => {\n    try {\n      setTransactionStatus('Đang hoàn tất đăng ký guardian...');\n\n      // 1. Lấy dữ liệu guardian từ localStorage\n      const guardianData = await fetchGuardianDataFromDatabase(inviteCode);\n      if (!guardianData) {\n        setTransactionStatus('Không tìm thấy dữ liệu guardian. Vui lòng đảm bảo guardian đã hoàn tất đăng ký.');\n        return;\n      }\n      if (guardianData.status !== 'ready') {\n        setTransactionStatus('Guardian chưa hoàn tất đăng ký.');\n        return;\n      }\n\n      // 2. Lấy thông tin invite\n      const inviteData = await fetchInviteFromDatabase(inviteCode);\n      if (!inviteData) {\n        setTransactionStatus('Không tìm thấy thông tin mời guardian.');\n        return;\n      }\n\n      // 3. Tính PDA cho guardian\n      const multisigPDA = new PublicKey(inviteData.multisigAddress);\n      const guardianId = inviteData.guardianId;\n      const guardianPDA = await findGuardianAddress(guardianId);\n      if (!guardianPDA) {\n        setTransactionStatus('Không thể tính PDA cho guardian.');\n        return;\n      }\n\n      // 4. Chuyển đổi dữ liệu thành format phù hợp\n      const hashedRecoveryBytes = new Uint8Array(guardianData.hashedRecoveryBytes);\n      const compressedKeyBuffer = Buffer.from(guardianData.webauthnPublicKey);\n\n      // 5. Tạo discriminator cho add_guardian\n      const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n\n      // 6. Chuyển đổi guardian ID thành bytes (little-endian)\n      const guardianIdBigInt = BigInt(guardianId);\n      const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n\n      // 7. Chuẩn bị tên guardian\n      const guardianNameBuffer = Buffer.from(guardianData.guardianName);\n      const guardianNameLenBuffer = Buffer.alloc(4);\n      guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n\n      // 8. Đặt is_owner = false vì đây là guardian member, không phải owner\n      const isOwnerByte = new Uint8Array([0]); // false = 0\n\n      // 9. Cấu hình webauthn_pubkey là Some(compressed_key)\n      const hasWebauthn = new Uint8Array([1]); // Some variant\n\n      // 10. Tạo dữ liệu instruction\n      const addGuardianData = concatUint8Arrays(addGuardianDiscriminator,\n      // guardian_id (u64)\n      bufferToUint8Array(Buffer.from(guardianIdBytes)),\n      // guardian_name (string)\n      bufferToUint8Array(guardianNameLenBuffer), bufferToUint8Array(guardianNameBuffer),\n      // recovery_hash_intermediate ([u8; 32])\n      hashedRecoveryBytes,\n      // is_owner (bool)\n      isOwnerByte,\n      // webauthn_pubkey (Option<[u8; 33]>) - Some variant + compressed key\n      hasWebauthn, bufferToUint8Array(Buffer.from(compressedKeyBuffer)));\n\n      // 11. Tạo transaction add guardian\n      const addGuardianTransaction = new Transaction();\n      addGuardianTransaction.add(new TransactionInstruction({\n        keys: [{\n          pubkey: multisigPDA,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: guardianPDA,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: projectFeePayerKeypair.publicKey,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: projectFeePayerKeypair.publicKey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: SystemProgram.programId,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: PROGRAM_ID,\n        data: Buffer.from(addGuardianData)\n      }));\n\n      // Sign và gửi transaction với fee payer của dự án\n      addGuardianTransaction.feePayer = projectFeePayerKeypair.publicKey;\n      addGuardianTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      setTransactionStatus(prev => prev + '\\nĐang gửi transaction...');\n      const addGuardianSignature = await connection.sendTransaction(addGuardianTransaction, [projectFeePayerKeypair]);\n      setTransactionStatus(prev => prev + '\\nĐang xác nhận transaction...');\n      await connection.confirmTransaction(addGuardianSignature);\n\n      // Cập nhật trạng thái trong DB\n      await updateGuardianStatusInDatabase(inviteCode, 'completed', addGuardianSignature);\n      setTransactionStatus(`Guardian đã được thêm thành công với ID: ${guardianId}!\\n` + `Signature: ${addGuardianSignature}`);\n\n      // Xóa dữ liệu guardian từ database sau khi hoàn tất\n      setTransactionStatus(prev => prev + '\\n\\nĐang xóa dữ liệu guardian từ database...');\n      console.log(`Bắt đầu xóa dữ liệu guardian với mã mời: ${inviteCode}`);\n      const deleteResult = await deleteGuardianData(inviteCode);\n      if (deleteResult) {\n        console.log(`✅ ĐÃ XÓA THÀNH CÔNG dữ liệu guardian, invitation và lookup với mã mời: ${inviteCode}`);\n\n        // Cập nhật thông báo thành công rõ ràng hơn\n        setTransactionStatus(`✅ HOÀN TẤT THÀNH CÔNG!\n        \n        Guardian \"${guardianData.guardianName}\" (ID: ${guardianData.guardianId}) đã được thêm thành công vào ví.\n        \n        Địa chỉ Guardian: ${guardianPDA.toString()}\n        Signature: ${addGuardianSignature}\n        \n        ✅ Dữ liệu đã được xóa khỏi database để bảo vệ quyền riêng tư.\n        \n        ✅ Guardian hiện đã sẵn sàng sử dụng và đã được ẩn khỏi danh sách chờ.`);\n\n        // Bỏ mã mời đã sử dụng khỏi danh sách\n        setPendingInvites(prev => prev.filter(code => code !== inviteCode));\n\n        // Không đóng form để người dùng có thể tiếp tục thêm guardian khác\n        /* \n        if (pendingInvites.length <= 1) {\n          setShowInviteInput(false);\n        }\n        */\n      } else {\n        console.error(`❌ KHÔNG THỂ XÓA dữ liệu guardian với mã mời: ${inviteCode}`);\n        setTransactionStatus(prev => prev + '\\n❌ Không thể xóa dữ liệu guardian từ database.');\n      }\n\n      // Cập nhật danh sách guardian và load lại danh sách mã mời\n      await getExistingGuardianIds();\n      await loadPendingInvites();\n\n      // Cập nhật số dư của ví PDA\n      await loadPdaBalance(multisigPDA);\n    } catch (error) {\n      console.error(\"Lỗi khi hoàn tất đăng ký guardian:\", error);\n      setTransactionStatus(`Lỗi khi hoàn tất đăng ký guardian: ${error.message}`);\n    }\n  };\n\n  // Hàm kiểm tra thông tin guardians trong database\n  const checkGuardiansInDatabase = async () => {\n    try {\n      setTransactionStatus('Đang kiểm tra dữ liệu guardians từ Firestore...');\n      if (!projectFeePayerKeypair || !multisigAddress) {\n        setTransactionStatus('Cần có thông tin fee payer và multisig address để kiểm tra.');\n        return;\n      }\n      const ownerId = projectFeePayerKeypair.publicKey.toString();\n      const multisigAddressStr = multisigAddress.toString();\n\n      // Lấy danh sách invitations đang chờ CHỈ của ví hiện tại\n      const pendingInvites = await getPendingInvites(ownerId, multisigAddressStr);\n      console.log(`Danh sách mã mời đang chờ cho ví ${multisigAddressStr}:`, pendingInvites);\n      if (pendingInvites.length === 0) {\n        setTransactionStatus(`Không tìm thấy mã mời nào đang chờ xử lý cho ví ${multisigAddressStr}.`);\n        return;\n      }\n\n      // Kiểm tra thông tin từng guardian\n      let resultMessage = 'Thông tin guardians từ database:\\n\\n';\n      for (const inviteCode of pendingInvites) {\n        // Lấy thông tin invitation\n        const inviteData = await getInvitation(inviteCode);\n        if (!inviteData) {\n          resultMessage += `Mã mời ${inviteCode}: Không tìm thấy thông tin invitation.\\n`;\n          continue;\n        }\n\n        // Lấy thông tin guardian\n        const guardianData = await getGuardianData(inviteCode);\n        if (!guardianData) {\n          resultMessage += `Mã mời ${inviteCode}: Invitation tồn tại nhưng chưa có thông tin guardian.\\n`;\n          continue;\n        }\n\n        // Hiển thị thông tin\n        resultMessage += `Mã mời: ${inviteCode}\\n`;\n        resultMessage += `Guardian ID: ${guardianData.guardianId}\\n`;\n        resultMessage += `Tên guardian: ${guardianData.guardianName}\\n`;\n        resultMessage += `Trạng thái: ${guardianData.status}\\n`;\n        resultMessage += `WebAuthn ID: ${guardianData.webauthnCredentialId.substring(0, 20)}...\\n\\n`;\n      }\n      setTransactionStatus(resultMessage);\n    } catch (error) {\n      console.error(\"Lỗi khi kiểm tra thông tin guardians:\", error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      setTransactionStatus(`Lỗi khi kiểm tra thông tin guardians: ${errorMessage}`);\n    }\n  };\n\n  // Hoàn tất quá trình đăng ký guardian dựa trên mã mời\n  const completeGuardianSetup = async inviteCode => {\n    try {\n      setTransactionStatus(`Đang hoàn tất quá trình đăng ký guardian với mã mời: ${inviteCode}...`);\n\n      // 1. Lấy thông tin guardian\n      const guardianData = await getGuardianData(inviteCode);\n      if (!guardianData) {\n        setTransactionStatus('Không tìm thấy thông tin guardian. Vui lòng đảm bảo guardian đã hoàn tất đăng ký.');\n        return;\n      }\n      if (guardianData.status !== 'ready') {\n        setTransactionStatus(`Guardian có trạng thái không hợp lệ: ${guardianData.status}`);\n        return;\n      }\n\n      // 2. Thêm guardian vào blockchain\n      setTransactionStatus(prev => prev + '\\n\\nĐang thêm guardian vào blockchain...');\n\n      // Tạo multisig PDA từ địa chỉ multisig\n      const multisigPubkey = new PublicKey(guardianData.multisigAddress);\n\n      // Tạo WebAuthn public key từ dữ liệu lưu trữ\n      const webauthnPubkey = Buffer.from(new Uint8Array(guardianData.webauthnPublicKey));\n\n      // Chuẩn bị dữ liệu guardian\n      const guardianIndex = guardianData.guardianId;\n      const guardianName = guardianData.guardianName;\n      const guardianType = 0; // 0 = Guardian thường\n      const recoveryHash = Uint8Array.from(guardianData.hashedRecoveryBytes);\n\n      // Thêm guardian vào blockchain\n      if (projectFeePayerKeypair) {\n        // Tạo transaction\n        const tx = new Transaction();\n\n        // Tìm PDA cho guardian\n        const guardianIdBigInt = BigInt(guardianIndex);\n        const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n        const [guardianPDA] = await PublicKey.findProgramAddress([Buffer.from(\"guardian\"), multisigPubkey.toBuffer(), guardianIdBytes], PROGRAM_ID);\n\n        // Tạo instruction để thêm guardian\n        // Sử dụng discriminator đúng cho add_guardian theo IDL\n        const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n\n        // Chuẩn bị tên guardian\n        const guardianNameBuffer = Buffer.from(guardianName);\n        const guardianNameLenBuffer = Buffer.alloc(4);\n        guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n\n        // Đặt is_owner = false vì đây là guardian member, không phải owner\n        const isOwnerByte = new Uint8Array([0]); // false = 0\n\n        // Cấu hình webauthn_pubkey là Some(webauthnPubkey)\n        const hasWebauthn = new Uint8Array([1]); // Some variant\n\n        // Tạo dữ liệu instruction\n        const instructionData = concatUint8Arrays(addGuardianDiscriminator, guardianIdBytes, bufferToUint8Array(guardianNameLenBuffer), bufferToUint8Array(guardianNameBuffer), recoveryHash, isOwnerByte, hasWebauthn, bufferToUint8Array(webauthnPubkey));\n        const addGuardianIx = new TransactionInstruction({\n          keys: [{\n            pubkey: multisigPubkey,\n            isSigner: false,\n            isWritable: true\n          }, {\n            pubkey: guardianPDA,\n            isSigner: false,\n            isWritable: true\n          }, {\n            pubkey: projectFeePayerKeypair.publicKey,\n            isSigner: false,\n            isWritable: false\n          }, {\n            pubkey: projectFeePayerKeypair.publicKey,\n            isSigner: true,\n            isWritable: true\n          }, {\n            pubkey: SystemProgram.programId,\n            isSigner: false,\n            isWritable: false\n          }],\n          programId: PROGRAM_ID,\n          data: Buffer.from(instructionData)\n        });\n        tx.add(addGuardianIx);\n\n        // Gửi transaction\n        setTransactionStatus(prev => prev + '\\nĐang gửi transaction...');\n        const signature = await sendAndConfirmTransaction(connection, tx, [projectFeePayerKeypair], {\n          commitment: 'confirmed',\n          skipPreflight: true\n        });\n\n        // Xác nhận transaction đã thành công\n        setTransactionStatus(prev => prev + '\\nĐang xác nhận transaction...');\n        await connection.confirmTransaction(signature, 'confirmed');\n\n        // Cập nhật trạng thái guardian\n        await updateGuardianStatus(inviteCode, 'completed', signature);\n\n        // Thông báo kết quả\n        setTransactionStatus(`Guardian đã được thêm thành công vào blockchain!\n- Tên: ${guardianData.guardianName}\n- ID: ${guardianData.guardianId}\n- Địa chỉ: ${guardianPDA.toString()}\n- Signature: ${signature}\n\nGuardian đã sẵn sàng để sử dụng trong ví multisig của bạn.`);\n\n        // Xóa dữ liệu guardian từ database sau khi hoàn tất\n        setTransactionStatus(prev => prev + '\\n\\nĐang xóa dữ liệu guardian từ database...');\n        console.log(`Bắt đầu xóa dữ liệu guardian với mã mời: ${inviteCode}`);\n        const deleteResult = await deleteGuardianData(inviteCode);\n        if (deleteResult) {\n          console.log(`✅ ĐÃ XÓA THÀNH CÔNG dữ liệu guardian, invitation và lookup với mã mời: ${inviteCode}`);\n\n          // Cập nhật thông báo thành công rõ ràng hơn\n          setTransactionStatus(`✅ HOÀN TẤT THÀNH CÔNG!\n          \n          Guardian \"${guardianData.guardianName}\" (ID: ${guardianData.guardianId}) đã được thêm thành công vào ví.\n          \n          Địa chỉ Guardian: ${guardianPDA.toString()}\n          Signature: ${signature}\n          \n          ✅ Dữ liệu đã được xóa khỏi database để bảo vệ quyền riêng tư.\n          \n          ✅ Guardian hiện đã sẵn sàng sử dụng và đã được ẩn khỏi danh sách chờ.`);\n\n          // Bỏ mã mời đã sử dụng khỏi danh sách\n          setPendingInvites(prev => prev.filter(code => code !== inviteCode));\n\n          // Không đóng form sau khi hoàn tất để người dùng có thể tiếp tục thêm guardian khác\n          /* \n          if (pendingInvites.length <= 1) {\n            setShowInviteInput(false);\n          }\n          */\n        } else {\n          console.error(`❌ KHÔNG THỂ XÓA dữ liệu guardian với mã mời: ${inviteCode}`);\n          setTransactionStatus(prev => prev + '\\n❌ Không thể xóa dữ liệu guardian từ database.');\n        }\n\n        // Làm mới danh sách guardian và cập nhật UI\n        await getExistingGuardianIds();\n        await loadPendingInvites();\n\n        // Cập nhật số dư của ví\n        if (multisigAddress) {\n          await loadPdaBalance(multisigAddress);\n        }\n      } else {\n        setTransactionStatus('Lỗi: Fee payer không khả dụng');\n      }\n    } catch (error) {\n      console.error(\"Lỗi khi hoàn tất quá trình đăng ký guardian:\", error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      setTransactionStatus(`Lỗi khi hoàn tất quá trình đăng ký guardian: ${errorMessage}`);\n    }\n  };\n\n  // Hàm chuyển tiền\n  const transferFunds = async (recipientAddress, amount) => {\n    try {\n      // Kiểm tra xem ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi chuyển tiền.');\n        return;\n      }\n\n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n      let recipient;\n      try {\n        recipient = new PublicKey(recipientAddress);\n      } catch (error) {\n        setTransactionStatus('Địa chỉ người nhận không hợp lệ.');\n        return;\n      }\n\n      // Kiểm tra số dư của ví multisig\n      const multisigBalance = await connection.getBalance(multisigAddress);\n      const lamportsToSend = amount * LAMPORTS_PER_SOL;\n      if (multisigBalance < lamportsToSend) {\n        setTransactionStatus(`Số dư ví không đủ. Hiện tại: ${multisigBalance / LAMPORTS_PER_SOL} SOL`);\n        return;\n      }\n      setIsProcessingTransfer(true);\n      setTransactionStatus(`Đang chuyển ${amount} SOL từ ví đến ${recipientAddress}...`);\n\n      // Tạo discriminator cho withdraw\n      const withdrawDiscriminator = new Uint8Array([54, 27, 38, 179, 114, 92, 92, 82]);\n\n      // Số tiền chuyển (u64)\n      const amountBigInt = BigInt(Math.floor(amount * LAMPORTS_PER_SOL));\n      const amountBytes = bigIntToLeBytes(amountBigInt);\n\n      // Tạo dữ liệu instruction\n      const withdrawData = concatUint8Arrays(withdrawDiscriminator,\n      // amount (u64)\n      bufferToUint8Array(Buffer.from(amountBytes)));\n\n      // Tạo transaction chuyển tiền\n      const transferTransaction = new Transaction();\n      transferTransaction.add(new TransactionInstruction({\n        keys: [{\n          pubkey: multisigAddress,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: recipient,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: projectFeePayerKeypair.publicKey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: SystemProgram.programId,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: PROGRAM_ID,\n        data: Buffer.from(withdrawData)\n      }));\n\n      // Sign và gửi transaction\n      transferTransaction.feePayer = projectFeePayerKeypair.publicKey;\n      transferTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      const transferSignature = await connection.sendTransaction(transferTransaction, [projectFeePayerKeypair]);\n      await connection.confirmTransaction(transferSignature);\n\n      // Cập nhật số dư\n      await loadPdaBalance(multisigAddress);\n      setTransactionStatus(`Đã chuyển thành công ${amount} SOL đến ${recipientAddress}! Signature: ${transferSignature}`);\n    } catch (error) {\n      console.error('Lỗi khi chuyển tiền:', error);\n      setTransactionStatus(`Lỗi khi chuyển tiền: ${error.message}`);\n      throw error;\n    } finally {\n      setIsProcessingTransfer(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: /*#__PURE__*/_jsxDEV(\"header\", {\n      className: \"App-header\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: \"Moon Wallet\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2150,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"nav-buttons\",\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"nav-button\",\n          onClick: () => {\n            setShowLoginForm(false);\n            setShowQRCode(false);\n            setShowInviteInput(false);\n            setShowAddGuardianForm(false);\n            setShowTransferScreen(false);\n          },\n          children: \"Trang ch\\u1EE7\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2154,\n          columnNumber: 11\n        }, this), isLoggedIn && /*#__PURE__*/_jsxDEV(_Fragment, {\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            className: \"nav-button\",\n            onClick: () => {\n              setShowTransferScreen(true);\n              setShowLoginForm(false);\n              setShowQRCode(false);\n              setShowInviteInput(false);\n              setShowAddGuardianForm(false);\n            },\n            children: \"Chuy\\u1EC3n ti\\u1EC1n\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2169,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            className: \"nav-button\",\n            onClick: () => {\n              setShowAddGuardianForm(true);\n              setShowLoginForm(false);\n              setShowQRCode(false);\n              setShowInviteInput(false);\n              setShowTransferScreen(false);\n            },\n            children: \"Qu\\u1EA3n l\\xFD Guardian\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 2181,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true), !isLoggedIn && /*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"nav-button\",\n          onClick: () => {\n            setShowLoginForm(true);\n            setShowQRCode(false);\n            setShowInviteInput(false);\n            setShowAddGuardianForm(false);\n            setShowTransferScreen(false);\n          },\n          children: \"\\u0110\\u0103ng nh\\u1EADp\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2197,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 2153,\n        columnNumber: 9\n      }, this), showTransferScreen && multisigAddress && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"section transfer-section\",\n        children: /*#__PURE__*/_jsxDEV(TransferForm, {\n          onTransfer: transferFunds,\n          isProcessing: isProcessingTransfer,\n          balance: pdaBalance\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2215,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2214,\n        columnNumber: 11\n      }, this), transactionStatus && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"transaction-status\",\n        children: /*#__PURE__*/_jsxDEV(\"p\", {\n          children: transactionStatus\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 2226,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 2225,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 2149,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 2148,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"zvzF9k8uNX2HCTG7BC58YX7x0V4=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","Connection","PublicKey","Keypair","Transaction","SystemProgram","TransactionInstruction","LAMPORTS_PER_SOL","sendAndConfirmTransaction","Buffer","createWebAuthnCredential","getWebAuthnAssertionForLogin","calculateMultisigAddress","processCredentialIdForPDA","getMultisigPDA","getGuardianPDA","saveInvitation","getInvitation","getGuardianData","updateGuardianStatus","getPendingInvites","deleteGuardianData","getWalletByCredentialId","TransferForm","jsxDEV","_jsxDEV","Fragment","_Fragment","RPC_ENDPOINT","process","env","REACT_APP_RPC_ENDPOINT","PROGRAM_ID_STRING","REACT_APP_PROGRAM_ID","PROGRAM_ID","console","log","REACT_APP_FEE_PAYER_SECRET_KEY","split","length","connectionOptions","commitment","confirmTransactionInitialTimeout","disableRetryOnRateLimit","fetch","connection","ActionParams","constructor","props","amount","destination","tokenMint","TEMP_WALLET_PUBKEY","bufferToUint8Array","buffer","Uint8Array","byteOffset","byteLength","concatUint8Arrays","arrays","totalLength","reduce","acc","arr","result","offset","set","bigIntToLeBytes","value","bytesLength","i","Number","BigInt","calculateMultisigPDA","programId","credentialId","seedBuffer","from","toString","findProgramAddressSync","compressPublicKey","uncompressedKey","warn","randomKey","alloc","randomBytes","crypto","getRandomValues","x","slice","y","prefix","compressedKey","hashRecoveryPhrase","phrase","phraseBytes","TextEncoder","encode","inputBytes","Math","min","hashBuffer","subtle","digest","convertSecretKeyStringToUint8Array","secretKeyString","Error","numbers","map","s","parseInt","trim","bytes","hashCredentialId","encoder","data","App","_s","walletKeypair","setWalletKeypair","walletBalance","setWalletBalance","multisigAddress","setMultisigAddress","threshold","setThreshold","guardianName","setGuardianName","recoveryPhrase","setRecoveryPhrase","transactionStatus","setTransactionStatus","guardianPDA","setGuardianPDA","isLoadingBalance","setIsLoadingBalance","setCredentialId","webauthnPubkey","setWebauthnPubkey","walletName","setWalletName","isUsingTempWallet","setIsUsingTempWallet","newGuardianName","setNewGuardianName","newRecoveryPhrase","setNewRecoveryPhrase","existingGuardians","setExistingGuardians","showAddGuardianForm","setShowAddGuardianForm","projectFeePayerKeypair","setProjectFeePayerKeypair","usingProjectFeePayer","setUsingProjectFeePayer","feePayerBalance","setFeePayerBalance","isLoadingFeePayerBalance","setIsLoadingFeePayerBalance","pdaBalance","setPdaBalance","isLoadingPdaBalance","setIsLoadingPdaBalance","selectedGuardianId","setSelectedGuardianId","depositAmount","setDepositAmount","withdrawAmount","setWithdrawAmount","recipientAddress","setRecipientAddress","loginCredentialId","setLoginCredentialId","isLoggingIn","setIsLoggingIn","isLoggedIn","setIsLoggedIn","showLoginForm","setShowLoginForm","inviteLink","setInviteLink","inviteCode","setInviteCode","showQRCode","setShowQRCode","showInviteInput","setShowInviteInput","pendingInvites","setPendingInvites","showTransferScreen","setShowTransferScreen","isProcessingTransfer","setIsProcessingTransfer","newKeypair","generate","projectPayerPrivateKey","feePayerKeypair","fromSecretKey","loadFeePayerBalance","keypair","balance","getBalance","publicKey","error","useTempWallet","tempWalletPrivateKey","findMultisigAddress","loadBalance","message","createWalletWithWebAuthn","walletAddress","rawIdBase64","rawId","prev","multisigPDA","existingAccount","getAccountInfo","guardianId","guardianIdBytes","guardianPDAAddress","subarray","toBuffer","transaction","initMultisigDiscriminator","thresholdBytes","credentialIdString","credentialIdBuffer","credentialIdLenBuffer","writeUInt32LE","credentialIdLenBytes","credentialIdDataBytes","initData","add","keys","pubkey","isSigner","isWritable","feePayer","recentBlockhash","getLatestBlockhash","blockhash","instructions","ix","index","k","discriminator","Array","credentialIdLength","isOwner","hasWebauthn","webauthnPubkeyLength","signature","sendTransaction","confirmTransaction","guardianMultisigPDA","hashedRecoveryBytes","addGuardianDiscriminator","guardianIdBigIntBytes","guardianNameBuffer","guardianNameLenBuffer","recoveryHashIntermediateBytes","isOwnerByte","uncompressedKeyBuffer","compressedKeyBuffer","addGuardianData","addGuardianTransaction","addGuardianSignature","loadPdaBalance","pda","bump","pdaAddress","findGuardianAddress","guardianIdBigInt","requestAirdrop","fundFromValidator","validatorKey","transfer","fromPubkey","toPubkey","lamports","getWalletInfo","multisigAccount","guardian_count","recovery_nonce","DataView","getBigUint64","transaction_nonce","last_transaction_timestamp","getBigInt64","getGuardianInfo","guardianAccount","owner","equals","substring","walletBytes","wallet","nameLength","getUint32","nameOffset","nameBytes","name","TextDecoder","decode","currentOffset","isActive","recoveryHash","recoveryHashHex","webauthnHex","parseError","getExistingGuardianIds","guardianIds","push","includes","join","generateNewGuardianId","existingIds","newId","addNewGuardian","newGuardianId","guardianIdentifier","webAuthnResult","existingGuardian","Promise","resolve","setTimeout","newGuardianAccount","webAuthnError","depositToMultisig","lamportsToSend","withdrawFromMultisig","recipient","multisigBalance","withdrawDiscriminator","amountBigInt","floor","amountBytes","withdrawData","withdrawTransaction","withdrawSignature","testGuardianInfo","id","loginToWallet","assertionResult","success","credentialRawData","credentialIdHex","credentialMapping","walletAddressFromDB","walletAccount","generateRandomCode","chars","randomValues","charAt","generateGuardianInvite","ngrokUrl","REACT_APP_NGROK_URL","window","location","origin","status","ownerId","errorMessage","loadPendingInvites","multisigAddressStr","invitesList","fetchGuardianDataFromDatabase","fetchInviteFromDatabase","updateGuardianStatusInDatabase","txSignature","completeGuardianRegistration","guardianData","inviteData","webauthnPublicKey","deleteResult","filter","code","checkGuardiansInDatabase","resultMessage","webauthnCredentialId","completeGuardianSetup","multisigPubkey","guardianIndex","guardianType","tx","findProgramAddress","instructionData","addGuardianIx","skipPreflight","transferFunds","transferTransaction","transferSignature","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","onTransfer","isProcessing","_c","$RefreshReg$"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/acacac/src/App.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { Connection, PublicKey, Keypair, Transaction, SystemProgram, TransactionInstruction, Commitment, Signer, LAMPORTS_PER_SOL, sendAndConfirmTransaction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport './App.css';\nimport { createWebAuthnCredential, getWebAuthnAssertionForLogin, calculateMultisigAddress, getWebAuthnAssertion } from './utils/webauthnUtils';\nimport { processCredentialIdForPDA, getMultisigPDA, getGuardianPDA, getAllGuardianPDAs } from './utils/credentialUtils';\nimport { QRCodeSVG } from 'qrcode.react';\nimport { \n  saveInvitation, \n  getInvitation, \n  getGuardianData, \n  updateGuardianStatus,\n  getPendingInvites,\n  deleteGuardianData\n} from './firebase/guardianService';\nimport { getWalletByCredentialId } from './firebase/webAuthnService';\nimport TransferForm from './components/TransferForm';\n\n// Lấy các biến môi trường hoặc sử dụng giá trị mặc định\nconst RPC_ENDPOINT = process.env.REACT_APP_RPC_ENDPOINT || 'http://127.0.0.1:8899'; // Localhost validator\nconst PROGRAM_ID_STRING = process.env.REACT_APP_PROGRAM_ID || 'DeN1rBfabZezHPvrq9q7BbzUbZkrjnHE1kQDrPK8kWQ3'; // Program ID mới triển khai\n\n// Địa chỉ Program ID từ smart contract\nexport const PROGRAM_ID = new PublicKey(PROGRAM_ID_STRING);\n\n// Log biến môi trường để debug\nconsole.log(\"Biến môi trường RPC_ENDPOINT:\", process.env.REACT_APP_RPC_ENDPOINT);\nconsole.log(\"Biến môi trường PROGRAM_ID:\", process.env.REACT_APP_PROGRAM_ID);\nconsole.log(\"Biến môi trường FEE_PAYER_SECRET_KEY tồn tại:\", !!process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\nif (process.env.REACT_APP_FEE_PAYER_SECRET_KEY) {\n  console.log(\"Độ dài FEE_PAYER_SECRET_KEY:\", process.env.REACT_APP_FEE_PAYER_SECRET_KEY.split(',').length);\n}\n\n// Tùy chọn kết nối\nconst connectionOptions = {\n  commitment: 'confirmed' as Commitment,\n  confirmTransactionInitialTimeout: 60000,\n  disableRetryOnRateLimit: false,\n  fetch: fetch\n};\n\n// Connection với validator\nconst connection = new Connection(RPC_ENDPOINT, connectionOptions);\n\n// Schema cho các struct của chương trình\nclass ActionParams {\n  amount: number | null;\n  destination: PublicKey | null;\n  tokenMint: PublicKey | null;\n\n  constructor(props: { \n    amount: number | null; \n    destination: PublicKey | null; \n    tokenMint: PublicKey | null \n  }) {\n    this.amount = props.amount;\n    this.destination = props.destination;\n    this.tokenMint = props.tokenMint;\n  }\n}\n\n// Ví tạm thời đã được tạo và nhận SOL trước đó\nconst TEMP_WALLET_PUBKEY = '9Q8iZnAvCQP3uaDTuYbrvYSRDWB7Kk19u4TS1MDRSStJ';\n\n// Hàm chuyển đổi Buffer sang Uint8Array\nfunction bufferToUint8Array(buffer: Buffer): Uint8Array {\n  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n}\n\n// Hàm concat cho Uint8Array\nfunction concatUint8Arrays(...arrays: Uint8Array[]): Uint8Array {\n  // Tính tổng độ dài\n  const totalLength = arrays.reduce((acc, arr) => acc + arr.length, 0);\n  \n  // Tạo mảng mới với tổng độ dài\n  const result = new Uint8Array(totalLength);\n  \n  // Copy dữ liệu vào mảng mới\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  \n  return result;\n}\n\n// Hàm chuyển đổi từ BigInt (u64) sang bytes theo thứ tự little-endian\nconst bigIntToLeBytes = (value: bigint, bytesLength: number = 8): Uint8Array => {\n  const result = new Uint8Array(bytesLength);\n  for (let i = 0; i < bytesLength; i++) {\n    result[i] = Number((value >> BigInt(8 * i)) & BigInt(0xff));\n  }\n  return result;\n};\n\n// Helper function để tính toán MultisigPDA một cách nhất quán\nconst calculateMultisigPDA = async (programId: PublicKey, credentialId: string): Promise<[PublicKey, number]> => {\n  // Sử dụng hàm processCredentialIdForPDA từ helpers.ts để xử lý credential ID\n  // đảm bảo nhất quán với smart contract\n  const seedBuffer = processCredentialIdForPDA(credentialId);\n  console.log(\"Xử lý credential ID:\", credentialId);\n  console.log(\"Seed buffer để tính PDA:\", Buffer.from(seedBuffer).toString('hex'));\n  \n  return PublicKey.findProgramAddressSync(\n    [\n      Buffer.from(\"multisig\"),\n      seedBuffer\n    ],\n    programId\n  );\n};\n\n// Hàm nén khóa công khai từ dạng uncompressed (65 bytes) sang compressed (33 bytes)\nconst compressPublicKey = (uncompressedKey: Buffer): Buffer => {\n  // Đảm bảo khóa bắt đầu với byte 0x04 (không nén)\n  if (uncompressedKey[0] !== 0x04 || uncompressedKey.length !== 65) {\n    console.warn('Khóa không đúng định dạng không nén ECDSA, tạo khóa ngẫu nhiên');\n    // Tạo khóa random nếu không đúng định dạng\n    const randomKey = Buffer.alloc(33);\n    randomKey[0] = 0x02; // compressed, y is even\n    \n    // Tạo dữ liệu ngẫu nhiên cho 32 bytes còn lại\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    \n    // Sao chép vào buffer\n    for (let i = 0; i < 32; i++) {\n      randomKey[i+1] = randomBytes[i];\n    }\n    \n    return randomKey;\n  }\n  \n  // Lấy tọa độ x và y\n  const x = new Uint8Array(uncompressedKey.slice(1, 33));\n  const y = new Uint8Array(uncompressedKey.slice(33, 65));\n  \n  // Tính prefix: 0x02 nếu y chẵn, 0x03 nếu y lẻ\n  const prefix = (y[31] & 1) === 0 ? 0x02 : 0x03;\n  \n  // Tạo khóa nén: prefix (1 byte) + x (32 bytes)\n  const compressedKey = Buffer.alloc(33);\n  compressedKey[0] = prefix;\n  \n  // Copy x vào compressedKey từ vị trí 1\n  for (let i = 0; i < 32; i++) {\n    compressedKey[i + 1] = x[i];\n  }\n  \n  return compressedKey;\n};\n\n// Hàm hash recovery phrase tại frontend\nconst hashRecoveryPhrase = async (phrase: string): Promise<Uint8Array> => {\n  // Chuyển recovery phrase thành bytes\n  const phraseBytes = new TextEncoder().encode(phrase);\n  \n  // Tạo buffer 32 bytes để lưu dữ liệu\n  const inputBytes = new Uint8Array(32);\n  \n  // Sao chép dữ liệu từ phrase, đảm bảo không vượt quá 32 bytes\n  inputBytes.set(phraseBytes.slice(0, Math.min(phraseBytes.length, 32)));\n  \n  // Hash bằng SHA-256\n  const hashBuffer = await crypto.subtle.digest('SHA-256', inputBytes);\n  \n  // Chuyển kết quả thành Uint8Array\n  return new Uint8Array(hashBuffer);\n};\n\n// Chuyển đổi secret key từ chuỗi trong .env thành mảng số\nconst convertSecretKeyStringToUint8Array = (secretKeyString: string | undefined): Uint8Array => {\n  if (!secretKeyString) {\n    throw new Error('Fee payer secret key không được định nghĩa trong biến môi trường');\n  }\n  \n  // Chuyển đổi chuỗi \"1,2,3,...\" thành mảng số\n  const numbers = secretKeyString.split(',').map(s => parseInt(s.trim(), 10));\n  \n  // Kiểm tra kích thước hợp lệ (64 bytes cho ed25519)\n  if (numbers.length !== 64 && numbers.length !== 65) {\n    throw new Error(`Secret key phải có 64 hoặc 65 bytes, nhưng có ${numbers.length} bytes`);\n  }\n  \n  // Nếu có 65 bytes, bỏ qua byte cuối cùng (thường là checksum)\n  const bytes = numbers.length === 65 ? numbers.slice(0, 64) : numbers;\n  \n  return new Uint8Array(bytes);\n};\n\n// Add this function near the top with other utility functions\nconst hashCredentialId = async (credentialId: string): Promise<Uint8Array> => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(credentialId);\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  return new Uint8Array(hashBuffer);\n};\n\nfunction App() {\n  const [walletKeypair, setWalletKeypair] = useState<Keypair | null>(null);\n  const [walletBalance, setWalletBalance] = useState<number>(0);\n  const [multisigAddress, setMultisigAddress] = useState<PublicKey | null>(null);\n  const [threshold, setThreshold] = useState<number>(1);\n  const [guardianName, setGuardianName] = useState<string>('Owner');\n  const [recoveryPhrase, setRecoveryPhrase] = useState<string>('');\n  const [transactionStatus, setTransactionStatus] = useState<string>('');\n  const [guardianPDA, setGuardianPDA] = useState<PublicKey | null>(null);\n  const [isLoadingBalance, setIsLoadingBalance] = useState<boolean>(false);\n  const [credentialId, setCredentialId] = useState<string>('');\n  const [webauthnPubkey, setWebauthnPubkey] = useState<string>('');\n  const [walletName, setWalletName] = useState<string>('My Moon Wallet');\n  const [isUsingTempWallet, setIsUsingTempWallet] = useState<boolean>(false);\n  // Thêm state cho new guardian\n  const [newGuardianName, setNewGuardianName] = useState<string>('');\n  const [newRecoveryPhrase, setNewRecoveryPhrase] = useState<string>('');\n  const [existingGuardians, setExistingGuardians] = useState<number[]>([]);  // Lưu các guardian ID đã tồn tại\n  const [showAddGuardianForm, setShowAddGuardianForm] = useState<boolean>(false);\n  // Thêm state cho fee payer của dự án\n  const [projectFeePayerKeypair, setProjectFeePayerKeypair] = useState<Keypair | null>(null);\n  const [usingProjectFeePayer, setUsingProjectFeePayer] = useState<boolean>(true);\n  const [feePayerBalance, setFeePayerBalance] = useState<number>(0);\n  const [isLoadingFeePayerBalance, setIsLoadingFeePayerBalance] = useState<boolean>(false);\n  // Thêm state cho số dư PDA\n  const [pdaBalance, setPdaBalance] = useState<number>(0);\n  const [isLoadingPdaBalance, setIsLoadingPdaBalance] = useState<boolean>(false);\n  // Thêm state cho việc chọn guardian ID\n  const [selectedGuardianId, setSelectedGuardianId] = useState<number>(1);\n  // State cho form nạp tiền\n  const [depositAmount, setDepositAmount] = useState<number>(0.1);\n  // State cho form rút tiền\n  const [withdrawAmount, setWithdrawAmount] = useState<number>(0.05);\n  const [recipientAddress, setRecipientAddress] = useState<string>('');\n  // State cho form đăng nhập ví\n  const [loginCredentialId, setLoginCredentialId] = useState<string>('');\n  const [isLoggingIn, setIsLoggingIn] = useState<boolean>(false);\n  const [isLoggedIn, setIsLoggedIn] = useState<boolean>(false);\n  const [showLoginForm, setShowLoginForm] = useState<boolean>(false);\n  \n  // Thêm state cho chức năng tạo invitation\n  const [inviteLink, setInviteLink] = useState<string>('');\n  const [inviteCode, setInviteCode] = useState<string>('');\n  const [showQRCode, setShowQRCode] = useState<boolean>(false);\n  const [showInviteInput, setShowInviteInput] = useState<boolean>(false);\n  const [pendingInvites, setPendingInvites] = useState<string[]>([]);\n  \n  // Thêm state cho màn hình Transfer\n  const [showTransferScreen, setShowTransferScreen] = useState<boolean>(false);\n  const [isProcessingTransfer, setIsProcessingTransfer] = useState<boolean>(false);\n\n  // Tạo keypair mới khi component được mount\n  useEffect(() => {\n    // Tạo keypair ngẫu nhiên mới cho user\n    const newKeypair = Keypair.generate();\n    setWalletKeypair(newKeypair);\n    \n    // Tạo keypair cố định cho dự án để trả phí\n    // Trong môi trường thực tế, bạn có thể lấy keypair này từ server hoặc một nguồn an toàn\n    const projectPayerPrivateKey = convertSecretKeyStringToUint8Array(process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\n    \n    // Sử dụng keypair cố định cho fee payer\n    const feePayerKeypair = Keypair.fromSecretKey(projectPayerPrivateKey);\n    setProjectFeePayerKeypair(feePayerKeypair);\n    \n    // Load balance cho fee payer\n    loadFeePayerBalance(feePayerKeypair);\n    \n    // Không tính PDA ngay vì chưa có credential ID\n    // findMultisigAddress sẽ được gọi sau khi người dùng tạo WebAuthn credential\n  }, []);\n\n  // Thêm hàm để load balance của fee payer\n  const loadFeePayerBalance = async (keypair: Keypair) => {\n    try {\n      setIsLoadingFeePayerBalance(true);\n      const balance = await connection.getBalance(keypair.publicKey);\n      console.log(`Fee payer balance: ${balance / 1_000_000_000} SOL`);\n      \n      // Nếu balance quá thấp, có thể gửi thông báo cảnh báo\n      if (balance < 100_000_000) { // dưới 0.1 SOL\n        console.warn(\"Fee payer balance thấp, cần nạp thêm SOL\");\n      }\n      \n      setFeePayerBalance(balance / 1_000_000_000);\n    } catch (error) {\n      console.error(\"Lỗi khi load balance của fee payer:\", error);\n    } finally {\n      setIsLoadingFeePayerBalance(false);\n    }\n  };\n\n  // Sử dụng ví tạm thời đã có SOL\n  const useTempWallet = async () => {\n    try {\n      setTransactionStatus('Đang tải ví tạm thời với SOL...');\n      \n      // Sử dụng cùng secret key của fee payer\n      const tempWalletPrivateKey = convertSecretKeyStringToUint8Array(process.env.REACT_APP_FEE_PAYER_SECRET_KEY);\n      \n      // Tạo Keypair từ private key\n      const keypair = Keypair.fromSecretKey(tempWalletPrivateKey);\n      \n      setWalletKeypair(keypair);\n      setIsUsingTempWallet(true);\n      \n      // Tính PDA mới dựa trên keypair mới\n      findMultisigAddress();\n      \n      // Tải balance của ví tạm thời\n      await loadBalance(keypair);\n      \n      setTransactionStatus(`Đã chuyển sang ví tạm thời: ${keypair.publicKey.toString()}. Ví này đã có sẵn SOL để giao dịch.`);\n    } catch (error: any) {\n      console.error('Lỗi khi tải ví tạm thời:', error);\n      setTransactionStatus(`Lỗi khi tải ví tạm thời: ${error.message}`);\n    }\n  };\n\n  // Tải balance với xử lý lỗi tốt hơn\n  const loadBalance = async (keypair?: Keypair) => {\n    const publicKey = keypair?.publicKey || walletKeypair?.publicKey;\n    if (!publicKey) return;\n    \n    setIsLoadingBalance(true);\n    try {\n      console.log(\"Đang tải balance cho địa chỉ:\", publicKey.toString());\n      const balance = await connection.getBalance(publicKey);\n      console.log(\"Balance đã tải thành công:\", balance / 1_000_000_000);\n      setWalletBalance(balance / 1_000_000_000); // Chuyển từ lamports sang SOL\n    } catch (error: any) {\n      console.error('Lỗi khi tải balance:', error);\n      // Không hiển thị lỗi cho người dùng, chỉ log ra console\n    } finally {\n      setIsLoadingBalance(false);\n    }\n  };\n\n  // Tạo ví với WebAuthn\n  const createWalletWithWebAuthn = async () => {\n    try {\n      // Kiểm tra xem người dùng đã nhập recovery phrase chưa\n      if (!recoveryPhrase || recoveryPhrase.trim().length < 8) {\n        setTransactionStatus('Vui lòng nhập recovery phrase (ít nhất 8 ký tự) trước khi tạo ví');\n        return;\n      }\n      \n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n      \n      setTransactionStatus('Đang tạo ví Moon Wallet...\\n\\nBước 1: Đang tạo khóa WebAuthn...');\n      \n      // 1. Tạo khóa WebAuthn\n      const walletAddress = projectFeePayerKeypair.publicKey.toString(); // Sử dụng địa chỉ của fee payer\n      const result = await createWebAuthnCredential(walletAddress, walletName);\n      \n      // Chuyển đổi rawId thành base64 để lưu trữ và sử dụng\n      const rawIdBase64 = Buffer.from(result.rawId).toString('base64');\n      \n      // Lưu thông tin WebAuthn\n      setCredentialId(rawIdBase64); // Lưu base64 thay vì hex\n      setWebauthnPubkey(result.publicKey);\n      \n      setTransactionStatus(prev => prev + `\\nĐã tạo khóa WebAuthn thành công!\\nCredential ID (base64): ${rawIdBase64.slice(0, 10)}...\\nPublic Key: ${result.publicKey.slice(0, 10)}...`);\n      \n      // 2. Tính PDA cho Multisig\n      const multisigPDA = getMultisigPDA(rawIdBase64);\n      console.log(\"Multisig PDA:\", multisigPDA.toString());\n      \n      setMultisigAddress(multisigPDA);\n      setTransactionStatus(prev => prev + `\\n\\nBước 2: Đang khởi tạo ví multisig tại địa chỉ: ${multisigPDA.toString()}...`);\n      \n      // Kiểm tra xem multisig account đã tồn tại chưa\n      const existingAccount = await connection.getAccountInfo(multisigPDA);\n      if (existingAccount) {\n        setTransactionStatus(prev => prev + `\\n\\nLỖI: Ví multisig với credential ID này đã tồn tại. Điều này gần như không thể xảy ra vì credential ID luôn duy nhất.`);\n        return;\n      }\n      \n      // 3. Tính PDA address cho guardian\n      // Tạo ID dạng u64 cho guardian\n      const guardianId = BigInt(1); // Owner có ID = 1\n\n      // Chuyển đổi guardianId sang bytes (little-endian)\n      const guardianIdBytes = bigIntToLeBytes(guardianId);\n      \n      const [guardianPDAAddress] = PublicKey.findProgramAddressSync(\n        [\n          Buffer.from(\"guardian\").subarray(0),\n          multisigPDA.toBuffer(),\n          guardianIdBytes\n        ],\n        PROGRAM_ID\n      );\n      \n      setGuardianPDA(guardianPDAAddress);\n      \n      // 4. Tạo transaction tích hợp để khởi tạo multisig và thêm guardian owner\n      const transaction = new Transaction();\n      \n      // 4.1 Khởi tạo Multisig\n      // Đây là discriminator cho initialize_multisig (sử dụng giá trị chính xác từ Anchor IDL)\n      const initMultisigDiscriminator = new Uint8Array([220, 130, 117, 21, 27, 227, 78, 213]);\n      const thresholdBytes = new Uint8Array([threshold]);\n      \n      // LƯU Ý QUAN TRỌNG: credential_id trong smart contract sử dụng as_bytes() trực tiếp, \n      // nên chúng ta phải gửi chính xác chuỗi rawIdBase64 như một chuỗi UTF-8\n      // không phải decode nó sang dạng binary\n      const credentialIdString = rawIdBase64;\n      const credentialIdBuffer = Buffer.from(credentialIdString);\n      console.log(\"Credential ID gửi đi (chuỗi gốc):\", credentialIdString);\n      \n      const credentialIdLenBuffer = Buffer.alloc(4);\n      credentialIdLenBuffer.writeUInt32LE(credentialIdBuffer.length, 0);\n      const credentialIdLenBytes = bufferToUint8Array(credentialIdLenBuffer);\n      const credentialIdDataBytes = bufferToUint8Array(credentialIdBuffer);\n      \n      // Tạo dữ liệu instruction theo đúng cấu trúc contract yêu cầu\n      const initData = concatUint8Arrays(\n        initMultisigDiscriminator,\n        thresholdBytes,\n        credentialIdLenBytes,\n        credentialIdDataBytes\n      );\n      \n      // Thêm instruction khởi tạo multisig vào transaction\n      transaction.add(new TransactionInstruction({\n        keys: [\n          { pubkey: multisigPDA, isSigner: false, isWritable: true },\n          { pubkey: projectFeePayerKeypair.publicKey, isSigner: true, isWritable: true },\n          { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n        ],\n        programId: PROGRAM_ID,\n        data: Buffer.from(initData)\n      }));\n      \n      // Sign và gửi transaction\n      transaction.feePayer = projectFeePayerKeypair.publicKey;\n      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      \n      // Thông báo cho người dùng\n      setTransactionStatus(prev => prev + '\\nĐang gửi transaction để khởi tạo ví và thêm guardian owner...');\n      \n      // Log dữ liệu transaction để debug\n      console.log(\"Transaction data:\", {\n        instructions: transaction.instructions.map((ix, index) => ({\n          programId: ix.programId.toString(),\n          keys: ix.keys.map(k => ({\n            pubkey: k.pubkey.toString(),\n            isSigner: k.isSigner,\n            isWritable: k.isWritable\n          })),\n          data: index === 1 ? {\n            discriminator: Array.from(initMultisigDiscriminator),\n            threshold: threshold,\n            credentialIdLength: credentialIdBuffer.length,\n            credentialId: Array.from(credentialIdBuffer),\n            isOwner: true,\n            hasWebauthn: true,\n            webauthnPubkeyLength: result.publicKey.length\n          } : \"initMultisig\"\n        }))\n      });\n      \n      const signature = await connection.sendTransaction(\n        transaction,\n        [projectFeePayerKeypair]\n      );\n      \n      await connection.confirmTransaction(signature);\n      setTransactionStatus(prev => prev + `\\nVí multisig đã được khởi tạo thành công! Signature: ${signature}`);\n      \n      // 5. Thêm guardian đầu tiên (owner)\n      setTransactionStatus(prev => prev + '\\n\\nBước 3: Đang thêm guardian owner đầu tiên...');\n\n      try {\n        // Tính PDA cho guardian\n        const guardianId = BigInt(1); // Owner có ID = 1\n        const guardianIdBytes = bigIntToLeBytes(guardianId);\n        \n        // 5.1 Tính PDA cho multisig với credential_id\n        const guardianMultisigPDA = multisigPDA;\n        \n        console.log(\"Sử dụng PDA cho guardian với multisig PDA:\", guardianMultisigPDA.toString());\n        \n        // 5.2 Tính PDA cho guardian\n        const guardianPDA = getGuardianPDA(guardianMultisigPDA, 1); // Owner có ID = 1\n        \n        setGuardianPDA(guardianPDA);\n        \n        // Hash recovery phrase tại frontend\n        console.log(\"Recovery phrase gốc:\", recoveryPhrase);\n        const hashedRecoveryBytes = await hashRecoveryPhrase(recoveryPhrase);\n        console.log(\"Recovery phrase sau khi hash tại frontend:\", Buffer.from(hashedRecoveryBytes).toString('hex'));\n        \n        // Tạo discriminator cho add_guardian\n        const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n        \n        // Chuyển guardian ID thành bytes\n        const guardianIdBigIntBytes = bigIntToLeBytes(guardianId);\n        \n        // Chuẩn bị tên guardian\n        const guardianNameBuffer = Buffer.from(guardianName || 'Owner');\n        const guardianNameLenBuffer = Buffer.alloc(4);\n        guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n        \n        // Chuẩn bị recovery hash - sử dụng giá trị đã hash\n        const recoveryHashIntermediateBytes = hashedRecoveryBytes;\n        \n        // Chuẩn bị các tham số khác\n        const isOwnerByte = new Uint8Array([1]); // true = 1\n        \n        // WebAuthn pubkey - nén khóa từ 65 bytes (uncompressed) thành 33 bytes (compressed)\n        // Smart contract yêu cầu webauthn_pubkey: Option<[u8; 33]>\n        const uncompressedKeyBuffer = Buffer.from(result.publicKey, 'hex');\n        console.log(\"WebAuthn key (uncompressed, 65 bytes):\", result.publicKey);\n        \n        // Nén khóa thành 33 bytes\n        const compressedKeyBuffer = compressPublicKey(uncompressedKeyBuffer);\n        console.log(\"WebAuthn key (compressed, 33 bytes):\", compressedKeyBuffer.toString('hex'));\n        \n        // Nối tất cả lại với nhau\n        const addGuardianData = concatUint8Arrays(\n          addGuardianDiscriminator,\n          // guardian_id (u64)\n          bufferToUint8Array(Buffer.from(guardianIdBigIntBytes)),\n          // guardian_name (string)\n          bufferToUint8Array(guardianNameLenBuffer),\n          bufferToUint8Array(guardianNameBuffer),\n          // recovery_hash_intermediate ([u8; 32])\n          recoveryHashIntermediateBytes,\n          // is_owner (bool)\n          isOwnerByte,\n          // webauthn_pubkey (Option<[u8; 33]>)\n          new Uint8Array([1]), // Some variant\n          bufferToUint8Array(compressedKeyBuffer) // Sử dụng khóa đã được nén\n        );\n        \n        // Tạo transaction add guardian\n        const addGuardianTransaction = new Transaction();\n        addGuardianTransaction.add(\n          new TransactionInstruction({\n            keys: [\n              { pubkey: multisigPDA, isSigner: false, isWritable: true },\n              { pubkey: guardianPDA, isSigner: false, isWritable: true },\n              { pubkey: projectFeePayerKeypair.publicKey, isSigner: false, isWritable: false },\n              { pubkey: projectFeePayerKeypair.publicKey, isSigner: true, isWritable: true },\n              { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n            ],\n            programId: PROGRAM_ID,\n            data: Buffer.from(addGuardianData)\n          })\n        );\n        \n        // Sign và gửi transaction\n        addGuardianTransaction.feePayer = projectFeePayerKeypair.publicKey;\n        addGuardianTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n        \n        const addGuardianSignature = await connection.sendTransaction(\n          addGuardianTransaction,\n          [projectFeePayerKeypair]\n        );\n        \n        await connection.confirmTransaction(addGuardianSignature);\n        setTransactionStatus(prev => prev + `\\nGuardian owner đã được thêm thành công! Signature: ${addGuardianSignature}`);\n      } catch (error: any) {\n        console.error(\"Lỗi khi thêm guardian owner:\", error);\n        setTransactionStatus(prev => prev + `\\nLỗi khi thêm guardian owner: ${error.message}`);\n      }\n      \n      // 6. Hoàn thành quá trình tạo ví\n      setTransactionStatus(prev => prev + '\\n\\n✅ VÍ MOON WALLET ĐÃ ĐƯỢC TẠO THÀNH CÔNG!\\n' +\n        `Địa chỉ ví Multisig: ${multisigPDA.toString()}\\n` +\n        `Recovery Phrase: ${recoveryPhrase}\\n` +\n        'Vui lòng lưu lại thông tin này để sử dụng sau này!');\n      \n      // Kiểm tra số dư của ví PDA sau khi tạo\n      await loadPdaBalance(multisigPDA);\n      \n    } catch (error: any) {\n      console.error('Lỗi trong quá trình tạo ví:', error);\n      setTransactionStatus(`Lỗi: ${error.message}`);\n    }\n  };\n\n  // Sửa lại hàm tính PDA cho multisig wallet\n  const findMultisigAddress = async () => {\n    // Sử dụng credential ID (nếu có) hoặc một giá trị tạm thời nếu chưa có\n    if (!credentialId) {\n      // Nếu chưa có credential ID, không thể tính PDA chính xác\n      setMultisigAddress(null);\n      return;\n    }\n    \n    console.log(\"findMultisigAddress - credential ID:\", credentialId);\n    \n    // Sử dụng helper function để tính PDA một cách nhất quán\n    const [pda, bump] = await calculateMultisigAddress(PROGRAM_ID, credentialId);\n    console.log(\"findMultisigAddress - PDA:\", pda.toString(), \"bump:\", bump);\n    \n    setMultisigAddress(pda);\n    \n    // Load balance cho PDA\n    await loadPdaBalance(pda);\n  };\n\n  // Tải balance với xử lý lỗi tốt hơn\n  const loadPdaBalance = async (pdaAddress: PublicKey) => {\n    try {\n      setIsLoadingPdaBalance(true);\n      const balance = await connection.getBalance(pdaAddress);\n      console.log(`PDA balance: ${balance / 1_000_000_000} SOL`);\n      setPdaBalance(balance / 1_000_000_000);\n    } catch (error) {\n      console.error(\"Lỗi khi load balance của PDA:\", error);\n    } finally {\n      setIsLoadingPdaBalance(false);\n    }\n  };\n\n  // Tính PDA address cho guardian\n  const findGuardianAddress = async (guardianId: number = 1) => {\n    if (!multisigAddress) return null;\n    \n    try {\n      // Chuyển đổi guardianId sang bytes (little-endian)\n      const guardianIdBigInt = BigInt(guardianId);\n      const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n      \n      // Tính PDA cho guardian trực tiếp từ multisigAddress\n      const [guardianPDA] = PublicKey.findProgramAddressSync(\n        [\n          Buffer.from(\"guardian\"),\n          multisigAddress.toBuffer(),\n          guardianIdBytes\n        ],\n        PROGRAM_ID\n      );\n      \n      console.log(`Tính PDA cho guardian ID ${guardianId} với multisig: ${multisigAddress.toString()}`);\n      console.log(`Guardian PDA: ${guardianPDA.toString()}`);\n      \n      if (guardianId === 1) {\n        setGuardianPDA(guardianPDA); // Chỉ set state cho guardian chính (ID=1)\n      }\n      return guardianPDA;\n    } catch (error) {\n      console.error(`Lỗi khi tính PDA cho guardian ID ${guardianId}:`, error);\n      return null;\n    }\n  };\n\n  // Airdrop SOL cho testing\n  const requestAirdrop = async () => {\n    if (!projectFeePayerKeypair) {\n      setTransactionStatus('Không tìm thấy fee payer của dự án.');\n      return;\n    }\n    \n    try {\n      setTransactionStatus('Đang yêu cầu airdrop cho fee payer của dự án...');\n      const signature = await connection.requestAirdrop(\n        projectFeePayerKeypair.publicKey,\n        2_000_000_000 // 2 SOL\n      );\n      \n      await connection.confirmTransaction(signature);\n      // Tải lại số dư của fee payer\n      await loadFeePayerBalance(projectFeePayerKeypair);\n      setTransactionStatus('Airdrop thành công! 2 SOL đã được thêm vào ví fee payer của dự án.');\n    } catch (error: any) {\n      console.error('Lỗi khi thực hiện airdrop:', error);\n      setTransactionStatus(`Lỗi airdrop: ${error.message}. Đang thử phương thức chuyển tiền trực tiếp...`);\n      \n      // Thử phương pháp khác nếu airdrop thất bại\n      fundFromValidator(projectFeePayerKeypair);\n    }\n  };\n\n  // Chuyển tiền từ validator wallet sang ví người dùng \n  const fundFromValidator = async (keypair: Keypair) => {\n    try {\n      setTransactionStatus('Đang chuyển tiền từ validator vào fee payer...');\n      \n      // Tạo kết nối với validator wallet (địa chỉ mặc định của validator)\n      const validatorKey = new PublicKey('E6mJJmCvg4PDhanmaBxxeyTczza9vKpMgirRUD6Qz5kv');\n      \n      // Tạo transaction chuyển tiền\n      const transaction = new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: validatorKey,\n          toPubkey: keypair.publicKey,\n          lamports: 2_000_000_000 // 2 SOL\n        })\n      );\n      \n      // Lấy các thông tin cần thiết cho transaction\n      transaction.feePayer = validatorKey;\n      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      \n      // Không thể ký transaction vì không có private key của validator\n      // Thay vào đó, sử dụng phương thức sendTransactionWithRetry không cần chữ ký\n      const signature = await connection.sendTransaction(\n        transaction,\n        [] // Không cần signers khi gửi đến validator local\n      );\n      \n      await connection.confirmTransaction(signature);\n      \n      // Tải lại số dư\n      if (keypair === projectFeePayerKeypair) {\n        await loadFeePayerBalance(keypair);\n        setTransactionStatus('Chuyển tiền thành công! 2 SOL đã được thêm vào ví fee payer của dự án.');\n      } else {\n        await loadBalance(keypair);\n        setTransactionStatus('Chuyển tiền thành công! 2 SOL đã được thêm vào ví.');\n      }\n    } catch (error: any) {\n      console.error('Lỗi khi chuyển tiền từ validator:', error);\n      setTransactionStatus(`Lỗi khi chuyển tiền: ${error.message}. Hãy thử khởi động lại validator.`);\n    }\n  };\n\n  // Xem thông tin wallet\n  const getWalletInfo = async () => {\n    if (!multisigAddress) return;\n    \n    try {\n      setTransactionStatus('Đang truy vấn thông tin ví...');\n      \n      // Load balance trước\n      await loadPdaBalance(multisigAddress);\n      \n      const multisigAccount = await connection.getAccountInfo(multisigAddress);\n      \n      if (!multisigAccount) {\n        setTransactionStatus('Ví chưa được khởi tạo');\n        return;\n      }\n      \n      // Bỏ qua 8 byte discriminator\n      const data = multisigAccount.data.slice(8);\n      \n      // Parse dữ liệu dựa trên struct MultiSigWallet mới\n      // MultiSigWallet: threshold, guardian_count, recovery_nonce, bump, transaction_nonce, last_transaction_timestamp\n      const threshold = data[0];\n      const guardian_count = data[1];\n      const recovery_nonce = new DataView(data.buffer, data.byteOffset + 2, 8).getBigUint64(0, true);\n      const bump = data[10];\n      const transaction_nonce = new DataView(data.buffer, data.byteOffset + 11, 8).getBigUint64(0, true);\n      const last_transaction_timestamp = new DataView(data.buffer, data.byteOffset + 19, 8).getBigInt64(0, true);\n      \n      // Hiển thị thông tin\n      setTransactionStatus(\n        `Thông tin ví:\\n` +\n        `- Threshold: ${threshold}\\n` +\n        `- Guardian Count: ${guardian_count}\\n` +\n        `- Recovery Nonce: ${recovery_nonce}\\n` +\n        `- Bump: ${bump}\\n` +\n        `- Transaction Nonce: ${transaction_nonce}\\n` +\n        `- Last Transaction Timestamp: ${last_transaction_timestamp}`\n      );\n    } catch (error: any) {\n      console.error('Lỗi khi truy vấn thông tin ví:', error);\n      setTransactionStatus(`Lỗi: ${error.message}`);\n    }\n  };\n  \n  // Xem thông tin guardian\n  const getGuardianInfo = async () => {\n    if (!multisigAddress) {\n      setTransactionStatus('Vui lòng tạo ví trước khi xem thông tin guardian');\n      return;\n    }\n    \n    try {\n      setTransactionStatus(`Đang truy vấn thông tin guardian ID=${selectedGuardianId}...`);\n      \n      // Tính guardian PDA dựa trên ID được chọn\n      const guardianPDA = await findGuardianAddress(selectedGuardianId);\n      \n      if (!guardianPDA) {\n        setTransactionStatus('Không thể tìm thấy địa chỉ Guardian');\n        return;\n      }\n      \n      console.log(`Đang truy vấn thông tin guardian ID=${selectedGuardianId} với PDA: ${guardianPDA.toString()}`);\n      const guardianAccount = await connection.getAccountInfo(guardianPDA);\n      \n      if (!guardianAccount) {\n        console.log(`Không tìm thấy thông tin account tại địa chỉ: ${guardianPDA.toString()}`);\n        setTransactionStatus(`Guardian với ID=${selectedGuardianId} chưa được khởi tạo hoặc không tồn tại`);\n        return;\n      }\n      \n      console.log(`Đã tìm thấy account tại địa chỉ: ${guardianPDA.toString()}`);\n      console.log(`Data size: ${guardianAccount.data.length} bytes`);\n      console.log(`Owner: ${guardianAccount.owner.toString()}`);\n      \n      // Kiểm tra xem account có thuộc về program của chúng ta không\n      if (!guardianAccount.owner.equals(PROGRAM_ID)) {\n        console.error(`Account không thuộc về program của chúng ta. Owner: ${guardianAccount.owner.toString()}`);\n        setTransactionStatus(`Guardian với ID=${selectedGuardianId} không thuộc về program của chúng ta`);\n        return;\n      }\n      \n      // Bỏ qua 8 byte discriminator\n      const data = guardianAccount.data.slice(8);\n      console.log(`Data sau khi bỏ qua discriminator: ${data.length} bytes`);\n      console.log(`Raw data: ${Buffer.from(data).toString('hex').substring(0, 100)}...`);\n      \n      try {\n        // Parse dữ liệu dựa trên struct Guardian\n        // Guardian struct trên Rust: \n        // pub struct Guardian {\n        //     pub wallet: Pubkey,                  // 32 bytes\n        //     pub guardian_id: u64,                // 8 bytes\n        //     pub name: String,                    // 4 bytes length + n bytes string\n        //     pub is_active: bool,                 // 1 byte\n        //     pub recovery_hash_intermediate: [u8; 32], // 32 bytes\n        //     pub is_owner: bool,                  // 1 byte\n        //     pub webauthn_pubkey: Option<[u8; 33]>, // 1 byte discriminator + 33 bytes if Some\n        //     pub bump: u8,                        // 1 byte\n        // }\n        \n        // Đọc wallet address (32 bytes)\n        const walletBytes = data.slice(0, 32);\n        const wallet = new PublicKey(walletBytes);\n        console.log(`Wallet address parsed: ${wallet.toString()}`);\n        \n        // Đọc guardian_id (8 bytes - u64)\n        const guardianIdBytes = data.slice(32, 40);\n        let guardianId = BigInt(0);\n        for (let i = 0; i < 8; i++) {\n          guardianId |= BigInt(guardianIdBytes[i]) << BigInt(8 * i);\n        }\n        console.log(`Guardian ID parsed: ${guardianId}`);\n        \n        // Đọc name (string dài tối đa 32 bytes)\n        const nameLength = new DataView(data.buffer, data.byteOffset + 40, 4).getUint32(0, true);\n        console.log(`Guardian name length: ${nameLength}`);\n        \n        if (nameLength > 100) {\n          console.error(`Name length quá lớn: ${nameLength}, có thể không đúng cấu trúc dữ liệu`);\n          throw new Error(\"Lỗi parse dữ liệu guardian: Name length không hợp lệ\");\n        }\n        \n        // Vị trí bắt đầu của name bytes\n        const nameOffset = 44;\n        const nameBytes = data.slice(nameOffset, nameOffset + nameLength);\n        const name = new TextDecoder().decode(nameBytes);\n        console.log(`Guardian name parsed: ${name}`);\n        \n        // Vị trí tiếp theo sau name\n        let currentOffset = nameOffset + nameLength;\n        \n        // Đọc is_active (1 byte)\n        const isActive = data[currentOffset] === 1;\n        console.log(`Is active byte: ${data[currentOffset]} (offset: ${currentOffset})`);\n        currentOffset += 1;\n        \n        // Đọc recovery_hash (32 bytes)\n        const recoveryHash = data.slice(currentOffset, currentOffset + 32);\n        const recoveryHashHex = Buffer.from(recoveryHash).toString('hex');\n        console.log(`Recovery hash (hex): ${recoveryHashHex} (offset: ${currentOffset})`);\n        currentOffset += 32;\n        \n        // Đọc is_owner (1 byte)\n        const isOwner = data[currentOffset] === 1;\n        console.log(`Is owner byte: ${data[currentOffset]} (offset: ${currentOffset})`);\n        currentOffset += 1;\n        \n        // Đọc webauthn_pubkey (option, 1 byte discriminator + 33 bytes if Some)\n        const hasWebauthn = data[currentOffset] === 1;\n        console.log(`Has webauthn byte: ${data[currentOffset]} (offset: ${currentOffset})`);\n        currentOffset += 1;\n        \n        let webauthnPubkey = null;\n        if (hasWebauthn) {\n          webauthnPubkey = data.slice(currentOffset, currentOffset + 33);\n          const webauthnHex = Buffer.from(webauthnPubkey).toString('hex');\n          console.log(`WebAuthn pubkey: ${webauthnHex} (offset: ${currentOffset})`);\n          // Log thêm thông tin về format của key\n          console.log(`WebAuthn key format byte: 0x${webauthnHex.slice(0, 2)} (${webauthnPubkey[0]})`);\n          currentOffset += 33;\n        }\n        \n        // Đọc bump (1 byte)\n        const bump = data[currentOffset];\n        console.log(`Bump: ${bump} (offset: ${currentOffset})`);\n        \n        // Hiển thị thông tin\n        setTransactionStatus(\n          `Thông tin Guardian (ID=${guardianId}):\\n` +\n          `- Loại Guardian: ${isOwner ? 'Owner (Quản trị viên)' : 'Regular (Thành viên)'}\\n` +\n          `- Wallet: ${wallet.toString()}\\n` +\n          `- Guardian ID: ${guardianId}\\n` +\n          `- Name: ${name}\\n` +\n          `- Active: ${isActive ? 'Có' : 'Không'}\\n` +\n          `- Recovery Hash: ${recoveryHashHex.slice(0, 10)}...${recoveryHashHex.slice(-10)}\\n` +\n          (hasWebauthn ? `- WebAuthn Key: ${Buffer.from(webauthnPubkey!).toString('hex')}\\n` : '') +\n          (hasWebauthn ? `- WebAuthn Key Format: ${webauthnPubkey![0] === 2 ? '02 (even y)' : \n                                                (webauthnPubkey![0] === 3 ? '03 (odd y)' : \n                                                webauthnPubkey![0].toString())}\\n` : '') +\n          (hasWebauthn ? `- Công dụng: ${isOwner ? 'Dùng để ký giao dịch và quản lý ví' : 'Dùng để xác thực từ thiết bị này'}\\n` : '') +\n          `- Bump: ${bump}\\n` +\n          `- PDA: ${guardianPDA.toString()}`\n        );\n      } catch (parseError) {\n        console.error(\"Lỗi khi parse dữ liệu guardian:\", parseError);\n        \n        // Hiển thị thông tin thô nếu không thể parse\n        setTransactionStatus(\n          `Không thể parse dữ liệu guardian chi tiết. Dữ liệu thô:\\n` +\n          `- PDA: ${guardianPDA.toString()}\\n` +\n          `- Data size: ${guardianAccount.data.length} bytes\\n` +\n          `- Raw data: ${Buffer.from(guardianAccount.data).toString('hex').substring(0, 100)}...\\n` +\n          `- Error: ${parseError}`\n        );\n      }\n    } catch (error: any) {\n      console.error('Lỗi khi truy vấn thông tin guardian:', error);\n      setTransactionStatus(`Lỗi: ${error.message}`);\n    }\n  };\n\n  // Hàm để lấy danh sách guardian ID hiện có\n  const getExistingGuardianIds = async () => {\n    if (!multisigAddress) return [];\n    \n    try {\n      setTransactionStatus('Đang kiểm tra danh sách Guardian ID...');\n      \n      const guardianIds: number[] = [];\n      \n      // Kiểm tra guardian từ ID 1 đến 8\n      for (let i = 1; i <= 8; i++) {\n        try {\n          // Tính PDA cho guardian với ID i sử dụng hàm đã sửa\n          const guardianPDA = await findGuardianAddress(i);\n          \n          if (!guardianPDA) {\n            console.log(`Guardian ID ${i}: Không tính được PDA`);\n            continue;\n          }\n          \n          // Kiểm tra xem guardian với ID này có tồn tại không\n          console.log(`Đang kiểm tra Guardian ID ${i} tại địa chỉ: ${guardianPDA.toString()}`);\n          const guardianAccount = await connection.getAccountInfo(guardianPDA);\n          \n          if (guardianAccount) {\n            guardianIds.push(i);\n            console.log(`Guardian ID ${i} đã tồn tại - PDA: ${guardianPDA.toString()}`);\n            console.log(`  - Owner: ${guardianAccount.owner.toString()}`);\n            console.log(`  - Data size: ${guardianAccount.data.length} bytes`);\n            \n            // Kiểm tra discriminator (8 bytes đầu)\n            const discriminator = guardianAccount.data.slice(0, 8);\n            console.log(`  - Discriminator: ${Buffer.from(discriminator).toString('hex')}`);\n          } else {\n            console.log(`Guardian ID ${i}: Account không tồn tại tại địa chỉ ${guardianPDA.toString()}`);\n          }\n        } catch (error) {\n          console.error(`Lỗi khi kiểm tra guardian ID ${i}:`, error);\n        }\n      }\n      \n      console.log(\"Danh sách guardian ID hiện tại:\", guardianIds);\n      \n      // Nếu không có guardian nào, thêm ID 1 vào danh sách để có thể chọn\n      if (guardianIds.length === 0) {\n        guardianIds.push(1);\n        console.log(\"Không tìm thấy guardian nào, thêm ID 1 mặc định vào danh sách\");\n      }\n      \n      setExistingGuardians(guardianIds);\n      \n      // Đảm bảo selectedGuardianId nằm trong danh sách các ID hiện có\n      if (!guardianIds.includes(selectedGuardianId)) {\n        console.log(`Selected Guardian ID ${selectedGuardianId} không tồn tại, chuyển sang ID ${guardianIds[0]}`);\n        setSelectedGuardianId(guardianIds[0]);\n      }\n      \n      setTransactionStatus(`Đã tìm thấy ${guardianIds.length} guardian. IDs: ${guardianIds.join(', ')}`);\n      return guardianIds;\n    } catch (error) {\n      console.error(\"Lỗi khi lấy danh sách guardian:\", error);\n      return [];\n    }\n  };\n  \n  // Hàm sinh guardian ID mới không bị trùng\n  const generateNewGuardianId = (existingIds: number[]) => {\n    // Nếu không có ID nào tồn tại, bắt đầu từ 2 (vì ID 1 thường là owner)\n    if (existingIds.length === 0) return 2;\n    \n    // Tìm ID nhỏ nhất không bị trùng\n    let newId = 1;\n    while (existingIds.includes(newId)) {\n      newId++;\n    }\n    \n    return newId;\n  };\n  \n  // Hàm thêm guardian mới với chữ ký WebAuthn riêng\n  const addNewGuardian = async () => {\n    try {\n      // Kiểm tra xem ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi thêm guardian.');\n        return;\n      }\n      \n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n      \n      // Kiểm tra các trường bắt buộc\n      if (!newGuardianName || !newRecoveryPhrase || newRecoveryPhrase.length < 8) {\n        setTransactionStatus('Vui lòng nhập tên guardian và recovery phrase (ít nhất 8 ký tự).');\n        return;\n      }\n      \n      setTransactionStatus('Đang thêm guardian mới...\\n\\nBước 1: Tạo khóa WebAuthn cho guardian mới...');\n      \n      // Lấy danh sách guardian ID hiện tại\n      const existingIds = await getExistingGuardianIds();\n      \n      // Sinh guardian ID mới không bị trùng\n      const newGuardianId = generateNewGuardianId(existingIds);\n      console.log(\"=== ADD GUARDIAN === Guardian ID mới được sinh:\", newGuardianId);\n      \n      // 1. Tạo khóa WebAuthn cho guardian mới\n      try {\n        // Sử dụng một định danh duy nhất cho khóa mới\n        const guardianIdentifier = `${multisigAddress?.toString()}_guardian_${newGuardianId}`;\n        const webAuthnResult = await createWebAuthnCredential(guardianIdentifier, newGuardianName);\n        \n        // Log thông tin WebAuthn\n        console.log(\"=== ADD GUARDIAN === WebAuthn credential mới đã được tạo:\");\n        console.log(\"=== ADD GUARDIAN === Credential ID:\", webAuthnResult.credentialId);\n        console.log(\"=== ADD GUARDIAN === Public Key:\", webAuthnResult.publicKey);\n        \n        setTransactionStatus(prev => prev + `\\nĐã tạo khóa WebAuthn thành công!`);\n        \n        // 2. Tính PDA cho guardian mới\n        const guardianPDA = await findGuardianAddress(newGuardianId);\n        \n        if (!guardianPDA) {\n          setTransactionStatus('Không thể tính PDA cho guardian mới.');\n          return;\n        }\n        \n        console.log(\"=== ADD GUARDIAN === Guardian PDA mới:\", guardianPDA.toString());\n        \n        // Kiểm tra trước xem guardian account đã tồn tại chưa\n        const existingGuardian = await connection.getAccountInfo(guardianPDA);\n        if (existingGuardian) {\n          console.log(\"=== ADD GUARDIAN === Guardian account đã tồn tại!\", existingGuardian);\n          setTransactionStatus(`Guardian với ID=${newGuardianId} đã tồn tại rồi. Hãy chọn ID khác.`);\n          return;\n        }\n        \n        // 3. Hash recovery phrase\n        const hashedRecoveryBytes = await hashRecoveryPhrase(newRecoveryPhrase);\n        console.log(\"=== ADD GUARDIAN === Recovery phrase sau khi hash:\", Buffer.from(hashedRecoveryBytes).toString('hex'));\n        \n        // 4. Chuyển đổi guardian ID thành bytes (little-endian)\n        const guardianIdBigInt = BigInt(newGuardianId);\n        const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n        \n        // 5. Nén khóa WebAuthn từ 65 bytes (uncompressed) thành 33 bytes (compressed)\n        const uncompressedKeyBuffer = Buffer.from(webAuthnResult.publicKey, 'hex');\n        console.log(\"=== ADD GUARDIAN === WebAuthn key (uncompressed, 65 bytes):\", webAuthnResult.publicKey);\n        \n        // Nén khóa thành 33 bytes\n        const compressedKeyBuffer = compressPublicKey(uncompressedKeyBuffer);\n        console.log(\"=== ADD GUARDIAN === WebAuthn key (compressed, 33 bytes):\", compressedKeyBuffer.toString('hex'));\n        \n        // 6. Tạo discriminator cho add_guardian\n        const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n        \n        // 7. Chuẩn bị tên guardian\n        const guardianNameBuffer = Buffer.from(newGuardianName);\n        const guardianNameLenBuffer = Buffer.alloc(4);\n        guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n        \n        // 8. Đặt is_owner = false vì đây là guardian member, không phải owner\n        const isOwnerByte = new Uint8Array([0]); // false = 0\n        \n        // 9. Cấu hình webauthn_pubkey là Some(compressed_key)\n        const hasWebauthn = new Uint8Array([1]); // Some variant\n        \n        // 10. Tạo dữ liệu instruction\n        const addGuardianData = concatUint8Arrays(\n          addGuardianDiscriminator,\n          // guardian_id (u64)\n          bufferToUint8Array(Buffer.from(guardianIdBytes)),\n          // guardian_name (string)\n          bufferToUint8Array(guardianNameLenBuffer),\n          bufferToUint8Array(guardianNameBuffer),\n          // recovery_hash_intermediate ([u8; 32])\n          hashedRecoveryBytes,\n          // is_owner (bool)\n          isOwnerByte,\n          // webauthn_pubkey (Option<[u8; 33]>) - Some variant + compressed key\n          hasWebauthn,\n          bufferToUint8Array(compressedKeyBuffer)\n        );\n        \n        // Log dữ liệu instruction để debug\n        console.log(\"=== ADD GUARDIAN === Dữ liệu instruction:\", {\n          discriminator: Buffer.from(addGuardianDiscriminator).toString('hex'),\n          guardianId: newGuardianId.toString(),\n          guardianIdBytes: Buffer.from(guardianIdBytes).toString('hex'),\n          nameLength: guardianNameBuffer.length,\n          name: newGuardianName,\n          recoveryHashHex: Buffer.from(hashedRecoveryBytes).toString('hex'),\n          isOwner: false,\n          hasWebauthn: true,\n          webauthnPubkey: compressedKeyBuffer.toString('hex')\n        });\n        \n        setTransactionStatus(prev => prev + `\\n\\nBước 2: Đang thêm guardian vào blockchain...`);\n        \n        // 11. Tạo transaction add guardian\n        const addGuardianTransaction = new Transaction();\n        addGuardianTransaction.add(\n          new TransactionInstruction({\n            keys: [\n              { pubkey: multisigAddress, isSigner: false, isWritable: true },\n              { pubkey: guardianPDA, isSigner: false, isWritable: true },\n              { pubkey: projectFeePayerKeypair.publicKey, isSigner: false, isWritable: false },\n              { pubkey: projectFeePayerKeypair.publicKey, isSigner: true, isWritable: true },\n              { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n            ],\n            programId: PROGRAM_ID,\n            data: Buffer.from(addGuardianData)\n          })\n        );\n        \n        // Sign và gửi transaction với fee payer của dự án\n        addGuardianTransaction.feePayer = projectFeePayerKeypair.publicKey;\n        addGuardianTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n        \n        console.log(\"=== ADD GUARDIAN === Đang gửi transaction...\");\n        const addGuardianSignature = await connection.sendTransaction(\n          addGuardianTransaction,\n          [projectFeePayerKeypair] as Signer[]\n        );\n        \n        console.log(\"=== ADD GUARDIAN === Transaction đã gửi. Signature:\", addGuardianSignature);\n        \n        setTransactionStatus(prev => prev + `\\nĐang xác nhận transaction thêm guardian...`);\n        await connection.confirmTransaction(addGuardianSignature);\n        \n        setTransactionStatus(`Guardian mới đã được thêm thành công với ID: ${newGuardianId}!\\n` +\n          `Chữ ký WebAuthn đã được lưu cho guardian này.\\n` +\n          `Signature: ${addGuardianSignature}`\n        );\n        \n        // Kiểm tra xem guardian đã được thêm thành công chưa\n        console.log(\"=== ADD GUARDIAN === Đang kiểm tra guardian vừa thêm...\");\n        await new Promise(resolve => setTimeout(resolve, 2000)); // Đợi 2 giây\n        \n        const newGuardianAccount = await connection.getAccountInfo(guardianPDA);\n        if (newGuardianAccount) {\n          console.log(\"=== ADD GUARDIAN === Guardian đã được thêm thành công!\");\n          console.log(`=== ADD GUARDIAN === Data size: ${newGuardianAccount.data.length} bytes`);\n          \n          // Kiểm tra discriminator\n          const discriminator = newGuardianAccount.data.slice(0, 8);\n          console.log(`=== ADD GUARDIAN === Discriminator: ${Buffer.from(discriminator).toString('hex')}`);\n        } else {\n          console.log(\"=== ADD GUARDIAN === Guardian không được tìm thấy sau khi thêm!\");\n          setTransactionStatus(prev => prev + '\\n\\nCẢNH BÁO: Guardian có vẻ như chưa được khởi tạo trên blockchain mặc dù transaction đã thành công!');\n        }\n        \n        // Cập nhật danh sách guardian\n        await getExistingGuardianIds();\n        \n        // Cập nhật số dư của ví PDA\n        await loadPdaBalance(multisigAddress);\n        \n        // Reset form\n        setNewGuardianName('');\n        setNewRecoveryPhrase('');\n      } catch (webAuthnError: any) {\n        console.error(\"=== ADD GUARDIAN === Lỗi khi tạo khóa WebAuthn:\", webAuthnError);\n        setTransactionStatus(`Lỗi khi tạo khóa WebAuthn: ${webAuthnError.message || 'Không xác định'}. Vui lòng thử lại.`);\n        return;\n      }\n    } catch (error: any) {\n      console.error(\"=== ADD GUARDIAN === Lỗi khi thêm guardian mới:\", error);\n      setTransactionStatus(`Lỗi khi thêm guardian mới: ${error.message}`);\n    }\n  };\n\n  // Hàm để nạp SOL vào ví multisig\n  const depositToMultisig = async () => {\n    try {\n      // Kiểm tra xem ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi nạp tiền.');\n        return;\n      }\n      \n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n      \n      // Kiểm tra số tiền hợp lệ\n      if (!depositAmount || depositAmount <= 0) {\n        setTransactionStatus('Vui lòng nhập số tiền hợp lệ để nạp.');\n        return;\n      }\n      \n      // Kiểm tra số dư của fee payer\n      const feePayerBalance = await connection.getBalance(projectFeePayerKeypair.publicKey);\n      const lamportsToSend = depositAmount * LAMPORTS_PER_SOL;\n      \n      if (feePayerBalance < lamportsToSend + 5000) { // 5000 lamports cho phí giao dịch\n        setTransactionStatus(`Số dư fee payer không đủ. Hiện tại: ${feePayerBalance / LAMPORTS_PER_SOL} SOL`);\n        return;\n      }\n      \n      setTransactionStatus(`Đang nạp ${depositAmount} SOL vào ví...`);\n      \n      // Tạo transaction chuyển tiền\n      const transaction = new Transaction().add(\n        SystemProgram.transfer({\n          fromPubkey: projectFeePayerKeypair.publicKey,\n          toPubkey: multisigAddress,\n          lamports: lamportsToSend\n        })\n      );\n      \n      // Cấu hình transaction\n      transaction.feePayer = projectFeePayerKeypair.publicKey;\n      transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      \n      // Ký và gửi transaction\n      const signature = await connection.sendTransaction(\n        transaction,\n        [projectFeePayerKeypair]\n      );\n      \n      await connection.confirmTransaction(signature);\n      \n      // Cập nhật số dư\n      await loadPdaBalance(multisigAddress);\n      await loadFeePayerBalance(projectFeePayerKeypair);\n      \n      setTransactionStatus(`Đã nạp thành công ${depositAmount} SOL vào ví! Signature: ${signature}`);\n    } catch (error: any) {\n      console.error('Lỗi khi nạp tiền vào ví:', error);\n      setTransactionStatus(`Lỗi khi nạp tiền: ${error.message}`);\n    }\n  };\n\n  // Hàm để rút tiền từ ví multisig\n  const withdrawFromMultisig = async () => {\n    try {\n      // Kiểm tra xem ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi rút tiền.');\n        return;\n      }\n      \n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n      \n      // Kiểm tra các trường bắt buộc\n      if (!recipientAddress || !withdrawAmount || withdrawAmount <= 0) {\n        setTransactionStatus('Vui lòng nhập địa chỉ người nhận và số tiền hợp lệ.');\n        return;\n      }\n      \n      let recipient: PublicKey;\n      try {\n        recipient = new PublicKey(recipientAddress);\n      } catch (error) {\n        setTransactionStatus('Địa chỉ người nhận không hợp lệ.');\n        return;\n      }\n      \n      // Kiểm tra số dư của ví multisig\n      const multisigBalance = await connection.getBalance(multisigAddress);\n      const lamportsToSend = withdrawAmount * LAMPORTS_PER_SOL;\n      \n      if (multisigBalance < lamportsToSend) {\n        setTransactionStatus(`Số dư ví không đủ. Hiện tại: ${multisigBalance / LAMPORTS_PER_SOL} SOL`);\n        return;\n      }\n      \n      setTransactionStatus(`Đang rút ${withdrawAmount} SOL từ ví...`);\n      \n      // Tạo discriminator cho withdraw\n      const withdrawDiscriminator = new Uint8Array([54, 27, 38, 179, 114, 92, 92, 82]);\n      \n      // Số tiền rút (u64)\n      const amountBigInt = BigInt(Math.floor(withdrawAmount * LAMPORTS_PER_SOL));\n      const amountBytes = bigIntToLeBytes(amountBigInt);\n      \n      // Tạo dữ liệu instruction\n      const withdrawData = concatUint8Arrays(\n        withdrawDiscriminator,\n        // amount (u64)\n        bufferToUint8Array(Buffer.from(amountBytes))\n      );\n      \n      // Tạo transaction rút tiền\n      const withdrawTransaction = new Transaction();\n      withdrawTransaction.add(\n        new TransactionInstruction({\n          keys: [\n            { pubkey: multisigAddress, isSigner: false, isWritable: true },\n            { pubkey: recipient, isSigner: false, isWritable: true },\n            { pubkey: projectFeePayerKeypair.publicKey, isSigner: true, isWritable: true },\n            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n          ],\n          programId: PROGRAM_ID,\n          data: Buffer.from(withdrawData)\n        })\n      );\n      \n      // Sign và gửi transaction\n      withdrawTransaction.feePayer = projectFeePayerKeypair.publicKey;\n      withdrawTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      \n      const withdrawSignature = await connection.sendTransaction(\n        withdrawTransaction,\n        [projectFeePayerKeypair]\n      );\n      \n      await connection.confirmTransaction(withdrawSignature);\n      \n      // Cập nhật số dư\n      await loadPdaBalance(multisigAddress);\n      \n      setTransactionStatus(`Đã rút thành công ${withdrawAmount} SOL từ ví! Signature: ${withdrawSignature}`);\n      \n      // Reset form\n      setWithdrawAmount(0.05);\n      setRecipientAddress('');\n      \n    } catch (error: any) {\n      console.error('Lỗi khi rút tiền từ ví:', error);\n      setTransactionStatus(`Lỗi khi rút tiền: ${error.message}`);\n    }\n  };\n\n  // Tự động cập nhật danh sách guardians khi multisigAddress thay đổi\n  useEffect(() => {\n    if (multisigAddress) {\n      // Load lại danh sách guardian IDs\n      getExistingGuardianIds();\n      \n      // Load số dư của PDA\n      loadPdaBalance(multisigAddress);\n    }\n  }, [multisigAddress]);\n\n  // Hàm để kiểm tra guardian ID cụ thể\n  const testGuardianInfo = async (id: number) => {\n    if (!multisigAddress) {\n      setTransactionStatus('Ví chưa được khởi tạo');\n      return;\n    }\n    \n    setTransactionStatus(`Đang kiểm tra chi tiết Guardian ID ${id}...`);\n    \n    try {\n      // Tính PDA \n      const guardianPDA = await findGuardianAddress(id);\n      if (!guardianPDA) {\n        setTransactionStatus(`Không thể tính PDA cho Guardian ID ${id}`);\n        return;\n      }\n      \n      console.log(`=== TEST === Đang kiểm tra chi tiết Guardian ID ${id} tại ${guardianPDA.toString()}`);\n      \n      const guardianAccount = await connection.getAccountInfo(guardianPDA);\n      if (!guardianAccount) {\n        console.log(`=== TEST === Account không tồn tại tại địa chỉ ${guardianPDA.toString()}`);\n        setTransactionStatus(`Guardian ID ${id} không tồn tại trên blockchain`);\n        return;\n      }\n      \n      console.log(`=== TEST === Account tồn tại!`);\n      console.log(`=== TEST === Owner: ${guardianAccount.owner.toString()}`);\n      console.log(`=== TEST === Data size: ${guardianAccount.data.length} bytes`);\n      \n      // Kiểm tra discriminator\n      const discriminator = guardianAccount.data.slice(0, 8);\n      console.log(`=== TEST === Discriminator: ${Buffer.from(discriminator).toString('hex')}`);\n      \n      // Bỏ qua 8 byte discriminator\n      const data = guardianAccount.data.slice(8);\n      \n      try {\n        // Wallet (32 bytes)\n        const walletBytes = data.slice(0, 32);\n        const wallet = new PublicKey(walletBytes);\n        console.log(`=== TEST === Wallet: ${wallet.toString()}`);\n        \n        // Guardian ID (8 bytes)\n        const guardianIdBytes = data.slice(32, 40);\n        let guardianId = BigInt(0);\n        for (let i = 0; i < 8; i++) {\n          guardianId |= BigInt(guardianIdBytes[i]) << BigInt(8 * i);\n        }\n        console.log(`=== TEST === Guardian ID parsed: ${guardianId}`);\n        \n        // Name\n        const nameLength = new DataView(data.buffer, data.byteOffset + 40, 4).getUint32(0, true);\n        console.log(`=== TEST === Name length: ${nameLength}`);\n        \n        // Nếu name length hợp lệ, tiếp tục parse\n        if (nameLength <= 100) {\n          const nameBytes = data.slice(44, 44 + nameLength);\n          const name = new TextDecoder().decode(nameBytes);\n          console.log(`=== TEST === Name: ${name}`);\n          \n          setTransactionStatus(`Guardian ID ${id} tồn tại!\\n- PDA: ${guardianPDA.toString()}\\n- Wallet: ${wallet.toString()}\\n- Name: ${name}\\n- Guardian ID: ${guardianId}`);\n        } else {\n          console.log(`=== TEST === Name length không hợp lệ`);\n          setTransactionStatus(`Guardian ID ${id} tồn tại nhưng có cấu trúc dữ liệu không hợp lệ`);\n        }\n      } catch (parseError) {\n        console.error(`=== TEST === Lỗi khi parse dữ liệu:`, parseError);\n        setTransactionStatus(`Guardian ID ${id} tồn tại nhưng không thể parse dữ liệu: ${parseError}`);\n      }\n      \n    } catch (error: any) {\n      console.error(`=== TEST === Lỗi:`, error);\n      setTransactionStatus(`Lỗi khi kiểm tra: ${error.message}`);\n    }\n  };\n\n  // Hàm đăng nhập vào ví đã tạo\n  const loginToWallet = async () => {\n    try {\n      setIsLoggingIn(true);\n      setTransactionStatus('Đang đăng nhập vào ví...\\n\\nBước 1: Đang yêu cầu xác thực WebAuthn...');\n      \n      // 1. Yêu cầu người dùng xác thực với thiết bị (không cần nhập credential ID cụ thể)\n      try {\n        // Gọi hàm getWebAuthnAssertionForLogin với allowEmpty=true để cho phép người dùng chọn từ bất kỳ credential nào\n        const assertionResult = await getWebAuthnAssertionForLogin('', true);\n        \n        if (!assertionResult.success || !assertionResult.rawId) {\n          throw new Error(assertionResult.error || 'Không thể xác thực với thiết bị');\n        }\n        \n        // Lấy thông tin credential từ phản hồi\n        const credentialRawData = assertionResult.rawId;\n        \n        // Chuyển rawId thành hex để sử dụng làm key trong bảng webauthn_credentials\n        const credentialIdHex = Buffer.from(credentialRawData).toString('hex');\n        console.log(\"Credential ID (hex):\", credentialIdHex);\n        \n        // Chuyển rawId thành base64 để sử dụng trong blockchain\n        const rawIdBase64 = Buffer.from(credentialRawData).toString('base64');\n        console.log(\"Raw credential ID (base64):\", rawIdBase64);\n        \n        setTransactionStatus(prev => prev + '\\nXác thực WebAuthn thành công!\\n\\nBước 2: Đang tìm thông tin ví...');\n        \n        // 2. Truy vấn thông tin ví từ bảng webauthn_credentials\n        const credentialMapping = await getWalletByCredentialId(credentialIdHex);\n        \n        if (credentialMapping) {\n          // Nếu tìm thấy trong bảng ánh xạ\n          setTransactionStatus(prev => prev + `\\nĐã tìm thấy thông tin ví trong database!`);\n          \n          // Chuyển đổi từ chuỗi sang PublicKey\n          const walletAddressFromDB = new PublicKey(credentialMapping.walletAddress);\n          console.log(\"Wallet address from database:\", walletAddressFromDB.toString());\n          \n          // 3. Kiểm tra xem ví có tồn tại trên blockchain không\n          const walletAccount = await connection.getAccountInfo(walletAddressFromDB);\n          \n          if (!walletAccount) {\n            setTransactionStatus(`Ví tìm thấy trong database không tồn tại trên blockchain. Địa chỉ: ${walletAddressFromDB.toString()}`);\n            setIsLoggingIn(false);\n            return;\n          }\n          \n          // 4. Cập nhật state với thông tin ví\n          setMultisigAddress(walletAddressFromDB);\n          setCredentialId(rawIdBase64); // Lưu credential ID gốc\n          \n          setTransactionStatus(prev => prev + `\\nĐã tìm thấy ví tại địa chỉ: ${walletAddressFromDB.toString()}\\n\\nBước 3: Đang tải thông tin ví...`);\n        } else {\n          // Nếu không tìm thấy trong bảng ánh xạ, sử dụng phương pháp tính toán cũ\n          setTransactionStatus(prev => prev + '\\nKhông tìm thấy thông tin trong database, đang tính toán địa chỉ ví...');\n          \n          // Tính địa chỉ ví từ credential ID\n          const multisigPDA = getMultisigPDA(rawIdBase64);\n          console.log(\"Computed Multisig PDA:\", multisigPDA.toString());\n          \n          // Kiểm tra xem ví có tồn tại không\n          const walletAccount = await connection.getAccountInfo(multisigPDA);\n          \n          if (!walletAccount) {\n            setTransactionStatus(`Không tìm thấy ví với credential này. Có thể bạn cần tạo ví mới.`);\n            setIsLoggingIn(false);\n            return;\n          }\n          \n          setTransactionStatus(prev => prev + `\\nĐã tìm thấy ví tại địa chỉ: ${multisigPDA.toString()}\\n\\nBước 3: Đang tải thông tin ví...`);\n          \n          // Cập nhật state với thông tin ví\n          setMultisigAddress(multisigPDA);\n          setCredentialId(rawIdBase64); // Lưu credential ID gốc\n        }\n        \n        // 5. Tìm guardian PDA\n        await findGuardianAddress(1); // Tìm guardian chính (owner)\n        \n        // 6. Tải số dư và danh sách guardian\n        await loadPdaBalance(multisigAddress!);\n        await getExistingGuardianIds();\n        \n        // 7. Hoàn thành đăng nhập\n        setIsLoggedIn(true);\n        setIsLoggingIn(false);\n        setTransactionStatus(`Đăng nhập thành công!\\n\\nĐịa chỉ ví: ${multisigAddress!.toString()}\\nSố guardian: ${existingGuardians.length}`);\n        \n        // 8. Ẩn form đăng nhập\n        setShowLoginForm(false);\n      } catch (webAuthnError: any) {\n        console.error(\"Lỗi khi xác thực WebAuthn:\", webAuthnError);\n        setTransactionStatus(`Lỗi khi xác thực: ${webAuthnError.message}`);\n        setIsLoggingIn(false);\n      }\n    } catch (error: any) {\n      console.error('Lỗi khi đăng nhập:', error);\n      setTransactionStatus(`Lỗi khi đăng nhập: ${error.message}`);\n      setIsLoggingIn(false);\n    }\n  };\n\n  // Hàm tạo mã mời ngẫu nhiên\n  const generateRandomCode = (length: number): string => {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let result = '';\n    const randomValues = new Uint8Array(length);\n    crypto.getRandomValues(randomValues);\n    for (let i = 0; i < length; i++) {\n      result += chars.charAt(randomValues[i] % chars.length);\n    }\n    return result;\n  };\n\n  // Hàm tạo link mời guardian mới\n  const generateGuardianInvite = async () => {\n    try {\n      // Kiểm tra ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi mời guardian.');\n        return;\n      }\n      \n      // Lấy danh sách guardian ID hiện tại\n      const existingIds = await getExistingGuardianIds();\n      \n      // Sinh guardian ID mới không bị trùng\n      const newGuardianId = generateNewGuardianId(existingIds);\n      \n      // Tạo mã ngẫu nhiên cho link mời\n      const inviteCode = generateRandomCode(8);\n      \n      // Tạo link mời với URL ngrok từ biến môi trường hoặc sử dụng địa chỉ hiện tại\n      const ngrokUrl = process.env.REACT_APP_NGROK_URL || window.location.origin;\n      const inviteLink = `${ngrokUrl}/#/guardian-signup/${inviteCode}`;\n      \n      // Hiển thị link (đặt state trước khi lưu vào Firebase)\n      setInviteCode(inviteCode);\n      setInviteLink(inviteLink);\n      setShowQRCode(true);\n      \n      // Lưu thông tin vào Firebase\n      try {\n        await saveInvitation({\n          multisigAddress: multisigAddress.toString(),\n          guardianId: newGuardianId,\n          inviteCode,\n          status: 'pending',\n          ownerId: projectFeePayerKeypair?.publicKey.toString() || ''\n        });\n      } catch (error) {\n        console.error(\"Lỗi khi lưu vào Firebase:\", error);\n        // Hiển thị lỗi nhưng vẫn tiếp tục hiển thị link mời\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        setTransactionStatus(`Đã tạo link mời guardian: ${inviteLink}\\nLưu ý: Có lỗi khi lưu thông tin: ${errorMessage}`);\n        return inviteLink;\n      }\n      \n      setTransactionStatus(`Đã tạo link mời guardian: ${inviteLink}`);\n      \n      return inviteLink;\n    } catch (error: any) {\n      console.error(\"Lỗi khi tạo link mời guardian:\", error);\n      setTransactionStatus(`Lỗi khi tạo link mời guardian: ${error.message}`);\n      return null;\n    }\n  };\n\n  // Tải danh sách mã mời đang chờ\n  const loadPendingInvites = async () => {\n    try {\n      if (!projectFeePayerKeypair || !multisigAddress) return;\n      \n      const ownerId = projectFeePayerKeypair.publicKey.toString();\n      // Chỉ lọc guardian của chính ví multisig hiện tại\n      const multisigAddressStr = multisigAddress.toString();\n      const invitesList = await getPendingInvites(ownerId, multisigAddressStr);\n      setPendingInvites(invitesList);\n      \n      if (invitesList.length > 0) {\n        console.log(`Tìm thấy ${invitesList.length} guardian đang chờ hoàn tất cho ví ${multisigAddressStr}. Mã mời: ${invitesList.join(', ')}`);\n      }\n    } catch (error) {\n      console.error(\"Lỗi khi tải danh sách mã mời:\", error);\n    }\n  };\n\n  // Load danh sách mã mời khi component được mount và mỗi khi projectFeePayerKeypair hoặc multisigAddress thay đổi\n  useEffect(() => {\n    if (projectFeePayerKeypair && multisigAddress) {\n      loadPendingInvites();\n    }\n  }, [projectFeePayerKeypair, multisigAddress]);\n\n  // Hàm để lấy thông tin guardian đã đăng ký\n  const fetchGuardianDataFromDatabase = async (inviteCode: string) => {\n    try {\n      return await getGuardianData(inviteCode);\n    } catch (error) {\n      console.error(\"Lỗi khi lấy dữ liệu guardian:\", error);\n      return null;\n    }\n  };\n\n  // Hàm để lấy thông tin invitation\n  const fetchInviteFromDatabase = async (inviteCode: string) => {\n    try {\n      return await getInvitation(inviteCode);\n    } catch (error) {\n      console.error(\"Lỗi khi lấy dữ liệu invite:\", error);\n      return null;\n    }\n  };\n\n  // Hàm để cập nhật trạng thái guardian\n  const updateGuardianStatusInDatabase = async (inviteCode: string, status: string, txSignature?: string) => {\n    try {\n      await updateGuardianStatus(inviteCode, status as any, txSignature);\n    } catch (error) {\n      console.error(\"Lỗi khi cập nhật trạng thái guardian:\", error);\n    }\n  };\n\n  // Hàm hoàn tất đăng ký guardian từ dữ liệu đã lưu\n  const completeGuardianRegistration = async (inviteCode: string) => {\n    try {\n      setTransactionStatus('Đang hoàn tất đăng ký guardian...');\n      \n      // 1. Lấy dữ liệu guardian từ localStorage\n      const guardianData = await fetchGuardianDataFromDatabase(inviteCode);\n      \n      if (!guardianData) {\n        setTransactionStatus('Không tìm thấy dữ liệu guardian. Vui lòng đảm bảo guardian đã hoàn tất đăng ký.');\n        return;\n      }\n      \n      if (guardianData.status !== 'ready') {\n        setTransactionStatus('Guardian chưa hoàn tất đăng ký.');\n        return;\n      }\n      \n      // 2. Lấy thông tin invite\n      const inviteData = await fetchInviteFromDatabase(inviteCode);\n      \n      if (!inviteData) {\n        setTransactionStatus('Không tìm thấy thông tin mời guardian.');\n        return;\n      }\n      \n      // 3. Tính PDA cho guardian\n      const multisigPDA = new PublicKey(inviteData.multisigAddress);\n      const guardianId = inviteData.guardianId;\n      const guardianPDA = await findGuardianAddress(guardianId);\n      \n      if (!guardianPDA) {\n        setTransactionStatus('Không thể tính PDA cho guardian.');\n        return;\n      }\n      \n      // 4. Chuyển đổi dữ liệu thành format phù hợp\n      const hashedRecoveryBytes = new Uint8Array(guardianData.hashedRecoveryBytes);\n      const compressedKeyBuffer = Buffer.from(guardianData.webauthnPublicKey);\n      \n      // 5. Tạo discriminator cho add_guardian\n      const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n      \n      // 6. Chuyển đổi guardian ID thành bytes (little-endian)\n      const guardianIdBigInt = BigInt(guardianId);\n      const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n      \n      // 7. Chuẩn bị tên guardian\n      const guardianNameBuffer = Buffer.from(guardianData.guardianName);\n      const guardianNameLenBuffer = Buffer.alloc(4);\n      guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n      \n      // 8. Đặt is_owner = false vì đây là guardian member, không phải owner\n      const isOwnerByte = new Uint8Array([0]); // false = 0\n      \n      // 9. Cấu hình webauthn_pubkey là Some(compressed_key)\n      const hasWebauthn = new Uint8Array([1]); // Some variant\n      \n      // 10. Tạo dữ liệu instruction\n      const addGuardianData = concatUint8Arrays(\n        addGuardianDiscriminator,\n        // guardian_id (u64)\n        bufferToUint8Array(Buffer.from(guardianIdBytes)),\n        // guardian_name (string)\n        bufferToUint8Array(guardianNameLenBuffer),\n        bufferToUint8Array(guardianNameBuffer),\n        // recovery_hash_intermediate ([u8; 32])\n        hashedRecoveryBytes,\n        // is_owner (bool)\n        isOwnerByte,\n        // webauthn_pubkey (Option<[u8; 33]>) - Some variant + compressed key\n        hasWebauthn,\n        bufferToUint8Array(Buffer.from(compressedKeyBuffer))\n      );\n      \n      // 11. Tạo transaction add guardian\n      const addGuardianTransaction = new Transaction();\n      addGuardianTransaction.add(\n        new TransactionInstruction({\n          keys: [\n            { pubkey: multisigPDA, isSigner: false, isWritable: true },\n            { pubkey: guardianPDA, isSigner: false, isWritable: true },\n            { pubkey: projectFeePayerKeypair!.publicKey, isSigner: false, isWritable: false },\n            { pubkey: projectFeePayerKeypair!.publicKey, isSigner: true, isWritable: true },\n            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n          ],\n          programId: PROGRAM_ID,\n          data: Buffer.from(addGuardianData)\n        })\n      );\n      \n      // Sign và gửi transaction với fee payer của dự án\n      addGuardianTransaction.feePayer = projectFeePayerKeypair!.publicKey;\n      addGuardianTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      \n      setTransactionStatus(prev => prev + '\\nĐang gửi transaction...');\n      const addGuardianSignature = await connection.sendTransaction(\n        addGuardianTransaction,\n        [projectFeePayerKeypair!] as Signer[]\n      );\n      \n      setTransactionStatus(prev => prev + '\\nĐang xác nhận transaction...');\n      await connection.confirmTransaction(addGuardianSignature);\n      \n      // Cập nhật trạng thái trong DB\n      await updateGuardianStatusInDatabase(inviteCode, 'completed', addGuardianSignature);\n      \n      setTransactionStatus(`Guardian đã được thêm thành công với ID: ${guardianId}!\\n` +\n        `Signature: ${addGuardianSignature}`\n      );\n      \n      // Xóa dữ liệu guardian từ database sau khi hoàn tất\n      setTransactionStatus(prev => prev + '\\n\\nĐang xóa dữ liệu guardian từ database...');\n      console.log(`Bắt đầu xóa dữ liệu guardian với mã mời: ${inviteCode}`);\n      const deleteResult = await deleteGuardianData(inviteCode);\n      \n      if (deleteResult) {\n        console.log(`✅ ĐÃ XÓA THÀNH CÔNG dữ liệu guardian, invitation và lookup với mã mời: ${inviteCode}`);\n        \n        // Cập nhật thông báo thành công rõ ràng hơn\n        setTransactionStatus(`✅ HOÀN TẤT THÀNH CÔNG!\n        \n        Guardian \"${guardianData.guardianName}\" (ID: ${guardianData.guardianId}) đã được thêm thành công vào ví.\n        \n        Địa chỉ Guardian: ${guardianPDA.toString()}\n        Signature: ${addGuardianSignature}\n        \n        ✅ Dữ liệu đã được xóa khỏi database để bảo vệ quyền riêng tư.\n        \n        ✅ Guardian hiện đã sẵn sàng sử dụng và đã được ẩn khỏi danh sách chờ.`);\n        \n        // Bỏ mã mời đã sử dụng khỏi danh sách\n        setPendingInvites(prev => prev.filter(code => code !== inviteCode));\n        \n        // Không đóng form để người dùng có thể tiếp tục thêm guardian khác\n        /* \n        if (pendingInvites.length <= 1) {\n          setShowInviteInput(false);\n        }\n        */\n      } else {\n        console.error(`❌ KHÔNG THỂ XÓA dữ liệu guardian với mã mời: ${inviteCode}`);\n        setTransactionStatus(prev => prev + '\\n❌ Không thể xóa dữ liệu guardian từ database.');\n      }\n      \n      // Cập nhật danh sách guardian và load lại danh sách mã mời\n      await getExistingGuardianIds();\n      await loadPendingInvites();\n      \n      // Cập nhật số dư của ví PDA\n      await loadPdaBalance(multisigPDA);\n    } catch (error: any) {\n      console.error(\"Lỗi khi hoàn tất đăng ký guardian:\", error);\n      setTransactionStatus(`Lỗi khi hoàn tất đăng ký guardian: ${error.message}`);\n    }\n  };\n\n  // Hàm kiểm tra thông tin guardians trong database\n  const checkGuardiansInDatabase = async () => {\n    try {\n      setTransactionStatus('Đang kiểm tra dữ liệu guardians từ Firestore...');\n      \n      if (!projectFeePayerKeypair || !multisigAddress) {\n        setTransactionStatus('Cần có thông tin fee payer và multisig address để kiểm tra.');\n        return;\n      }\n      \n      const ownerId = projectFeePayerKeypair.publicKey.toString();\n      const multisigAddressStr = multisigAddress.toString();\n      \n      // Lấy danh sách invitations đang chờ CHỈ của ví hiện tại\n      const pendingInvites = await getPendingInvites(ownerId, multisigAddressStr);\n      console.log(`Danh sách mã mời đang chờ cho ví ${multisigAddressStr}:`, pendingInvites);\n      \n      if (pendingInvites.length === 0) {\n        setTransactionStatus(`Không tìm thấy mã mời nào đang chờ xử lý cho ví ${multisigAddressStr}.`);\n        return;\n      }\n      \n      // Kiểm tra thông tin từng guardian\n      let resultMessage = 'Thông tin guardians từ database:\\n\\n';\n      \n      for (const inviteCode of pendingInvites) {\n        // Lấy thông tin invitation\n        const inviteData = await getInvitation(inviteCode);\n        if (!inviteData) {\n          resultMessage += `Mã mời ${inviteCode}: Không tìm thấy thông tin invitation.\\n`;\n          continue;\n        }\n        \n        // Lấy thông tin guardian\n        const guardianData = await getGuardianData(inviteCode);\n        if (!guardianData) {\n          resultMessage += `Mã mời ${inviteCode}: Invitation tồn tại nhưng chưa có thông tin guardian.\\n`;\n          continue;\n        }\n        \n        // Hiển thị thông tin\n        resultMessage += `Mã mời: ${inviteCode}\\n`;\n        resultMessage += `Guardian ID: ${guardianData.guardianId}\\n`;\n        resultMessage += `Tên guardian: ${guardianData.guardianName}\\n`;\n        resultMessage += `Trạng thái: ${guardianData.status}\\n`;\n        resultMessage += `WebAuthn ID: ${guardianData.webauthnCredentialId.substring(0, 20)}...\\n\\n`;\n      }\n      \n      setTransactionStatus(resultMessage);\n    } catch (error) {\n      console.error(\"Lỗi khi kiểm tra thông tin guardians:\", error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      setTransactionStatus(`Lỗi khi kiểm tra thông tin guardians: ${errorMessage}`);\n    }\n  };\n\n  // Hoàn tất quá trình đăng ký guardian dựa trên mã mời\n  const completeGuardianSetup = async (inviteCode: string) => {\n    try {\n      setTransactionStatus(`Đang hoàn tất quá trình đăng ký guardian với mã mời: ${inviteCode}...`);\n      \n      // 1. Lấy thông tin guardian\n      const guardianData = await getGuardianData(inviteCode);\n      if (!guardianData) {\n        setTransactionStatus('Không tìm thấy thông tin guardian. Vui lòng đảm bảo guardian đã hoàn tất đăng ký.');\n        return;\n      }\n      \n      if (guardianData.status !== 'ready') {\n        setTransactionStatus(`Guardian có trạng thái không hợp lệ: ${guardianData.status}`);\n        return;\n      }\n      \n      // 2. Thêm guardian vào blockchain\n      setTransactionStatus(prev => prev + '\\n\\nĐang thêm guardian vào blockchain...');\n      \n      // Tạo multisig PDA từ địa chỉ multisig\n      const multisigPubkey = new PublicKey(guardianData.multisigAddress);\n      \n      // Tạo WebAuthn public key từ dữ liệu lưu trữ\n      const webauthnPubkey = Buffer.from(new Uint8Array(guardianData.webauthnPublicKey));\n      \n      // Chuẩn bị dữ liệu guardian\n      const guardianIndex = guardianData.guardianId;\n      const guardianName = guardianData.guardianName;\n      const guardianType = 0; // 0 = Guardian thường\n      const recoveryHash = Uint8Array.from(guardianData.hashedRecoveryBytes);\n      \n      // Thêm guardian vào blockchain\n      if (projectFeePayerKeypair) {\n        // Tạo transaction\n        const tx = new Transaction();\n        \n        // Tìm PDA cho guardian\n        const guardianIdBigInt = BigInt(guardianIndex);\n        const guardianIdBytes = bigIntToLeBytes(guardianIdBigInt);\n        \n        const [guardianPDA] = await PublicKey.findProgramAddress(\n          [\n            Buffer.from(\"guardian\"),\n            multisigPubkey.toBuffer(),\n            guardianIdBytes\n          ],\n          PROGRAM_ID\n        );\n        \n        // Tạo instruction để thêm guardian\n        // Sử dụng discriminator đúng cho add_guardian theo IDL\n        const addGuardianDiscriminator = new Uint8Array([167, 189, 170, 27, 74, 240, 201, 241]);\n        \n        // Chuẩn bị tên guardian\n        const guardianNameBuffer = Buffer.from(guardianName);\n        const guardianNameLenBuffer = Buffer.alloc(4);\n        guardianNameLenBuffer.writeUInt32LE(guardianNameBuffer.length, 0);\n        \n        // Đặt is_owner = false vì đây là guardian member, không phải owner\n        const isOwnerByte = new Uint8Array([0]); // false = 0\n        \n        // Cấu hình webauthn_pubkey là Some(webauthnPubkey)\n        const hasWebauthn = new Uint8Array([1]); // Some variant\n        \n        // Tạo dữ liệu instruction\n        const instructionData = concatUint8Arrays(\n          addGuardianDiscriminator,\n          guardianIdBytes,\n          bufferToUint8Array(guardianNameLenBuffer),\n          bufferToUint8Array(guardianNameBuffer),\n          recoveryHash,\n          isOwnerByte,\n          hasWebauthn,\n          bufferToUint8Array(webauthnPubkey)\n        );\n        \n        const addGuardianIx = new TransactionInstruction({\n          keys: [\n            { pubkey: multisigPubkey, isSigner: false, isWritable: true },\n            { pubkey: guardianPDA, isSigner: false, isWritable: true },\n            { pubkey: projectFeePayerKeypair.publicKey, isSigner: false, isWritable: false },\n            { pubkey: projectFeePayerKeypair.publicKey, isSigner: true, isWritable: true },\n            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n          ],\n          programId: PROGRAM_ID,\n          data: Buffer.from(instructionData)\n        });\n        \n        tx.add(addGuardianIx);\n        \n        // Gửi transaction\n        setTransactionStatus(prev => prev + '\\nĐang gửi transaction...');\n        const signature = await sendAndConfirmTransaction(\n          connection,\n          tx,\n          [projectFeePayerKeypair],\n          {\n            commitment: 'confirmed',\n            skipPreflight: true,\n          }\n        );\n        \n        // Xác nhận transaction đã thành công\n        setTransactionStatus(prev => prev + '\\nĐang xác nhận transaction...');\n        await connection.confirmTransaction(signature, 'confirmed');\n        \n        // Cập nhật trạng thái guardian\n        await updateGuardianStatus(inviteCode, 'completed', signature);\n        \n        // Thông báo kết quả\n        setTransactionStatus(`Guardian đã được thêm thành công vào blockchain!\n- Tên: ${guardianData.guardianName}\n- ID: ${guardianData.guardianId}\n- Địa chỉ: ${guardianPDA.toString()}\n- Signature: ${signature}\n\nGuardian đã sẵn sàng để sử dụng trong ví multisig của bạn.`);\n        \n        // Xóa dữ liệu guardian từ database sau khi hoàn tất\n        setTransactionStatus(prev => prev + '\\n\\nĐang xóa dữ liệu guardian từ database...');\n        console.log(`Bắt đầu xóa dữ liệu guardian với mã mời: ${inviteCode}`);\n        const deleteResult = await deleteGuardianData(inviteCode);\n        \n        if (deleteResult) {\n          console.log(`✅ ĐÃ XÓA THÀNH CÔNG dữ liệu guardian, invitation và lookup với mã mời: ${inviteCode}`);\n          \n          // Cập nhật thông báo thành công rõ ràng hơn\n          setTransactionStatus(`✅ HOÀN TẤT THÀNH CÔNG!\n          \n          Guardian \"${guardianData.guardianName}\" (ID: ${guardianData.guardianId}) đã được thêm thành công vào ví.\n          \n          Địa chỉ Guardian: ${guardianPDA.toString()}\n          Signature: ${signature}\n          \n          ✅ Dữ liệu đã được xóa khỏi database để bảo vệ quyền riêng tư.\n          \n          ✅ Guardian hiện đã sẵn sàng sử dụng và đã được ẩn khỏi danh sách chờ.`);\n          \n          // Bỏ mã mời đã sử dụng khỏi danh sách\n          setPendingInvites(prev => prev.filter(code => code !== inviteCode));\n          \n          // Không đóng form sau khi hoàn tất để người dùng có thể tiếp tục thêm guardian khác\n          /* \n          if (pendingInvites.length <= 1) {\n            setShowInviteInput(false);\n          }\n          */\n        } else {\n          console.error(`❌ KHÔNG THỂ XÓA dữ liệu guardian với mã mời: ${inviteCode}`);\n          setTransactionStatus(prev => prev + '\\n❌ Không thể xóa dữ liệu guardian từ database.');\n        }\n        \n        // Làm mới danh sách guardian và cập nhật UI\n        await getExistingGuardianIds();\n        await loadPendingInvites();\n        \n        // Cập nhật số dư của ví\n        if (multisigAddress) {\n          await loadPdaBalance(multisigAddress);\n        }\n      } else {\n        setTransactionStatus('Lỗi: Fee payer không khả dụng');\n      }\n    } catch (error) {\n      console.error(\"Lỗi khi hoàn tất quá trình đăng ký guardian:\", error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      setTransactionStatus(`Lỗi khi hoàn tất quá trình đăng ký guardian: ${errorMessage}`);\n    }\n  };\n\n  // Hàm chuyển tiền\n  const transferFunds = async (recipientAddress: string, amount: number) => {\n    try {\n      // Kiểm tra xem ví đã được tạo chưa\n      if (!multisigAddress) {\n        setTransactionStatus('Vui lòng tạo ví trước khi chuyển tiền.');\n        return;\n      }\n      \n      // Kiểm tra xem có fee payer hay không\n      if (!projectFeePayerKeypair) {\n        setTransactionStatus('Không tìm thấy fee payer của dự án. Vui lòng thử lại sau.');\n        return;\n      }\n      \n      let recipient: PublicKey;\n      try {\n        recipient = new PublicKey(recipientAddress);\n      } catch (error) {\n        setTransactionStatus('Địa chỉ người nhận không hợp lệ.');\n        return;\n      }\n      \n      // Kiểm tra số dư của ví multisig\n      const multisigBalance = await connection.getBalance(multisigAddress);\n      const lamportsToSend = amount * LAMPORTS_PER_SOL;\n      \n      if (multisigBalance < lamportsToSend) {\n        setTransactionStatus(`Số dư ví không đủ. Hiện tại: ${multisigBalance / LAMPORTS_PER_SOL} SOL`);\n        return;\n      }\n      \n      setIsProcessingTransfer(true);\n      setTransactionStatus(`Đang chuyển ${amount} SOL từ ví đến ${recipientAddress}...`);\n      \n      // Tạo discriminator cho withdraw\n      const withdrawDiscriminator = new Uint8Array([54, 27, 38, 179, 114, 92, 92, 82]);\n      \n      // Số tiền chuyển (u64)\n      const amountBigInt = BigInt(Math.floor(amount * LAMPORTS_PER_SOL));\n      const amountBytes = bigIntToLeBytes(amountBigInt);\n      \n      // Tạo dữ liệu instruction\n      const withdrawData = concatUint8Arrays(\n        withdrawDiscriminator,\n        // amount (u64)\n        bufferToUint8Array(Buffer.from(amountBytes))\n      );\n      \n      // Tạo transaction chuyển tiền\n      const transferTransaction = new Transaction();\n      transferTransaction.add(\n        new TransactionInstruction({\n          keys: [\n            { pubkey: multisigAddress, isSigner: false, isWritable: true },\n            { pubkey: recipient, isSigner: false, isWritable: true },\n            { pubkey: projectFeePayerKeypair.publicKey, isSigner: true, isWritable: true },\n            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n          ],\n          programId: PROGRAM_ID,\n          data: Buffer.from(withdrawData)\n        })\n      );\n      \n      // Sign và gửi transaction\n      transferTransaction.feePayer = projectFeePayerKeypair.publicKey;\n      transferTransaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n      \n      const transferSignature = await connection.sendTransaction(\n        transferTransaction,\n        [projectFeePayerKeypair]\n      );\n      \n      await connection.confirmTransaction(transferSignature);\n      \n      // Cập nhật số dư\n      await loadPdaBalance(multisigAddress);\n      \n      setTransactionStatus(`Đã chuyển thành công ${amount} SOL đến ${recipientAddress}! Signature: ${transferSignature}`);\n    } catch (error: any) {\n      console.error('Lỗi khi chuyển tiền:', error);\n      setTransactionStatus(`Lỗi khi chuyển tiền: ${error.message}`);\n      throw error;\n    } finally {\n      setIsProcessingTransfer(false);\n    }\n  };\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>Moon Wallet</h1>\n        \n        {/* Các nút điều hướng */}\n        <div className=\"nav-buttons\">\n          <button\n            className=\"nav-button\"\n            onClick={() => {\n              setShowLoginForm(false);\n              setShowQRCode(false);\n              setShowInviteInput(false);\n              setShowAddGuardianForm(false);\n              setShowTransferScreen(false);\n            }}\n          >\n            Trang chủ\n          </button>\n          \n          {isLoggedIn && (\n            <>\n              <button\n                className=\"nav-button\"\n                onClick={() => {\n                  setShowTransferScreen(true);\n                  setShowLoginForm(false);\n                  setShowQRCode(false);\n                  setShowInviteInput(false);\n                  setShowAddGuardianForm(false);\n                }}\n              >\n                Chuyển tiền\n              </button>\n              <button\n                className=\"nav-button\"\n                onClick={() => {\n                  setShowAddGuardianForm(true);\n                  setShowLoginForm(false);\n                  setShowQRCode(false);\n                  setShowInviteInput(false);\n                  setShowTransferScreen(false);\n                }}\n              >\n                Quản lý Guardian\n              </button>\n            </>\n          )}\n          \n          {!isLoggedIn && (\n            <button\n              className=\"nav-button\"\n              onClick={() => {\n                setShowLoginForm(true);\n                setShowQRCode(false);\n                setShowInviteInput(false);\n                setShowAddGuardianForm(false);\n                setShowTransferScreen(false);\n              }}\n            >\n              Đăng nhập\n            </button>\n          )}\n        </div>\n        \n        {/* Màn hình chuyển tiền */}\n        {showTransferScreen && multisigAddress && (\n          <div className=\"section transfer-section\">\n            <TransferForm \n              onTransfer={transferFunds}\n              isProcessing={isProcessingTransfer}\n              balance={pdaBalance}\n            />\n          </div>\n        )}\n        \n        {/* Phần hiển thị thông báo */}\n        {transactionStatus && (\n          <div className=\"transaction-status\">\n            <p>{transactionStatus}</p>\n          </div>\n        )}\n        \n        {/* Các phần khác của ứng dụng */}\n        {/* ... existing code ... */}\n      </header>\n    </div>\n  );\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}