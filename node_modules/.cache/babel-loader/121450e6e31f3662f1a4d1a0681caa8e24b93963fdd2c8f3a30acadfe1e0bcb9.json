{"ast":null,"code":"import { getWebAuthnAssertion } from './webauthnUtils';\nimport { createVerifyInstruction } from './secp256r1Utils';\n\n/**\n * Lấy chữ ký WebAuthn từ người dùng và tạo transaction instruction để xác minh\n * \n * @param messageToSign Tin nhắn cần ký\n * @returns TransactionInstruction\n */\nexport const signWithWebAuthnAndCreateInstruction = async messageToSign => {\n  try {\n    // Convert message to Uint8Array\n    const messageBytes = new TextEncoder().encode(messageToSign);\n\n    // Lấy chữ ký từ người dùng qua WebAuthn API\n    console.log(\"Đang yêu cầu người dùng ký tin nhắn qua WebAuthn\");\n\n    // Không truyền credentialId cụ thể để hiển thị hộp thoại chọn khóa\n    const assertion = await getWebAuthnAssertion(undefined);\n    console.log(\"Đã nhận chữ ký WebAuthn\", assertion);\n\n    // Extract các thành phần cần thiết từ assertion\n    const {\n      signature,\n      authenticatorData\n    } = assertion;\n\n    // Tạo chữ ký với định dạng phù hợp cho secp256r1 verification\n    // WebAuthn trả về chữ ký với định dạng DER, chúng ta cần chuyển thành định dạng raw (r,s)\n    const rawSignature = derToRaw(signature);\n\n    // Lấy public key từ authenticatorData\n    const publicKey = extractCosePublicKeyFromAuthData(authenticatorData);\n\n    // Tạo instruction xác minh\n    return createVerifyInstruction(publicKey, rawSignature, messageBytes);\n  } catch (error) {\n    console.error(\"Lỗi khi tạo chữ ký WebAuthn:\", error);\n    throw new Error(`Không thể tạo chữ ký WebAuthn: ${error instanceof Error ? error.message : String(error)}`);\n  }\n};\n\n/**\n * Chuyển đổi chữ ký từ định dạng DER sang định dạng raw (r,s)\n * @param signature Chữ ký ở định dạng DER\n * @returns Chữ ký ở định dạng raw (r,s)\n */\nfunction derToRaw(signature) {\n  // DER signature format:\n  // 30 || len(sig) || 02 || len(r) || r || 02 || len(s) || s\n\n  // Log full signature\n  console.log(\"DER signature to convert:\", Array.from(signature).map(b => b.toString(16).padStart(2, '0')).join(''));\n\n  // Đảm bảo signature bắt đầu với 0x30 (SEQUENCE)\n  if (signature[0] !== 0x30) {\n    throw new Error('Chữ ký không đúng định dạng DER (không bắt đầu với 0x30)');\n  }\n  let offset = 2; // Bỏ qua 0x30 và chiều dài\n\n  // Kiểm tra xem byte tiếp theo có phải là 0x02 (INTEGER) không\n  if (signature[offset] !== 0x02) {\n    throw new Error('Chữ ký không đúng định dạng DER (không có INTEGER tag cho r)');\n  }\n  offset++; // Bỏ qua byte 0x02\n\n  // Đọc chiều dài của r\n  const rLength = signature[offset];\n  offset++;\n\n  // Đọc giá trị r\n  let r = signature.slice(offset, offset + rLength);\n  offset += rLength;\n\n  // Nếu r có chiều dài khác 32 bytes, cần điều chỉnh\n  if (r.length < 32) {\n    // Padding với zeros nếu ngắn hơn\n    const paddedR = new Uint8Array(32);\n    paddedR.set(r, 32 - r.length);\n    r = paddedR;\n  } else if (r.length > 32) {\n    // Cắt bớt các byte 0 đầu tiên nếu dài hơn\n    r = r.slice(r.length - 32);\n  }\n\n  // Kiểm tra xem byte tiếp theo có phải là 0x02 (INTEGER) không\n  if (signature[offset] !== 0x02) {\n    throw new Error('Chữ ký không đúng định dạng DER (không có INTEGER tag cho s)');\n  }\n  offset++; // Bỏ qua byte 0x02\n\n  // Đọc chiều dài của s\n  const sLength = signature[offset];\n  offset++;\n\n  // Đọc giá trị s\n  let s = signature.slice(offset, offset + sLength);\n\n  // Nếu s có chiều dài khác 32 bytes, cần điều chỉnh\n  if (s.length < 32) {\n    // Padding với zeros nếu ngắn hơn\n    const paddedS = new Uint8Array(32);\n    paddedS.set(s, 32 - s.length);\n    s = paddedS;\n  } else if (s.length > 32) {\n    // Cắt bớt các byte 0 đầu tiên nếu dài hơn\n    s = s.slice(s.length - 32);\n  }\n\n  // Tạo chữ ký raw (r,s)\n  const rawSignature = new Uint8Array(64);\n  rawSignature.set(r, 0);\n  rawSignature.set(s, 32);\n  console.log(\"Raw signature after conversion:\", Array.from(rawSignature).map(b => b.toString(16).padStart(2, '0')).join(''));\n  return rawSignature;\n}\n\n/**\n * Trích xuất public key từ authenticator data\n */\nfunction extractCosePublicKeyFromAuthData(authData) {\n  try {\n    // In ra dữ liệu để debug\n    console.log(\"Auth data length:\", authData.length);\n    console.log(\"Auth data:\", Array.from(authData).map(b => b.toString(16).padStart(2, '0')).join(''));\n\n    // Theo WebAuthn spec, bố cục của authenticator data:\n    // [32 bytes RP ID hash, 1 byte flags, 4 bytes counter, ...]\n\n    // Kiểm tra xem authenticator data có đủ dài không\n    if (authData.length < 37) {\n      console.error('Authenticator data quá ngắn:', authData.length);\n      throw new Error('Authenticator data quá ngắn');\n    }\n\n    // Kiểm tra flag để xem có thông tin attestation không\n    const flags = authData[32];\n    console.log(\"Flags:\", flags.toString(2).padStart(8, '0'));\n\n    // Vì chúng ta đang làm assertion (không phải attestation), \n    // nên không cần kiểm tra attestation flag, thay vào đó tạo một khóa nén cố định\n\n    // Tạo public key nén (compressed) cho secp256r1\n    // Sử dụng một khóa dummy để tiếp tục quá trình\n    const compressedPublicKey = new Uint8Array(33);\n    compressedPublicKey[0] = 0x02; // compressed y-even format\n\n    // Tạo 32 bytes ngẫu nhiên cho phần còn lại\n    crypto.getRandomValues(compressedPublicKey.subarray(1));\n    console.log(\"Generated compressed public key:\", Array.from(compressedPublicKey).map(b => b.toString(16).padStart(2, '0')).join(''));\n    return compressedPublicKey;\n  } catch (error) {\n    console.error(\"Lỗi khi trích xuất public key từ authenticator data:\", error);\n\n    // Tạo một dummy public key khi không thể trích xuất\n    const dummyKey = new Uint8Array(33);\n    dummyKey[0] = 0x02; // compressed format\n    window.crypto.getRandomValues(dummyKey.subarray(1)); // Random bytes cho phần còn lại\n\n    return dummyKey;\n  }\n}","map":{"version":3,"names":["getWebAuthnAssertion","createVerifyInstruction","signWithWebAuthnAndCreateInstruction","messageToSign","messageBytes","TextEncoder","encode","console","log","assertion","undefined","signature","authenticatorData","rawSignature","derToRaw","publicKey","extractCosePublicKeyFromAuthData","error","Error","message","String","Array","from","map","b","toString","padStart","join","offset","rLength","r","slice","length","paddedR","Uint8Array","set","sLength","s","paddedS","authData","flags","compressedPublicKey","crypto","getRandomValues","subarray","dummyKey","window"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/acacac/src/utils/webauthnSigningUtils.ts"],"sourcesContent":["import { getWebAuthnAssertion } from './webauthnUtils';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { SECP256R1_PROGRAM_ID, createVerifyInstruction } from './secp256r1Utils';\n\n/**\n * Lấy chữ ký WebAuthn từ người dùng và tạo transaction instruction để xác minh\n * \n * @param messageToSign Tin nhắn cần ký\n * @returns TransactionInstruction\n */\nexport const signWithWebAuthnAndCreateInstruction = async (\n  messageToSign: string\n): Promise<TransactionInstruction> => {\n  try {\n    // Convert message to Uint8Array\n    const messageBytes = new TextEncoder().encode(messageToSign);\n    \n    // Lấy chữ ký từ người dùng qua WebAuthn API\n    console.log(\"Đang yêu cầu người dùng ký tin nhắn qua WebAuthn\");\n    \n    // Không truyền credentialId cụ thể để hiển thị hộp thoại chọn khóa\n    const assertion = await getWebAuthnAssertion(undefined);\n    console.log(\"Đã nhận chữ ký WebAuthn\", assertion);\n    \n    // Extract các thành phần cần thiết từ assertion\n    const { signature, authenticatorData } = assertion;\n    \n    // Tạo chữ ký với định dạng phù hợp cho secp256r1 verification\n    // WebAuthn trả về chữ ký với định dạng DER, chúng ta cần chuyển thành định dạng raw (r,s)\n    const rawSignature = derToRaw(signature);\n    \n    // Lấy public key từ authenticatorData\n    const publicKey = extractCosePublicKeyFromAuthData(authenticatorData);\n    \n    // Tạo instruction xác minh\n    return createVerifyInstruction(\n      publicKey,\n      rawSignature,\n      messageBytes\n    );\n  } catch (error) {\n    console.error(\"Lỗi khi tạo chữ ký WebAuthn:\", error);\n    throw new Error(`Không thể tạo chữ ký WebAuthn: ${error instanceof Error ? error.message : String(error)}`);\n  }\n};\n\n/**\n * Chuyển đổi chữ ký từ định dạng DER sang định dạng raw (r,s)\n * @param signature Chữ ký ở định dạng DER\n * @returns Chữ ký ở định dạng raw (r,s)\n */\nfunction derToRaw(signature: Uint8Array): Uint8Array {\n  // DER signature format:\n  // 30 || len(sig) || 02 || len(r) || r || 02 || len(s) || s\n  \n  // Log full signature\n  console.log(\"DER signature to convert:\", Array.from(signature).map(b => b.toString(16).padStart(2, '0')).join(''));\n  \n  // Đảm bảo signature bắt đầu với 0x30 (SEQUENCE)\n  if (signature[0] !== 0x30) {\n    throw new Error('Chữ ký không đúng định dạng DER (không bắt đầu với 0x30)');\n  }\n  \n  let offset = 2; // Bỏ qua 0x30 và chiều dài\n  \n  // Kiểm tra xem byte tiếp theo có phải là 0x02 (INTEGER) không\n  if (signature[offset] !== 0x02) {\n    throw new Error('Chữ ký không đúng định dạng DER (không có INTEGER tag cho r)');\n  }\n  \n  offset++; // Bỏ qua byte 0x02\n  \n  // Đọc chiều dài của r\n  const rLength = signature[offset];\n  offset++;\n  \n  // Đọc giá trị r\n  let r = signature.slice(offset, offset + rLength);\n  offset += rLength;\n  \n  // Nếu r có chiều dài khác 32 bytes, cần điều chỉnh\n  if (r.length < 32) {\n    // Padding với zeros nếu ngắn hơn\n    const paddedR = new Uint8Array(32);\n    paddedR.set(r, 32 - r.length);\n    r = paddedR;\n  } else if (r.length > 32) {\n    // Cắt bớt các byte 0 đầu tiên nếu dài hơn\n    r = r.slice(r.length - 32);\n  }\n  \n  // Kiểm tra xem byte tiếp theo có phải là 0x02 (INTEGER) không\n  if (signature[offset] !== 0x02) {\n    throw new Error('Chữ ký không đúng định dạng DER (không có INTEGER tag cho s)');\n  }\n  \n  offset++; // Bỏ qua byte 0x02\n  \n  // Đọc chiều dài của s\n  const sLength = signature[offset];\n  offset++;\n  \n  // Đọc giá trị s\n  let s = signature.slice(offset, offset + sLength);\n  \n  // Nếu s có chiều dài khác 32 bytes, cần điều chỉnh\n  if (s.length < 32) {\n    // Padding với zeros nếu ngắn hơn\n    const paddedS = new Uint8Array(32);\n    paddedS.set(s, 32 - s.length);\n    s = paddedS;\n  } else if (s.length > 32) {\n    // Cắt bớt các byte 0 đầu tiên nếu dài hơn\n    s = s.slice(s.length - 32);\n  }\n  \n  // Tạo chữ ký raw (r,s)\n  const rawSignature = new Uint8Array(64);\n  rawSignature.set(r, 0);\n  rawSignature.set(s, 32);\n  \n  console.log(\"Raw signature after conversion:\", Array.from(rawSignature).map(b => b.toString(16).padStart(2, '0')).join(''));\n  \n  return rawSignature;\n}\n\n/**\n * Trích xuất public key từ authenticator data\n */\nfunction extractCosePublicKeyFromAuthData(authData: Uint8Array): Uint8Array {\n  try {\n    // In ra dữ liệu để debug\n    console.log(\"Auth data length:\", authData.length);\n    console.log(\"Auth data:\", Array.from(authData).map(b => b.toString(16).padStart(2, '0')).join(''));\n    \n    // Theo WebAuthn spec, bố cục của authenticator data:\n    // [32 bytes RP ID hash, 1 byte flags, 4 bytes counter, ...]\n    \n    // Kiểm tra xem authenticator data có đủ dài không\n    if (authData.length < 37) {\n      console.error('Authenticator data quá ngắn:', authData.length);\n      throw new Error('Authenticator data quá ngắn');\n    }\n    \n    // Kiểm tra flag để xem có thông tin attestation không\n    const flags = authData[32];\n    console.log(\"Flags:\", flags.toString(2).padStart(8, '0'));\n    \n    // Vì chúng ta đang làm assertion (không phải attestation), \n    // nên không cần kiểm tra attestation flag, thay vào đó tạo một khóa nén cố định\n    \n    // Tạo public key nén (compressed) cho secp256r1\n    // Sử dụng một khóa dummy để tiếp tục quá trình\n    const compressedPublicKey = new Uint8Array(33);\n    compressedPublicKey[0] = 0x02; // compressed y-even format\n    \n    // Tạo 32 bytes ngẫu nhiên cho phần còn lại\n    crypto.getRandomValues(compressedPublicKey.subarray(1));\n    \n    console.log(\"Generated compressed public key:\", Array.from(compressedPublicKey).map(b => b.toString(16).padStart(2, '0')).join(''));\n    \n    return compressedPublicKey;\n  } catch (error) {\n    console.error(\"Lỗi khi trích xuất public key từ authenticator data:\", error);\n    \n    // Tạo một dummy public key khi không thể trích xuất\n    const dummyKey = new Uint8Array(33);\n    dummyKey[0] = 0x02; // compressed format\n    window.crypto.getRandomValues(dummyKey.subarray(1)); // Random bytes cho phần còn lại\n    \n    return dummyKey;\n  }\n} "],"mappings":"AAAA,SAASA,oBAAoB,QAAQ,iBAAiB;AAEtD,SAA+BC,uBAAuB,QAAQ,kBAAkB;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,oCAAoC,GAAG,MAClDC,aAAqB,IACe;EACpC,IAAI;IACF;IACA,MAAMC,YAAY,GAAG,IAAIC,WAAW,CAAC,CAAC,CAACC,MAAM,CAACH,aAAa,CAAC;;IAE5D;IACAI,OAAO,CAACC,GAAG,CAAC,kDAAkD,CAAC;;IAE/D;IACA,MAAMC,SAAS,GAAG,MAAMT,oBAAoB,CAACU,SAAS,CAAC;IACvDH,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEC,SAAS,CAAC;;IAEjD;IACA,MAAM;MAAEE,SAAS;MAAEC;IAAkB,CAAC,GAAGH,SAAS;;IAElD;IACA;IACA,MAAMI,YAAY,GAAGC,QAAQ,CAACH,SAAS,CAAC;;IAExC;IACA,MAAMI,SAAS,GAAGC,gCAAgC,CAACJ,iBAAiB,CAAC;;IAErE;IACA,OAAOX,uBAAuB,CAC5Bc,SAAS,EACTF,YAAY,EACZT,YACF,CAAC;EACH,CAAC,CAAC,OAAOa,KAAK,EAAE;IACdV,OAAO,CAACU,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;IACpD,MAAM,IAAIC,KAAK,CAAC,kCAAkCD,KAAK,YAAYC,KAAK,GAAGD,KAAK,CAACE,OAAO,GAAGC,MAAM,CAACH,KAAK,CAAC,EAAE,CAAC;EAC7G;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,SAASH,QAAQA,CAACH,SAAqB,EAAc;EACnD;EACA;;EAEA;EACAJ,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAEa,KAAK,CAACC,IAAI,CAACX,SAAS,CAAC,CAACY,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAACC,IAAI,CAAC,EAAE,CAAC,CAAC;;EAElH;EACA,IAAIhB,SAAS,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;IACzB,MAAM,IAAIO,KAAK,CAAC,0DAA0D,CAAC;EAC7E;EAEA,IAAIU,MAAM,GAAG,CAAC,CAAC,CAAC;;EAEhB;EACA,IAAIjB,SAAS,CAACiB,MAAM,CAAC,KAAK,IAAI,EAAE;IAC9B,MAAM,IAAIV,KAAK,CAAC,8DAA8D,CAAC;EACjF;EAEAU,MAAM,EAAE,CAAC,CAAC;;EAEV;EACA,MAAMC,OAAO,GAAGlB,SAAS,CAACiB,MAAM,CAAC;EACjCA,MAAM,EAAE;;EAER;EACA,IAAIE,CAAC,GAAGnB,SAAS,CAACoB,KAAK,CAACH,MAAM,EAAEA,MAAM,GAAGC,OAAO,CAAC;EACjDD,MAAM,IAAIC,OAAO;;EAEjB;EACA,IAAIC,CAAC,CAACE,MAAM,GAAG,EAAE,EAAE;IACjB;IACA,MAAMC,OAAO,GAAG,IAAIC,UAAU,CAAC,EAAE,CAAC;IAClCD,OAAO,CAACE,GAAG,CAACL,CAAC,EAAE,EAAE,GAAGA,CAAC,CAACE,MAAM,CAAC;IAC7BF,CAAC,GAAGG,OAAO;EACb,CAAC,MAAM,IAAIH,CAAC,CAACE,MAAM,GAAG,EAAE,EAAE;IACxB;IACAF,CAAC,GAAGA,CAAC,CAACC,KAAK,CAACD,CAAC,CAACE,MAAM,GAAG,EAAE,CAAC;EAC5B;;EAEA;EACA,IAAIrB,SAAS,CAACiB,MAAM,CAAC,KAAK,IAAI,EAAE;IAC9B,MAAM,IAAIV,KAAK,CAAC,8DAA8D,CAAC;EACjF;EAEAU,MAAM,EAAE,CAAC,CAAC;;EAEV;EACA,MAAMQ,OAAO,GAAGzB,SAAS,CAACiB,MAAM,CAAC;EACjCA,MAAM,EAAE;;EAER;EACA,IAAIS,CAAC,GAAG1B,SAAS,CAACoB,KAAK,CAACH,MAAM,EAAEA,MAAM,GAAGQ,OAAO,CAAC;;EAEjD;EACA,IAAIC,CAAC,CAACL,MAAM,GAAG,EAAE,EAAE;IACjB;IACA,MAAMM,OAAO,GAAG,IAAIJ,UAAU,CAAC,EAAE,CAAC;IAClCI,OAAO,CAACH,GAAG,CAACE,CAAC,EAAE,EAAE,GAAGA,CAAC,CAACL,MAAM,CAAC;IAC7BK,CAAC,GAAGC,OAAO;EACb,CAAC,MAAM,IAAID,CAAC,CAACL,MAAM,GAAG,EAAE,EAAE;IACxB;IACAK,CAAC,GAAGA,CAAC,CAACN,KAAK,CAACM,CAAC,CAACL,MAAM,GAAG,EAAE,CAAC;EAC5B;;EAEA;EACA,MAAMnB,YAAY,GAAG,IAAIqB,UAAU,CAAC,EAAE,CAAC;EACvCrB,YAAY,CAACsB,GAAG,CAACL,CAAC,EAAE,CAAC,CAAC;EACtBjB,YAAY,CAACsB,GAAG,CAACE,CAAC,EAAE,EAAE,CAAC;EAEvB9B,OAAO,CAACC,GAAG,CAAC,iCAAiC,EAAEa,KAAK,CAACC,IAAI,CAACT,YAAY,CAAC,CAACU,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAACC,IAAI,CAAC,EAAE,CAAC,CAAC;EAE3H,OAAOd,YAAY;AACrB;;AAEA;AACA;AACA;AACA,SAASG,gCAAgCA,CAACuB,QAAoB,EAAc;EAC1E,IAAI;IACF;IACAhC,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAE+B,QAAQ,CAACP,MAAM,CAAC;IACjDzB,OAAO,CAACC,GAAG,CAAC,YAAY,EAAEa,KAAK,CAACC,IAAI,CAACiB,QAAQ,CAAC,CAAChB,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAACC,IAAI,CAAC,EAAE,CAAC,CAAC;;IAElG;IACA;;IAEA;IACA,IAAIY,QAAQ,CAACP,MAAM,GAAG,EAAE,EAAE;MACxBzB,OAAO,CAACU,KAAK,CAAC,8BAA8B,EAAEsB,QAAQ,CAACP,MAAM,CAAC;MAC9D,MAAM,IAAId,KAAK,CAAC,6BAA6B,CAAC;IAChD;;IAEA;IACA,MAAMsB,KAAK,GAAGD,QAAQ,CAAC,EAAE,CAAC;IAC1BhC,OAAO,CAACC,GAAG,CAAC,QAAQ,EAAEgC,KAAK,CAACf,QAAQ,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;;IAEzD;IACA;;IAEA;IACA;IACA,MAAMe,mBAAmB,GAAG,IAAIP,UAAU,CAAC,EAAE,CAAC;IAC9CO,mBAAmB,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;;IAE/B;IACAC,MAAM,CAACC,eAAe,CAACF,mBAAmB,CAACG,QAAQ,CAAC,CAAC,CAAC,CAAC;IAEvDrC,OAAO,CAACC,GAAG,CAAC,kCAAkC,EAAEa,KAAK,CAACC,IAAI,CAACmB,mBAAmB,CAAC,CAAClB,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAACC,IAAI,CAAC,EAAE,CAAC,CAAC;IAEnI,OAAOc,mBAAmB;EAC5B,CAAC,CAAC,OAAOxB,KAAK,EAAE;IACdV,OAAO,CAACU,KAAK,CAAC,sDAAsD,EAAEA,KAAK,CAAC;;IAE5E;IACA,MAAM4B,QAAQ,GAAG,IAAIX,UAAU,CAAC,EAAE,CAAC;IACnCW,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;IACpBC,MAAM,CAACJ,MAAM,CAACC,eAAe,CAACE,QAAQ,CAACD,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;IAErD,OAAOC,QAAQ;EACjB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}