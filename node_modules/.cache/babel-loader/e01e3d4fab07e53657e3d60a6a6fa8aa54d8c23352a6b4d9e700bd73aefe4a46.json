{"ast":null,"code":"import { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\n// Constants\nexport const SECP256R1_PROGRAM_ID = new PublicKey('Secp256r1SigVerify1111111111111111111111111');\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 14;\nconst SIGNATURE_OFFSETS_START = 2;\nconst DATA_START = SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START;\nconst SIGNATURE_SERIALIZED_SIZE = 64;\nconst COMPRESSED_PUBKEY_SERIALIZED_SIZE = 33;\n\n/**\n * Hàm băm một tin nhắn để chuẩn bị cho ký\n * @param message Tin nhắn cần băm\n * @returns Buffer chứa hash của tin nhắn\n */\nexport const hashMessage = async message => {\n  if (typeof message === 'string') {\n    message = new TextEncoder().encode(message);\n  }\n  const hashBuffer = await crypto.subtle.digest('SHA-256', message);\n  return new Uint8Array(hashBuffer);\n};\n\n/**\n * Chuyển đổi chữ ký từ định dạng DER sang định dạng raw (r,s)\n * @param signature Chữ ký ở định dạng DER\n * @returns Chữ ký ở định dạng raw (r,s)\n */\nexport const derToRaw = signature => {\n  try {\n    // DER format: 30 + len + 02 + r_len + r + 02 + s_len + s\n    let offset = 2; // Skip 30 + len\n\n    // Read r\n    if (signature[offset] !== 0x02) {\n      throw new Error('Định dạng DER không hợp lệ: không tìm thấy marker r');\n    }\n    offset++; // Skip 02\n\n    const rLen = signature[offset++];\n    let r = signature.slice(offset, offset + rLen);\n    offset += rLen;\n\n    // Read s\n    if (signature[offset] !== 0x02) {\n      throw new Error('Định dạng DER không hợp lệ: không tìm thấy marker s');\n    }\n    offset++; // Skip 02\n\n    const sLen = signature[offset++];\n    let s = signature.slice(offset, offset + sLen);\n\n    // Pad r and s to 32 bytes\n    let rPadded, sPadded;\n    if (r.length < 32) {\n      const padding = new Uint8Array(32 - r.length).fill(0);\n      rPadded = new Uint8Array(32);\n      rPadded.set(padding, 0);\n      rPadded.set(r, padding.length);\n    } else if (r.length > 32) {\n      rPadded = r.slice(r.length - 32);\n    } else {\n      rPadded = r;\n    }\n    if (s.length < 32) {\n      const padding = new Uint8Array(32 - s.length).fill(0);\n      sPadded = new Uint8Array(32);\n      sPadded.set(padding, 0);\n      sPadded.set(s, padding.length);\n    } else if (s.length > 32) {\n      sPadded = s.slice(s.length - 32);\n    } else {\n      sPadded = s;\n    }\n\n    // Concatenate r and s\n    const result = new Uint8Array(64);\n    result.set(rPadded, 0);\n    result.set(sPadded, 32);\n    return result;\n  } catch (error) {\n    console.error('Lỗi khi chuyển đổi chữ ký DER sang raw:', error);\n    throw error;\n  }\n};\n\n/**\n * Tạo instruction xác minh chữ ký secp256r1\n * @param publicKey Public key dùng để xác minh (dạng nén)\n * @param signature Chữ ký (r,s) đã được chuyển đổi sang dạng raw\n * @param message Tin nhắn đã được ký\n * @returns TransactionInstruction để xác minh chữ ký\n */\nexport const createVerifyInstruction = (publicKey, signature, message) => {\n  // Kiểm tra độ dài của các tham số\n  if (publicKey.length !== COMPRESSED_PUBKEY_SERIALIZED_SIZE) {\n    throw new Error(`Public key phải có độ dài ${COMPRESSED_PUBKEY_SERIALIZED_SIZE} bytes`);\n  }\n  if (signature.length !== SIGNATURE_SERIALIZED_SIZE) {\n    throw new Error(`Chữ ký phải có độ dài ${SIGNATURE_SERIALIZED_SIZE} bytes`);\n  }\n\n  // Tạo instruction data\n  const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + message.length;\n  const instructionData = Buffer.alloc(totalSize);\n\n  // Header\n  instructionData.writeUInt8(1, 0); // num_signatures = 1\n  instructionData.writeUInt8(0, 1); // padding\n\n  // Offsets\n  const publicKeyOffset = DATA_START;\n  const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n  const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n\n  // Write offsets\n  instructionData.writeUInt16LE(signatureOffset, SIGNATURE_OFFSETS_START);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 2);\n  instructionData.writeUInt16LE(publicKeyOffset, SIGNATURE_OFFSETS_START + 4);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 6);\n  instructionData.writeUInt16LE(messageDataOffset, SIGNATURE_OFFSETS_START + 8);\n  instructionData.writeUInt16LE(message.length, SIGNATURE_OFFSETS_START + 10);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 12);\n\n  // Write data\n  Buffer.from(publicKey).copy(instructionData, publicKeyOffset);\n  Buffer.from(signature).copy(instructionData, signatureOffset);\n  Buffer.from(message).copy(instructionData, messageDataOffset);\n  return new TransactionInstruction({\n    keys: [],\n    programId: SECP256R1_PROGRAM_ID,\n    data: instructionData\n  });\n};\n\n/**\n * Tạo cặp khóa secp256r1 (chỉ dùng cho testing)\n * Lưu ý: Trong ứng dụng thực tế, hãy sử dụng WebAuthn để lấy cặp khóa từ người dùng\n */\nexport const generateKeyPair = async () => {\n  try {\n    // Tạo cặp khóa ECDSA bằng Web Crypto API\n    const keyPair = await window.crypto.subtle.generateKey({\n      name: 'ECDSA',\n      namedCurve: 'P-256'\n    }, true, ['sign', 'verify']);\n\n    // Export public key\n    const publicKeyBuffer = await window.crypto.subtle.exportKey('raw', keyPair.publicKey);\n\n    // Export private key (lưu ý: chỉ dùng trong môi trường testing)\n    const privateKeyBuffer = await window.crypto.subtle.exportKey('pkcs8', keyPair.privateKey);\n\n    // Nén public key (0x02 hoặc 0x03 + x coordinate)\n    const publicKeyArray = new Uint8Array(publicKeyBuffer);\n    const compressedPublicKey = new Uint8Array(33);\n\n    // Byte đầu tiên là 0x02 nếu y chẵn, 0x03 nếu y lẻ\n    compressedPublicKey[0] = publicKeyArray[64] & 1 ? 0x03 : 0x02;\n\n    // Sao chép tọa độ x\n    compressedPublicKey.set(publicKeyArray.slice(1, 33), 1);\n    return {\n      publicKey: compressedPublicKey,\n      privateKey: new Uint8Array(privateKeyBuffer)\n    };\n  } catch (error) {\n    console.error('Lỗi khi tạo cặp khóa secp256r1:', error);\n    throw error;\n  }\n};\n\n/**\n * Ký một tin nhắn với khóa riêng tư (chỉ dùng cho testing)\n * Lưu ý: Trong ứng dụng thực tế, hãy sử dụng WebAuthn để lấy chữ ký từ người dùng\n */\nexport const signMessage = async (privateKey, message) => {\n  try {\n    // Import private key\n    const cryptoKey = await window.crypto.subtle.importKey('pkcs8', privateKey, {\n      name: 'ECDSA',\n      namedCurve: 'P-256'\n    }, false, ['sign']);\n\n    // Ký tin nhắn\n    const signature = await window.crypto.subtle.sign({\n      name: 'ECDSA',\n      hash: {\n        name: 'SHA-256'\n      }\n    }, cryptoKey, message);\n\n    // Web Crypto API trả về chữ ký dạng DER, cần chuyển sang dạng raw (r,s)\n    return derToRaw(new Uint8Array(signature));\n  } catch (error) {\n    console.error('Lỗi khi ký tin nhắn:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["PublicKey","TransactionInstruction","Buffer","SECP256R1_PROGRAM_ID","SIGNATURE_OFFSETS_SERIALIZED_SIZE","SIGNATURE_OFFSETS_START","DATA_START","SIGNATURE_SERIALIZED_SIZE","COMPRESSED_PUBKEY_SERIALIZED_SIZE","hashMessage","message","TextEncoder","encode","hashBuffer","crypto","subtle","digest","Uint8Array","derToRaw","signature","offset","Error","rLen","r","slice","sLen","s","rPadded","sPadded","length","padding","fill","set","result","error","console","createVerifyInstruction","publicKey","totalSize","instructionData","alloc","writeUInt8","publicKeyOffset","signatureOffset","messageDataOffset","writeUInt16LE","from","copy","keys","programId","data","generateKeyPair","keyPair","window","generateKey","name","namedCurve","publicKeyBuffer","exportKey","privateKeyBuffer","privateKey","publicKeyArray","compressedPublicKey","signMessage","cryptoKey","importKey","sign","hash"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/acacac/src/utils/secp256r1Utils.ts"],"sourcesContent":["import { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport BN from 'bn.js';\n\n// Constants\nexport const SECP256R1_PROGRAM_ID = new PublicKey('Secp256r1SigVerify1111111111111111111111111');\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 14;\nconst SIGNATURE_OFFSETS_START = 2;\nconst DATA_START = SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START;\nconst SIGNATURE_SERIALIZED_SIZE = 64;\nconst COMPRESSED_PUBKEY_SERIALIZED_SIZE = 33;\n\n/**\n * Hàm băm một tin nhắn để chuẩn bị cho ký\n * @param message Tin nhắn cần băm\n * @returns Buffer chứa hash của tin nhắn\n */\nexport const hashMessage = async (message: string | Uint8Array): Promise<Uint8Array> => {\n  if (typeof message === 'string') {\n    message = new TextEncoder().encode(message);\n  }\n  \n  const hashBuffer = await crypto.subtle.digest('SHA-256', message);\n  return new Uint8Array(hashBuffer);\n};\n\n/**\n * Chuyển đổi chữ ký từ định dạng DER sang định dạng raw (r,s)\n * @param signature Chữ ký ở định dạng DER\n * @returns Chữ ký ở định dạng raw (r,s)\n */\nexport const derToRaw = (signature: Uint8Array): Uint8Array => {\n  try {\n    // DER format: 30 + len + 02 + r_len + r + 02 + s_len + s\n    let offset = 2; // Skip 30 + len\n    \n    // Read r\n    if (signature[offset] !== 0x02) {\n      throw new Error('Định dạng DER không hợp lệ: không tìm thấy marker r');\n    }\n    offset++; // Skip 02\n    \n    const rLen = signature[offset++];\n    let r = signature.slice(offset, offset + rLen);\n    offset += rLen;\n    \n    // Read s\n    if (signature[offset] !== 0x02) {\n      throw new Error('Định dạng DER không hợp lệ: không tìm thấy marker s');\n    }\n    offset++; // Skip 02\n    \n    const sLen = signature[offset++];\n    let s = signature.slice(offset, offset + sLen);\n    \n    // Pad r and s to 32 bytes\n    let rPadded, sPadded;\n    \n    if (r.length < 32) {\n      const padding = new Uint8Array(32 - r.length).fill(0);\n      rPadded = new Uint8Array(32);\n      rPadded.set(padding, 0);\n      rPadded.set(r, padding.length);\n    } else if (r.length > 32) {\n      rPadded = r.slice(r.length - 32);\n    } else {\n      rPadded = r;\n    }\n    \n    if (s.length < 32) {\n      const padding = new Uint8Array(32 - s.length).fill(0);\n      sPadded = new Uint8Array(32);\n      sPadded.set(padding, 0);\n      sPadded.set(s, padding.length);\n    } else if (s.length > 32) {\n      sPadded = s.slice(s.length - 32);\n    } else {\n      sPadded = s;\n    }\n    \n    // Concatenate r and s\n    const result = new Uint8Array(64);\n    result.set(rPadded, 0);\n    result.set(sPadded, 32);\n    \n    return result;\n  } catch (error) {\n    console.error('Lỗi khi chuyển đổi chữ ký DER sang raw:', error);\n    throw error;\n  }\n};\n\n/**\n * Tạo instruction xác minh chữ ký secp256r1\n * @param publicKey Public key dùng để xác minh (dạng nén)\n * @param signature Chữ ký (r,s) đã được chuyển đổi sang dạng raw\n * @param message Tin nhắn đã được ký\n * @returns TransactionInstruction để xác minh chữ ký\n */\nexport const createVerifyInstruction = (\n  publicKey: Uint8Array,\n  signature: Uint8Array,\n  message: Uint8Array\n): TransactionInstruction => {\n  // Kiểm tra độ dài của các tham số\n  if (publicKey.length !== COMPRESSED_PUBKEY_SERIALIZED_SIZE) {\n    throw new Error(`Public key phải có độ dài ${COMPRESSED_PUBKEY_SERIALIZED_SIZE} bytes`);\n  }\n  \n  if (signature.length !== SIGNATURE_SERIALIZED_SIZE) {\n    throw new Error(`Chữ ký phải có độ dài ${SIGNATURE_SERIALIZED_SIZE} bytes`);\n  }\n  \n  // Tạo instruction data\n  const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + message.length;\n  const instructionData = Buffer.alloc(totalSize);\n\n  // Header\n  instructionData.writeUInt8(1, 0); // num_signatures = 1\n  instructionData.writeUInt8(0, 1); // padding\n\n  // Offsets\n  const publicKeyOffset = DATA_START;\n  const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n  const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n\n  // Write offsets\n  instructionData.writeUInt16LE(signatureOffset, SIGNATURE_OFFSETS_START);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 2);\n  instructionData.writeUInt16LE(publicKeyOffset, SIGNATURE_OFFSETS_START + 4);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 6);\n  instructionData.writeUInt16LE(messageDataOffset, SIGNATURE_OFFSETS_START + 8);\n  instructionData.writeUInt16LE(message.length, SIGNATURE_OFFSETS_START + 10);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 12);\n\n  // Write data\n  Buffer.from(publicKey).copy(instructionData, publicKeyOffset);\n  Buffer.from(signature).copy(instructionData, signatureOffset);\n  Buffer.from(message).copy(instructionData, messageDataOffset);\n\n  return new TransactionInstruction({\n    keys: [],\n    programId: SECP256R1_PROGRAM_ID,\n    data: instructionData\n  });\n};\n\n/**\n * Tạo cặp khóa secp256r1 (chỉ dùng cho testing)\n * Lưu ý: Trong ứng dụng thực tế, hãy sử dụng WebAuthn để lấy cặp khóa từ người dùng\n */\nexport const generateKeyPair = async (): Promise<{\n  publicKey: Uint8Array;\n  privateKey: Uint8Array;\n}> => {\n  try {\n    // Tạo cặp khóa ECDSA bằng Web Crypto API\n    const keyPair = await window.crypto.subtle.generateKey(\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256'\n      },\n      true,\n      ['sign', 'verify']\n    );\n    \n    // Export public key\n    const publicKeyBuffer = await window.crypto.subtle.exportKey(\n      'raw',\n      keyPair.publicKey\n    );\n    \n    // Export private key (lưu ý: chỉ dùng trong môi trường testing)\n    const privateKeyBuffer = await window.crypto.subtle.exportKey(\n      'pkcs8',\n      keyPair.privateKey\n    );\n    \n    // Nén public key (0x02 hoặc 0x03 + x coordinate)\n    const publicKeyArray = new Uint8Array(publicKeyBuffer);\n    const compressedPublicKey = new Uint8Array(33);\n    \n    // Byte đầu tiên là 0x02 nếu y chẵn, 0x03 nếu y lẻ\n    compressedPublicKey[0] = (publicKeyArray[64] & 1) ? 0x03 : 0x02;\n    \n    // Sao chép tọa độ x\n    compressedPublicKey.set(publicKeyArray.slice(1, 33), 1);\n    \n    return {\n      publicKey: compressedPublicKey,\n      privateKey: new Uint8Array(privateKeyBuffer)\n    };\n  } catch (error) {\n    console.error('Lỗi khi tạo cặp khóa secp256r1:', error);\n    throw error;\n  }\n};\n\n/**\n * Ký một tin nhắn với khóa riêng tư (chỉ dùng cho testing)\n * Lưu ý: Trong ứng dụng thực tế, hãy sử dụng WebAuthn để lấy chữ ký từ người dùng\n */\nexport const signMessage = async (\n  privateKey: Uint8Array,\n  message: Uint8Array\n): Promise<Uint8Array> => {\n  try {\n    // Import private key\n    const cryptoKey = await window.crypto.subtle.importKey(\n      'pkcs8',\n      privateKey,\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256'\n      },\n      false,\n      ['sign']\n    );\n    \n    // Ký tin nhắn\n    const signature = await window.crypto.subtle.sign(\n      {\n        name: 'ECDSA',\n        hash: { name: 'SHA-256' }\n      },\n      cryptoKey,\n      message\n    );\n    \n    // Web Crypto API trả về chữ ký dạng DER, cần chuyển sang dạng raw (r,s)\n    return derToRaw(new Uint8Array(signature));\n  } catch (error) {\n    console.error('Lỗi khi ký tin nhắn:', error);\n    throw error;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}