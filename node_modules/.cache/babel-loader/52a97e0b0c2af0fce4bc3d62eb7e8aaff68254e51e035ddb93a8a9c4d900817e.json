{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n  redirect: true,\n  expectStatusCode: 200,\n  headers: {},\n  full: false,\n  keepAlive: true,\n  cors: false,\n  referrer: false,\n  sslAllowSelfSigned: false,\n  _redirectCount: 0\n});\nclass InvalidCertError extends Error {\n  constructor(msg, fingerprint256) {\n    super(msg);\n    this.fingerprint256 = fingerprint256;\n  }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n  constructor(statusCode) {\n    super(`Request Failed. Status Code: ${statusCode}`);\n    this.statusCode = statusCode;\n  }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n  if (!type || type === 'text' || type === 'json') {\n    try {\n      let text = new TextDecoder('utf8', {\n        fatal: true\n      }).decode(b);\n      if (type === 'text') return text;\n      try {\n        return JSON.parse(text);\n      } catch (err) {\n        if (type === 'json') throw err;\n        return text;\n      }\n    } catch (err) {\n      if (type === 'text' || type === 'json') throw err;\n    }\n  }\n  return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n  let options = {\n    ...DEFAULT_OPT,\n    ..._options\n  };\n  const http = require('http');\n  const https = require('https');\n  const zlib = require('zlib');\n  const {\n    promisify\n  } = require('util');\n  const {\n    resolve: urlResolve\n  } = require('url');\n  const isSecure = !!/^https/.test(url);\n  let opts = {\n    method: options.method || 'GET',\n    headers: {\n      'Accept-Encoding': 'gzip, deflate, br'\n    }\n  };\n  const compactFP = s => s.replace(/:| /g, '').toLowerCase();\n  if (options.keepAlive) {\n    const agentOpt = {\n      keepAlive: true,\n      keepAliveMsecs: 30 * 1000,\n      maxFreeSockets: 1024,\n      maxCachedSessions: 1024\n    };\n    const agentKey = [isSecure, isSecure && options.sslPinnedCertificates?.map(i => compactFP(i)).sort()].join();\n    opts.agent = agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n  }\n  if (options.type === 'json') opts.headers['Content-Type'] = 'application/json';\n  if (options.data) {\n    if (!options.method) opts.method = 'POST';\n    opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n  }\n  opts.headers = {\n    ...opts.headers,\n    ...options.headers\n  };\n  if (options.sslAllowSelfSigned) opts.rejectUnauthorized = false;\n  const handleRes = async res => {\n    const status = res.statusCode;\n    if (options.redirect && 300 <= status && status < 400 && res.headers['location']) {\n      if (options._redirectCount == 10) throw new Error('Request failed. Too much redirects.');\n      options._redirectCount += 1;\n      return await fetchNode(urlResolve(url, res.headers['location']), options);\n    }\n    if (options.expectStatusCode && status !== options.expectStatusCode) {\n      res.resume();\n      throw new InvalidStatusCodeError(status);\n    }\n    let buf = [];\n    for await (const chunk of res) buf.push(chunk);\n    let bytes = Buffer.concat(buf);\n    const encoding = res.headers['content-encoding'];\n    if (encoding === 'br') bytes = await promisify(zlib.brotliDecompress)(bytes);\n    if (encoding === 'gzip' || encoding === 'deflate') bytes = await promisify(zlib.unzip)(bytes);\n    const body = detectType(bytes, options.type);\n    if (options.full) return {\n      headers: res.headers,\n      status,\n      body\n    };\n    return body;\n  };\n  return new Promise((resolve, reject) => {\n    const handleError = async err => {\n      if (err && err.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {\n        try {\n          await fetchNode(url, {\n            ...options,\n            sslAllowSelfSigned: true,\n            sslPinnedCertificates: []\n          });\n        } catch (e) {\n          if (e && e.fingerprint256) {\n            err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);\n          }\n        }\n      }\n      reject(err);\n    };\n    const req = (isSecure ? https : http).request(url, opts, res => {\n      res.on('error', handleError);\n      (async () => {\n        try {\n          resolve(await handleRes(res));\n        } catch (error) {\n          reject(error);\n        }\n      })();\n    });\n    req.on('error', handleError);\n    const pinned = options.sslPinnedCertificates?.map(i => compactFP(i));\n    const mfetchSecureConnect = socket => {\n      const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || '');\n      if (!fp256 && socket.isSessionReused()) return;\n      if (pinned.includes(fp256)) return;\n      req.emit('error', new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));\n      return req.abort();\n    };\n    if (options.sslPinnedCertificates) {\n      req.on('socket', socket => {\n        const hasListeners = socket.listeners('secureConnect').map(i => (i.name || '').replace('bound ', '')).includes('mfetchSecureConnect');\n        if (hasListeners) return;\n        socket.on('secureConnect', mfetchSecureConnect.bind(null, socket));\n      });\n    }\n    if (options.keepAlive) req.setNoDelay(true);\n    if (opts.body) req.write(opts.body);\n    req.end();\n  });\n}\nconst SAFE_HEADERS = new Set(['Accept', 'Accept-Language', 'Content-Language', 'Content-Type'].map(i => i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set(['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers', 'Access-Control-Request-Method', 'Connection', 'Content-Length', 'Cookie', 'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin', 'Referer', 'TE', 'Trailer', 'Transfer-Encoding', 'Upgrade', 'Via'].map(i => i.toLowerCase()));\nasync function fetchBrowser(url, _options) {\n  let options = {\n    ...DEFAULT_OPT,\n    ..._options\n  };\n  const headers = new Headers();\n  if (options.type === 'json') headers.set('Content-Type', 'application/json');\n  let parsed = new URL(url);\n  if (parsed.username) {\n    const auth = btoa(`${parsed.username}:${parsed.password}`);\n    headers.set('Authorization', `Basic ${auth}`);\n    parsed.username = '';\n    parsed.password = '';\n  }\n  url = '' + parsed;\n  for (let k in options.headers) {\n    const name = k.toLowerCase();\n    if (SAFE_HEADERS.has(name) || options.cors && !FORBIDDEN_HEADERS.has(name)) headers.set(k, options.headers[k]);\n  }\n  let opts = {\n    headers,\n    redirect: options.redirect ? 'follow' : 'manual'\n  };\n  if (!options.referrer) opts.referrerPolicy = 'no-referrer';\n  if (options.cors) opts.mode = 'cors';\n  if (options.data) {\n    if (!options.method) opts.method = 'POST';\n    opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n  }\n  const res = await fetch(url, opts);\n  if (options.expectStatusCode && res.status !== options.expectStatusCode) throw new InvalidStatusCodeError(res.status);\n  const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);\n  if (options.full) return {\n    headers: Object.fromEntries(res.headers.entries()),\n    status: res.status,\n    body\n  };\n  return body;\n}\nconst IS_NODE = !!(typeof process == 'object' && process.versions && process.versions.node && process.versions.v8);\nfunction fetchUrl(url, options) {\n  const fn = IS_NODE ? fetchNode : fetchBrowser;\n  return fn(url, options);\n}\nexports.default = fetchUrl;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}