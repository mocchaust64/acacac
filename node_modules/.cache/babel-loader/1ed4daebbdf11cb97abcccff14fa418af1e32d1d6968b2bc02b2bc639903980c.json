{"ast":null,"code":"import { web3, BN } from '@coral-xyz/anchor';\nimport { PublicKey, Transaction, Keypair, SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport idlFile from '../idl/moon_wallet_program.json';\n// Export programID từ biến môi trường thay vì hardcode\nexport const programID = new PublicKey(process.env.REACT_APP_PROGRAM_ID || 'DeN1rBfabZezHPvrq9q7BbzUbZkrjnHE1kQDrPK8kWQ3');\n\n// Hằng số cho chương trình secp256r1\nexport const SECP256R1_PROGRAM_ID = new PublicKey('Secp256r1SigVerify1111111111111111111111111');\n\n// Hằng số cho Sysvar accounts với địa chỉ chính xác\nexport const SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');\nexport const SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');\n\n// Sửa lỗi type cho IDL\nconst idl = idlFile;\n\n// Cập nhật: Chương trình secp256r1 là một chương trình native của Solana, \n// nên không thể kiểm tra bằng getAccountInfo\nexport const checkSecp256r1Program = async () => {\n  // Chương trình native luôn tồn tại trên validator chính thức\n  // Chỉ cần đảm bảo validator được khởi động với tham số phù hợp\n  return true;\n};\n\n// Thêm hàm kiểm tra chương trình secp256r1 thông qua transaction thử nghiệm nếu cần\nexport const testSecp256r1Instruction = async connection => {\n  try {\n    // Tạo một cặp khóa giả lập cho việc kiểm tra\n    const testKeyPair = web3.Keypair.generate();\n\n    // Tạo một chữ ký và message giả\n    const testSignature = Buffer.alloc(64, 1); // Chữ ký giả 64 bytes\n    const testPubkey = Buffer.alloc(33, 2); // Khóa công khai giả 33 bytes\n    testPubkey[0] = 0x02; // Định dạng khóa nén\n    const testMessage = Buffer.alloc(32, 3); // Message hash giả 32 bytes\n\n    // Tạo instruction secp256r1 giả - SỬA ĐỔI: đảm bảo thứ tự tham số đúng (message, publicKey, signature)\n    const testInstruction = createSecp256r1Instruction(testMessage,\n    // Message đầu tiên\n    testPubkey,\n    // Public key tiếp theo\n    testSignature // Signature cuối cùng\n    );\n\n    // Tạo transaction giả với instruction trên\n    const testTx = new web3.Transaction().add(testInstruction);\n    testTx.feePayer = testKeyPair.publicKey;\n    const {\n      blockhash\n    } = await connection.getLatestBlockhash();\n    testTx.recentBlockhash = blockhash;\n\n    // Chỉ mô phỏng giao dịch, không gửi thật\n    await connection.simulateTransaction(testTx);\n\n    // Nếu không có lỗi \"program not found\", chương trình tồn tại\n    return true;\n  } catch (error) {\n    // Kiểm tra lỗi cụ thể\n    const errorMessage = error.toString();\n    // Nếu lỗi là về chương trình không tồn tại\n    if (errorMessage.includes(\"Attempt to load a program that does not exist\") || errorMessage.includes(\"Program not found\")) {\n      console.error(\"Chương trình secp256r1 không tồn tại:\", error);\n      return false;\n    }\n\n    // Nếu là lỗi khác (vd: chữ ký không hợp lệ), chương trình vẫn tồn tại\n    console.warn(\"Lỗi khi kiểm tra secp256r1, nhưng chương trình có thể tồn tại:\", error);\n    return true;\n  }\n};\n\n// Cập nhật lại hàm tạo transaction\nexport const createInitializeMultisigTx = async (threshold, multisigPDA, owner, feePayer, recoveryHash, credentialId) => {\n  try {\n    const ownerPubkey = owner instanceof Keypair ? owner.publicKey : owner;\n\n    // Sử dụng discriminator chính xác từ IDL\n    const discriminator = Buffer.from([220, 130, 117, 21, 27, 227, 78, 213]);\n\n    // Đảm bảo recoveryHash có đúng 32 bytes\n    if (recoveryHash.length !== 32) {\n      throw new Error(\"Recovery hash phải đúng 32 bytes\");\n    }\n    const thresholdBuffer = Buffer.from([threshold]);\n    const recoveryHashBuffer = Buffer.from(recoveryHash);\n\n    // Tạo buffer cho độ dài credential ID\n    const credentialIdLenBuffer = Buffer.alloc(4);\n    credentialIdLenBuffer.writeUInt32LE(credentialId.length, 0);\n\n    // Nối tất cả lại với nhau\n    const data = Buffer.concat([new Uint8Array(discriminator), new Uint8Array(thresholdBuffer), new Uint8Array(recoveryHashBuffer), new Uint8Array(credentialIdLenBuffer), new Uint8Array(credentialId)]);\n\n    // Tạo transaction instruction\n    const instruction = new TransactionInstruction({\n      keys: [{\n        pubkey: multisigPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: feePayer.publicKey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: programID,\n      data\n    });\n    const tx = new Transaction().add(instruction);\n    return tx;\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction initialize multisig:\", error);\n    throw error;\n  }\n};\n\n// Thêm hàm compressPublicKey cho việc nén khóa công khai\nfunction compressPublicKey(uncompressedKey) {\n  // Đảm bảo khóa bắt đầu với byte 0x04 (không nén)\n  if (uncompressedKey[0] !== 0x04 || uncompressedKey.length !== 65) {\n    throw new Error('Khóa không đúng định dạng không nén ECDSA');\n  }\n\n  // Sử dụng Uint8Array để tránh lỗi type\n  const x = Buffer.from(uncompressedKey.subarray(1, 33));\n  const y = Buffer.from(uncompressedKey.subarray(33, 65));\n\n  // Tính prefix: 0x02 nếu y chẵn, 0x03 nếu y lẻ\n  const prefix = (y[31] & 1) === 0 ? 0x02 : 0x03;\n\n  // Tạo khóa nén: prefix (1 byte) + x (32 bytes)\n  const compressedKey = Buffer.alloc(33);\n  compressedKey[0] = prefix;\n  new Uint8Array(compressedKey).set(new Uint8Array(x), 1);\n  return compressedKey;\n}\n\n// Cập nhật hàm configure_webauthn với discriminator chính xác từ IDL\nexport const createConfigureWebAuthnTx = async (webauthnPubkey, multisigPDA, owner) => {\n  try {\n    // Lấy từ IDL: discriminator chính xác cho hàm configure_webauthn\n    const discriminator = Buffer.from([40, 149, 116, 224, 148, 48, 159, 54]);\n\n    // Nén khóa công khai từ 65 bytes xuống 33 bytes\n    let compressedKey;\n    if (webauthnPubkey.length === 65 && webauthnPubkey[0] === 0x04) {\n      // Khóa không nén, cần nén lại\n      compressedKey = compressPublicKey(webauthnPubkey);\n      console.log(\"Đã nén khóa từ 65 bytes xuống 33 bytes\");\n    } else if (webauthnPubkey.length === 33 && (webauthnPubkey[0] === 0x02 || webauthnPubkey[0] === 0x03)) {\n      // Khóa đã nén, sử dụng trực tiếp\n      compressedKey = webauthnPubkey;\n      console.log(\"Khóa đã ở định dạng nén (33 bytes)\");\n    } else {\n      console.warn(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPubkey.length} bytes`);\n      // Nếu không thể xử lý, tạo khóa giả\n      compressedKey = Buffer.alloc(33);\n      compressedKey[0] = 0x02; // Prefix cho khóa nén\n      if (webauthnPubkey.length > 0) {\n        // Sao chép dữ liệu nếu có\n        new Uint8Array(compressedKey).set(new Uint8Array(webauthnPubkey.subarray(0, Math.min(webauthnPubkey.length, 32))), 1);\n      }\n    }\n    console.log(\"Khóa công khai WebAuthn (nén):\", compressedKey.toString('hex'));\n    console.log(\"Độ dài khóa (bytes):\", compressedKey.length);\n\n    // Tạo dữ liệu instruction\n    const data = Buffer.concat([new Uint8Array(discriminator), new Uint8Array(compressedKey)]);\n\n    // Tạo instruction với đúng accounts theo IDL\n    const instruction = new TransactionInstruction({\n      keys: [{\n        pubkey: multisigPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: programID,\n      data\n    });\n    const tx = new Transaction().add(instruction);\n    return tx;\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction configure webauthn:\", error);\n    throw error;\n  }\n};\n\n/**\n * Tạo transaction cho storePasswordHash\n */\nexport const createStorePasswordHashTx = async (passwordHash, multisigPDA, ownerPubkey) => {\n  const tx = new web3.Transaction();\n\n  // Sửa lỗi Buffer.from\n  const discriminator = Buffer.from([\n  // Thay thế với giá trị discriminator thực tế\n  125, 106, 39, 42, 99, 108, 43, 50]);\n\n  // Sửa lại cách tạo data buffer\n  const data = Buffer.concat([new Uint8Array(discriminator), new Uint8Array(Buffer.from(Array.from(passwordHash)))]);\n\n  // Thêm instruction để lưu password hash\n  tx.add(new web3.TransactionInstruction({\n    keys: [{\n      pubkey: multisigPDA,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: ownerPubkey,\n      isSigner: true,\n      isWritable: false\n    }],\n    programId: programID,\n    data: data\n  }));\n  return tx;\n};\n\n/**\n * Tạo transaction xác thực WebAuthn\n */\nexport const createWebAuthnAuthTx = async (multisigPDA, ownerPubkey, webauthnSignature, authenticatorData, clientDataJSON) => {\n  const tx = new web3.Transaction();\n\n  // Thêm discriminator đúng cho verify_webauthn_auth\n  const instructionData = Buffer.concat([new Uint8Array(Buffer.from([234, 182, 165, 23, 186, 223, 208, 119])),\n  // discriminator từ IDL\n  new Uint8Array(Buffer.from(webauthnSignature)), new Uint8Array(Buffer.from(authenticatorData)), new Uint8Array(Buffer.from(clientDataJSON))]);\n  const instruction = new web3.TransactionInstruction({\n    keys: [{\n      pubkey: multisigPDA,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: ownerPubkey,\n      isSigner: false,\n      isWritable: false\n    }],\n    programId: programID,\n    data: instructionData\n  });\n  tx.add(instruction);\n  return tx;\n};\n\n// Tạo hàm mới createAddGuardianTx\nexport const createAddGuardianTx = (multisigPDA, guardianPDA, guardianPubkey, guardianName, recoveryHash, isOwner, webauthnPubkey) => {\n  try {\n    // Discriminator cho add_guardian\n    const discriminator = Buffer.from([167, 189, 170, 27, 74, 240, 201, 241]);\n\n    // Tạo buffer cho tên guardian\n    const nameBuffer = Buffer.from(guardianName);\n    const nameLenBuffer = Buffer.alloc(4);\n    nameLenBuffer.writeUInt32LE(nameBuffer.length, 0);\n\n    // Tạo buffer cho các tham số\n    const isOwnerByte = Buffer.from([isOwner ? 1 : 0]);\n\n    // Tạo buffers cho instruction data\n    const dataBuffers = [discriminator, guardianPubkey.toBuffer(), nameLenBuffer, nameBuffer, Buffer.from(recoveryHash)];\n\n    // Thêm isOwner\n    dataBuffers.push(isOwnerByte);\n\n    // Xử lý webauthn_pubkey (option)\n    if (webauthnPubkey && isOwner) {\n      // Some variant (1)\n      dataBuffers.push(Buffer.from([1]));\n\n      // Nén khóa công khai nếu cần\n      let compressedKey;\n      if (webauthnPubkey.length === 65 && webauthnPubkey[0] === 0x04) {\n        // Khóa không nén, cần nén lại\n        compressedKey = compressPublicKey(webauthnPubkey);\n      } else if (webauthnPubkey.length === 33 && (webauthnPubkey[0] === 0x02 || webauthnPubkey[0] === 0x03)) {\n        // Khóa đã nén, sử dụng trực tiếp\n        compressedKey = webauthnPubkey;\n      } else {\n        throw new Error(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPubkey.length} bytes`);\n      }\n      dataBuffers.push(compressedKey);\n    } else {\n      // None variant (0)\n      dataBuffers.push(Buffer.from([0]));\n    }\n\n    // Nối tất cả buffer lại với nhau\n    const data = Buffer.concat(dataBuffers.map(buffer => new Uint8Array(buffer)));\n\n    // Tạo instruction\n    const instruction = new TransactionInstruction({\n      keys: [{\n        pubkey: multisigPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: guardianPDA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: guardianPubkey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: programID,\n      data\n    });\n    return new Transaction().add(instruction);\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction add guardian:\", error);\n    throw error;\n  }\n};\n\n// Thêm các hằng số cho curve secp256r1 - dựa trên file test đã hoạt động\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 14;\nconst SIGNATURE_OFFSETS_START = 2;\nconst DATA_START = SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START;\nconst SIGNATURE_SERIALIZED_SIZE = 64;\nconst COMPRESSED_PUBKEY_SERIALIZED_SIZE = 33;\n\n// Order của curve secp256r1\nconst SECP256R1_ORDER = new Uint8Array([0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51]);\n\n// Nửa order của curve secp256r1\nconst SECP256R1_HALF_ORDER = new Uint8Array([0x7f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xde, 0x73, 0x7d, 0x56, 0xd3, 0x8b, 0xcf, 0x42, 0x79, 0xdc, 0xe5, 0x61, 0x7e, 0x31, 0x92, 0xa8]);\n\n// Thêm hàm so sánh số lớn\nfunction isGreaterThan(a, b) {\n  const aBuf = Buffer.isBuffer(a) ? a : Buffer.from(a);\n  if (aBuf.length !== b.length) {\n    return aBuf.length > b.length;\n  }\n  for (let i = 0; i < aBuf.length; i++) {\n    if (aBuf[i] !== b[i]) {\n      return aBuf[i] > b[i];\n    }\n  }\n  return false;\n}\n\n// Sửa lại hàm subtractBigNumbers để xử lý big-endian đúng cách\nfunction subtractBigNumbers(a, b) {\n  const bBuf = Buffer.isBuffer(b) ? b : Buffer.from(b);\n  const result = new Uint8Array(a.length);\n  let borrow = 0;\n\n  // Đảm bảo cả a và b đều có đúng 32 bytes\n  if (a.length !== 32 || bBuf.length !== 32) {\n    console.error(`Độ dài không đúng: a=${a.length}, b=${bBuf.length}, phải là 32 bytes`);\n  }\n\n  // Tính từ byte ít quan trọng nhất đến quan trọng nhất (big endian)\n  for (let i = a.length - 1; i >= 0; i--) {\n    let diff = a[i] - bBuf[i] - borrow;\n    if (diff < 0) {\n      diff += 256;\n      borrow = 1;\n    } else {\n      borrow = 0;\n    }\n    result[i] = diff;\n  }\n\n  // Log giá trị input và output để debug\n  console.log('Input a (hex):', Buffer.from(a).toString('hex'));\n  console.log('Input b (hex):', Buffer.from(bBuf).toString('hex'));\n  console.log('Result (hex):', Buffer.from(result).toString('hex'));\n  return result;\n}\n\n/**\n * Tạo instruction cho chương trình Secp256r1SigVerify\n * Cài đặt dựa trên file test đã hoạt động thành công\n * @param message Message đã hash (32 bytes)\n * @param publicKey Khóa công khai secp256r1 (dạng nén, 33 bytes)\n * @param signature Chữ ký (64 bytes)\n */\nexport const createSecp256r1Instruction = (message, publicKey, signature) => {\n  try {\n    console.log('Tạo secp256r1 instruction...');\n    console.log('- Message length:', message.length, 'bytes:', message.toString('hex'));\n    console.log('- Public key length:', publicKey.length, 'bytes:', publicKey.toString('hex'));\n    console.log('- Signature length:', signature.length, 'bytes:', signature.toString('hex'));\n\n    // Kiểm tra kích thước\n    if (message.length !== 32) {\n      throw new Error(`Message phải có độ dài 32 bytes, nhận được ${message.length} bytes`);\n    }\n    if (publicKey.length !== COMPRESSED_PUBKEY_SERIALIZED_SIZE) {\n      throw new Error(`Public key phải có độ dài 33 bytes (dạng nén), nhận được ${publicKey.length} bytes`);\n    }\n    if (signature.length !== SIGNATURE_SERIALIZED_SIZE) {\n      throw new Error(`Signature phải có độ dài 64 bytes, nhận được ${signature.length} bytes`);\n    }\n\n    // Tách r và s từ signature\n    const r = signature.slice(0, 32);\n    const s = signature.slice(32, 64);\n    console.log('Signature components:');\n    console.log('- r (hex):', r.toString('hex'));\n    console.log('- s (hex):', s.toString('hex'));\n\n    // QUAN TRỌNG: Chuẩn hóa s nếu cần\n    // Solana yêu cầu s phải trong phạm vi canonical (s <= half_order)\n    let finalSignature = signature;\n    if (isGreaterThan(s, SECP256R1_HALF_ORDER)) {\n      console.log('Chuẩn hóa signature: s > HALF_ORDER, thực hiện s = ORDER - s');\n      const newS = subtractBigNumbers(SECP256R1_ORDER, s);\n      finalSignature = Buffer.concat([r, Buffer.from(newS)]);\n      console.log('Signature sau khi chuẩn hóa (hex):', finalSignature.toString('hex'));\n    } else {\n      console.log('Signature đã chuẩn hóa, không cần thay đổi');\n    }\n\n    // SỬA CHỮA: Tạo phiên bản chữ ký thứ hai với s chuẩn hóa ngược lại \n    // (đôi khi cách chuẩn hóa có thể ngược với những gì mong đợi)\n    let alternativeSignature = signature;\n    if (!isGreaterThan(s, SECP256R1_HALF_ORDER)) {\n      // Nếu s nhỏ hơn HALF_ORDER, thử ORDER - s\n      console.log('Thử phiên bản chữ ký thay thế: s < HALF_ORDER, thực hiện s = ORDER - s');\n      const altS = subtractBigNumbers(SECP256R1_ORDER, s);\n      alternativeSignature = Buffer.concat([r, Buffer.from(altS)]);\n      console.log('Phiên bản chữ ký thay thế (hex):', alternativeSignature.toString('hex'));\n    }\n    console.log('Thử cả hai phiên bản của chữ ký (gốc và chuẩn hóa)');\n\n    // Tính toán tổng kích thước instruction data\n    const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + message.length;\n    const instructionData = Buffer.alloc(totalSize);\n\n    // Header - giống mẫu\n    instructionData.writeUInt8(1, 0); // num_signatures = 1\n    instructionData.writeUInt8(0, 1); // padding\n\n    // Tính offset theo mẫu thành công\n    const publicKeyOffset = DATA_START;\n    const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n    const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n\n    // Ghi offset vào instructionData - chính xác như mẫu\n    instructionData.writeUInt16LE(signatureOffset, SIGNATURE_OFFSETS_START);\n    instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 2);\n    instructionData.writeUInt16LE(publicKeyOffset, SIGNATURE_OFFSETS_START + 4);\n    instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 6);\n    instructionData.writeUInt16LE(messageDataOffset, SIGNATURE_OFFSETS_START + 8);\n    instructionData.writeUInt16LE(message.length, SIGNATURE_OFFSETS_START + 10);\n    instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 12);\n\n    // Copy data vào đúng vị trí theo mẫu\n    publicKey.copy(instructionData, publicKeyOffset); // Public key trước\n    finalSignature.copy(instructionData, signatureOffset); // Signature đã được chuẩn hóa\n    message.copy(instructionData, messageDataOffset); // Message cuối cùng\n\n    console.log('Secp256r1 instruction data:');\n    console.log(`- Total size: ${instructionData.length} bytes`);\n    console.log(`- Public key offset: ${publicKeyOffset}`);\n    console.log(`- Signature offset: ${signatureOffset}`);\n    console.log(`- Message offset: ${messageDataOffset}`);\n\n    // Lưu chữ ký thay thế để sử dụng khi cần\n    instructionData.alternativeSignature = alternativeSignature;\n    return new web3.TransactionInstruction({\n      keys: [],\n      programId: SECP256R1_PROGRAM_ID,\n      data: instructionData\n    });\n  } catch (error) {\n    console.error('❌ Lỗi khi tạo secp256r1 instruction:', error);\n    throw error;\n  }\n};\n\n/**\n * Kiểm tra xem chữ ký secp256r1 có hợp lệ không bằng cách mô phỏng transaction\n * @param connection Kết nối đến Solana cluster\n * @param publicKey Khóa công khai (dạng nén) dùng để xác minh\n * @param signature Chữ ký (raw format, 64 bytes) cần xác minh\n * @param message Message đã hash (32 bytes) đã được ký\n * @returns Promise<{isValid: boolean, error?: string}> Kết quả kiểm tra và lỗi nếu có\n */\nexport const testSecp256r1Signature = async (connection, publicKey, signature, message) => {\n  try {\n    // Hiển thị thông tin chi tiết để debug\n    console.log('=== DEBUG: testSecp256r1Signature ===');\n    console.log('- Message (hex):', message.toString('hex'));\n    console.log('- Public key (hex):', publicKey.toString('hex'));\n    console.log('- Signature (hex):', signature.toString('hex'));\n\n    // Log: Xác minh các giá trị đầu vào\n    if (message.length !== 32) console.warn('⚠️ WARNING: Message không phải 32 bytes');\n    if (publicKey.length !== 33) console.warn('⚠️ WARNING: Public key không phải 33 bytes');\n    if (signature.length !== 64) console.warn('⚠️ WARNING: Signature không phải 64 bytes');\n    if (publicKey[0] !== 0x02 && publicKey[0] !== 0x03) {\n      console.warn('⚠️ WARNING: Public key không ở định dạng nén đúng (byte đầu phải là 0x02 hoặc 0x03)');\n    }\n\n    // PHƯƠNG PHÁP 1: Thử xác minh với cách triển khai gốc (tương tự test_verify.js)\n    console.log('PHƯƠNG PHÁP 1: Thử xác minh với cách triển khai gốc (tương tự test_verify.js)');\n    const result1 = await testWithOriginalImplementation(connection, message, publicKey, signature);\n    if (result1.isValid) {\n      console.log('✅ PHƯƠNG PHÁP 1 THÀNH CÔNG!');\n      return {\n        isValid: true\n      };\n    }\n    console.log('❌ PHƯƠNG PHÁP 1 THẤT BẠI:', result1.error);\n\n    // Tách r và s từ signature\n    const r = signature.slice(0, 32);\n    const s = signature.slice(32, 64);\n\n    // Thử với phiên bản chuẩn hóa s (nếu cần)\n    console.log('PHƯƠNG PHÁP 2: Thử với chữ ký đã chuẩn hóa');\n    let normalizedSignature = signature;\n    if (isGreaterThan(s, SECP256R1_HALF_ORDER)) {\n      console.log('Chuẩn hóa signature: s > HALF_ORDER, thực hiện s = ORDER - s');\n      const newS = subtractBigNumbers(SECP256R1_ORDER, s);\n      normalizedSignature = Buffer.concat([r, Buffer.from(newS)]);\n      console.log('Signature sau khi chuẩn hóa (hex):', normalizedSignature.toString('hex'));\n      const result2 = await testWithOriginalImplementation(connection, message, publicKey, normalizedSignature);\n      if (result2.isValid) {\n        console.log('✅ PHƯƠNG PHÁP 2 THÀNH CÔNG!');\n        return {\n          isValid: true\n        };\n      }\n      console.log('❌ PHƯƠNG PHÁP 2 THẤT BẠI:', result2.error);\n    } else {\n      console.log('Signature đã chuẩn hóa, không cần thay đổi. Bỏ qua phương pháp 2.');\n    }\n\n    // Thử với phiên bản ngược lại của chuẩn hóa\n    console.log('PHƯƠNG PHÁP 3: Thử với chữ ký chuẩn hóa ngược lại');\n    if (!isGreaterThan(s, SECP256R1_HALF_ORDER)) {\n      console.log('Thử nghiệm ngược lại: s < HALF_ORDER, thực hiện s = ORDER - s');\n      const altS = subtractBigNumbers(SECP256R1_ORDER, s);\n      const reverseNormalizedSignature = Buffer.concat([r, Buffer.from(altS)]);\n      console.log('Chữ ký chuẩn hóa ngược (hex):', reverseNormalizedSignature.toString('hex'));\n      const result3 = await testWithOriginalImplementation(connection, message, publicKey, reverseNormalizedSignature);\n      if (result3.isValid) {\n        console.log('✅ PHƯƠNG PHÁP 3 THÀNH CÔNG!');\n        return {\n          isValid: true\n        };\n      }\n      console.log('❌ PHƯƠNG PHÁP 3 THẤT BẠI:', result3.error);\n    } else {\n      console.log('Không thử phương pháp 3 vì s > HALF_ORDER.');\n    }\n\n    // PHƯƠNG PHÁP 4: Thử với số lượng chữ ký khác\n    console.log('PHƯƠNG PHÁP 4: Thử với num_signatures = 0');\n    try {\n      const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + message.length;\n      const instructionData = Buffer.alloc(totalSize);\n\n      // Thay đổi số lượng signatures\n      instructionData.writeUInt8(0, 0); // num_signatures = 0 thay vì 1\n      instructionData.writeUInt8(0, 1); // padding\n\n      // Tính offset\n      const publicKeyOffset = DATA_START;\n      const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n      const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n\n      // Ghi offsets\n      instructionData.writeUInt16LE(signatureOffset, SIGNATURE_OFFSETS_START);\n      instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 2);\n      instructionData.writeUInt16LE(publicKeyOffset, SIGNATURE_OFFSETS_START + 4);\n      instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 6);\n      instructionData.writeUInt16LE(messageDataOffset, SIGNATURE_OFFSETS_START + 8);\n      instructionData.writeUInt16LE(message.length, SIGNATURE_OFFSETS_START + 10);\n      instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 12);\n\n      // Copy data\n      publicKey.copy(instructionData, publicKeyOffset);\n      signature.copy(instructionData, signatureOffset);\n      message.copy(instructionData, messageDataOffset);\n\n      // Tạo instruction\n      const instruction = new web3.TransactionInstruction({\n        keys: [],\n        programId: SECP256R1_PROGRAM_ID,\n        data: instructionData\n      });\n\n      // Tạo một feePayer mới\n      const feePayer = web3.Keypair.generate();\n\n      // Airdrop SOL cho feePayer\n      const airdropSignature = await connection.requestAirdrop(feePayer.publicKey, web3.LAMPORTS_PER_SOL / 100);\n      await connection.confirmTransaction(airdropSignature);\n\n      // Tạo transaction\n      const transaction = new web3.Transaction();\n      const blockhash = await connection.getLatestBlockhash();\n      transaction.recentBlockhash = blockhash.blockhash;\n      transaction.feePayer = feePayer.publicKey;\n      transaction.add(instruction);\n\n      // Ký transaction\n      transaction.sign(feePayer);\n\n      // Mô phỏng transaction\n      console.log('Đang mô phỏng transaction với num_signatures = 0...');\n      const simulationResult = await connection.simulateTransaction(transaction);\n      if (!simulationResult.value.err) {\n        console.log('✅ PHƯƠNG PHÁP 4 THÀNH CÔNG!');\n        return {\n          isValid: true\n        };\n      }\n      console.log('❌ PHƯƠNG PHÁP 4 THẤT BẠI:', JSON.stringify(simulationResult.value.err));\n    } catch (error) {\n      console.error('Lỗi khi thử nghiệm phương pháp 4:', error);\n    }\n\n    // PHƯƠNG PHÁP 5: Thử với chữ ký ở định dạng DER\n    console.log('PHƯƠNG PHÁP 5: Thử với chữ ký ở định dạng DER');\n    try {\n      // Chuyển đổi signature raw sang định dạng DER\n      const rBuffer = stripLeadingZeros(r);\n      const sBuffer = stripLeadingZeros(s);\n\n      // Tạo DER signature\n      // Format: 30 L 02 Lr r 02 Ls s\n      let rWithPrefix = rBuffer;\n      let sWithPrefix = sBuffer;\n      if (rBuffer[0] & 0x80) {\n        rWithPrefix = Buffer.concat([Buffer.from([0x00]), rBuffer]);\n      }\n      if (sBuffer[0] & 0x80) {\n        sWithPrefix = Buffer.concat([Buffer.from([0x00]), sBuffer]);\n      }\n      const rLength = rWithPrefix.length;\n      const sLength = sWithPrefix.length;\n      const totalLength = rLength + sLength + 4; // 4 = 2 bytes cho INTEGER tags và 2 bytes cho lengths\n\n      const derSignature = Buffer.alloc(totalLength + 2); // +2 cho SEQUENCE tag và length\n\n      // SEQUENCE tag\n      derSignature[0] = 0x30;\n      // SEQUENCE length\n      derSignature[1] = totalLength;\n      // INTEGER tag cho r\n      derSignature[2] = 0x02;\n      // Chiều dài của r\n      derSignature[3] = rLength;\n      // Giá trị r\n      rWithPrefix.copy(derSignature, 4);\n      // INTEGER tag cho s\n      derSignature[4 + rLength] = 0x02;\n      // Chiều dài của s\n      derSignature[5 + rLength] = sLength;\n      // Giá trị s\n      sWithPrefix.copy(derSignature, 6 + rLength);\n      console.log('DER signature (hex):', derSignature.toString('hex'));\n\n      // Tạo instruction data với DER signature\n      const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + message.length;\n      const instructionData = Buffer.alloc(totalSize);\n      instructionData.writeUInt8(1, 0); // num_signatures = 1\n      instructionData.writeUInt8(0, 1); // padding\n\n      // Tính offset\n      const publicKeyOffset = DATA_START;\n      const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n      const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n\n      // Ghi offsets\n      instructionData.writeUInt16LE(signatureOffset, SIGNATURE_OFFSETS_START);\n      instructionData.writeUInt16LE(derSignature.length, SIGNATURE_OFFSETS_START + 2);\n      instructionData.writeUInt16LE(publicKeyOffset, SIGNATURE_OFFSETS_START + 4);\n      instructionData.writeUInt16LE(publicKey.length, SIGNATURE_OFFSETS_START + 6);\n      instructionData.writeUInt16LE(messageDataOffset, SIGNATURE_OFFSETS_START + 8);\n      instructionData.writeUInt16LE(message.length, SIGNATURE_OFFSETS_START + 10);\n      instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 12);\n\n      // Copy data\n      publicKey.copy(instructionData, publicKeyOffset);\n\n      // Copy DER signature và padding với 0 nếu cần\n      const paddedDerSignature = Buffer.alloc(SIGNATURE_SERIALIZED_SIZE);\n      derSignature.copy(paddedDerSignature);\n      paddedDerSignature.copy(instructionData, signatureOffset);\n      message.copy(instructionData, messageDataOffset);\n\n      // Tạo instruction\n      const instruction = new web3.TransactionInstruction({\n        keys: [],\n        programId: SECP256R1_PROGRAM_ID,\n        data: instructionData\n      });\n\n      // Tạo một feePayer mới\n      const feePayer = web3.Keypair.generate();\n\n      // Airdrop SOL cho feePayer\n      const airdropSignature = await connection.requestAirdrop(feePayer.publicKey, web3.LAMPORTS_PER_SOL / 100);\n      await connection.confirmTransaction(airdropSignature);\n\n      // Tạo transaction\n      const transaction = new web3.Transaction();\n      const blockhash = await connection.getLatestBlockhash();\n      transaction.recentBlockhash = blockhash.blockhash;\n      transaction.feePayer = feePayer.publicKey;\n      transaction.add(instruction);\n\n      // Ký transaction\n      transaction.sign(feePayer);\n\n      // Mô phỏng transaction\n      console.log('Đang mô phỏng transaction với DER signature...');\n      const simulationResult = await connection.simulateTransaction(transaction);\n      if (!simulationResult.value.err) {\n        console.log('✅ PHƯƠNG PHÁP 5 THÀNH CÔNG!');\n        return {\n          isValid: true\n        };\n      }\n      console.log('❌ PHƯƠNG PHÁP 5 THẤT BẠI:', JSON.stringify(simulationResult.value.err));\n    } catch (error) {\n      console.error('Lỗi khi thử nghiệm phương pháp 5:', error);\n    }\n\n    // Tất cả phương pháp đều thất bại\n    return {\n      isValid: false,\n      error: 'Tất cả các phương pháp xác minh đều thất bại'\n    };\n  } catch (error) {\n    console.error('Lỗi khi kiểm tra chữ ký secp256r1:', error);\n    return {\n      isValid: false,\n      error: error.toString()\n    };\n  }\n};\n\n// Hàm để loại bỏ các byte 0 ở đầu của một buffer\nfunction stripLeadingZeros(buffer) {\n  let i = 0;\n  while (i < buffer.length && buffer[i] === 0) {\n    i++;\n  }\n  return i === 0 ? buffer : buffer.slice(i);\n}\n\n/**\n * Thử nghiệm với cách triển khai giống hệt với test_verify.js\n * @param connection Kết nối Solana\n * @param messageHash Hash của message (32 bytes)\n * @param publicKey Public key dạng nén (33 bytes)\n * @param signature Signature (64 bytes)\n */\nexport const testWithOriginalImplementation = async (connection, messageHash, publicKey, signature) => {\n  try {\n    console.log('=== KIỂM TRA THEO CÁCH TRIỂN KHAI GỐC ===');\n    console.log('Message hash:', messageHash.toString('hex'));\n    console.log('Public key:', publicKey.toString('hex'));\n    console.log('Signature:', signature.toString('hex'));\n\n    // Tạo một feePayer mới\n    const feePayer = web3.Keypair.generate();\n\n    // Airdrop SOL cho feePayer\n    const airdropSignature = await connection.requestAirdrop(feePayer.publicKey, web3.LAMPORTS_PER_SOL / 100);\n    await connection.confirmTransaction(airdropSignature);\n\n    // Tính toán kích thước instruction data\n    const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + messageHash.length;\n    const instructionData = Buffer.alloc(totalSize);\n\n    // Header - num_signatures=1, padding=0\n    instructionData.writeUInt8(1, 0);\n    instructionData.writeUInt8(0, 1);\n\n    // Offsets\n    const publicKeyOffset = DATA_START;\n    const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n    const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n\n    // Write offsets - CHÍNH XÁC giống test_verify.js\n    instructionData.writeUInt16LE(signatureOffset, SIGNATURE_OFFSETS_START);\n    instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 2);\n    instructionData.writeUInt16LE(publicKeyOffset, SIGNATURE_OFFSETS_START + 4);\n    instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 6);\n    instructionData.writeUInt16LE(messageDataOffset, SIGNATURE_OFFSETS_START + 8);\n    instructionData.writeUInt16LE(messageHash.length, SIGNATURE_OFFSETS_START + 10);\n    instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 12);\n\n    // Write data - CHÍNH XÁC giống test_verify.js\n    publicKey.copy(instructionData, publicKeyOffset);\n    signature.copy(instructionData, signatureOffset);\n    messageHash.copy(instructionData, messageDataOffset);\n\n    // Tạo instruction\n    const instruction = new web3.TransactionInstruction({\n      keys: [],\n      programId: SECP256R1_PROGRAM_ID,\n      data: instructionData\n    });\n\n    // Tạo transaction\n    const transaction = new web3.Transaction();\n    const blockhash = await connection.getLatestBlockhash();\n    transaction.recentBlockhash = blockhash.blockhash;\n    transaction.feePayer = feePayer.publicKey;\n    transaction.add(instruction);\n\n    // Ký transaction\n    transaction.sign(feePayer);\n\n    // Mô phỏng transaction\n    console.log('Đang mô phỏng transaction theo cách triển khai gốc...');\n    try {\n      const simulationResult = await connection.simulateTransaction(transaction);\n      if (simulationResult.value.err) {\n        const errorString = JSON.stringify(simulationResult.value.err);\n        console.error('Lỗi mô phỏng (cách gốc):', errorString);\n        return {\n          isValid: false,\n          error: errorString\n        };\n      }\n      console.log('✅ Mô phỏng thành công!');\n      return {\n        isValid: true\n      };\n    } catch (error) {\n      console.error('Lỗi khi mô phỏng transaction (cách gốc):', error);\n      return {\n        isValid: false,\n        error: error.toString()\n      };\n    }\n  } catch (error) {\n    console.error('Lỗi trong testWithOriginalImplementation:', error);\n    return {\n      isValid: false,\n      error: error.toString()\n    };\n  }\n};\n\n/**\n * Tạo giao dịch chuyển SOL hoặc token\n * @param multisigPDA PDA của ví multisig\n * @param destination Địa chỉ nhận\n * @param amount Số lượng cần chuyển (lamports cho SOL, units cho token)\n * @param mint Địa chỉ token mint (null nếu chuyển SOL)\n * @param connection Kết nối Solana\n * @param webauthnPublicKey Khóa công khai WebAuthn (tùy chọn)\n * @param webauthnSignature Chữ ký WebAuthn (tùy chọn)\n * @param message Tin nhắn đã ký (tùy chọn)\n * @param timestamp Thời gian thực hiện (tùy chọn)\n */\nexport const createTransferTx = async (multisigPDA, destination, amount, mint, connection, webauthnPublicKey, webauthnSignature, message, timestamp) => {\n  try {\n    console.log('Tạo giao dịch chuyển tiền...');\n    const isToken = mint !== null;\n\n    // Discriminator cho transfer_sol hoặc transfer_token\n    const discriminator = isToken ? Buffer.from([22, 93, 192, 70, 30, 202, 101, 106]) // transfer_token\n    : Buffer.from([85, 115, 0, 198, 211, 138, 226, 246]); // transfer_sol\n\n    // Chuyển đổi amount sang BN nếu nó là số\n    const amountBN = typeof amount === 'number' ? new BN(amount) : amount;\n\n    // Tạo buffer cho amount (8 bytes)\n    const amountBuffer = Buffer.alloc(8);\n    amountBN.toArrayLike(Buffer, 'le', 8).copy(amountBuffer);\n\n    // Chuẩn bị buffers cho instruction data\n    const dataBuffers = [discriminator, destination.toBuffer(), amountBuffer];\n\n    // Thêm mint nếu chuyển token\n    if (isToken) {\n      dataBuffers.push(mint.toBuffer());\n    }\n\n    // Thêm timestamp nếu có\n    if (timestamp) {\n      const timestampBuffer = Buffer.alloc(8);\n      new BN(timestamp).toArrayLike(Buffer, 'le', 8).copy(timestampBuffer);\n      dataBuffers.push(timestampBuffer);\n    }\n\n    // Thêm webauthn signature nếu có\n    if (webauthnPublicKey && webauthnSignature && message) {\n      // Some variant (1)\n      dataBuffers.push(Buffer.from([1]));\n\n      // Nén webauthnPublicKey nếu cần\n      let compressedKey;\n      if (webauthnPublicKey.length === 65 && webauthnPublicKey[0] === 0x04) {\n        compressedKey = compressPublicKey(webauthnPublicKey);\n      } else if (webauthnPublicKey.length === 33 && (webauthnPublicKey[0] === 0x02 || webauthnPublicKey[0] === 0x03)) {\n        compressedKey = webauthnPublicKey;\n      } else {\n        throw new Error(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPublicKey.length} bytes`);\n      }\n\n      // Gộp message, public key và signature vào instruction data\n      dataBuffers.push(message);\n      dataBuffers.push(compressedKey);\n      dataBuffers.push(webauthnSignature);\n    } else {\n      // None variant (0)\n      dataBuffers.push(Buffer.from([0]));\n    }\n\n    // Nối tất cả buffer lại\n    const data = Buffer.concat(dataBuffers.map(buffer => Buffer.isBuffer(buffer) ? new Uint8Array(buffer) : new Uint8Array(buffer)));\n\n    // Xác định các accounts cần thiết dựa trên loại giao dịch\n    const keys = [{\n      pubkey: multisigPDA,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: destination,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false\n    }];\n\n    // Thêm các accounts cần thiết cho token transfer\n    if (isToken) {\n      // Lấy token accounts\n      const multisigTokenAccount = await connection.getTokenAccountsByOwner(multisigPDA, {\n        mint: mint\n      });\n      if (multisigTokenAccount.value.length === 0) {\n        throw new Error(`Không tìm thấy token account cho mint ${mint.toString()}`);\n      }\n      const sourceTokenAccount = multisigTokenAccount.value[0].pubkey;\n\n      // Kiểm tra hoặc tạo token account đích\n      let destinationTokenAccount;\n      try {\n        const destTokenAccounts = await connection.getTokenAccountsByOwner(destination, {\n          mint: mint\n        });\n        if (destTokenAccounts.value.length > 0) {\n          destinationTokenAccount = destTokenAccounts.value[0].pubkey;\n        } else {\n          throw new Error('Cần tạo token account đích');\n        }\n      } catch (error) {\n        console.warn('Không tìm thấy token account đích, cần tạo mới');\n        // Trong trường hợp thực tế, bạn có thể muốn tạo token account đích\n        // trong một transaction riêng trước khi gọi hàm này\n        throw new Error('Người nhận chưa có token account cho loại token này');\n      }\n\n      // Import Token Program (cần đảm bảo đã import ở đầu file)\n      const TOKEN_PROGRAM_ID = new web3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n\n      // Thêm accounts cần thiết cho giao dịch token\n      keys.splice(1, 0, {\n        pubkey: sourceTokenAccount,\n        isSigner: false,\n        isWritable: true\n      });\n      keys.splice(2, 0, {\n        pubkey: destinationTokenAccount,\n        isSigner: false,\n        isWritable: true\n      });\n      keys.splice(3, 0, {\n        pubkey: TOKEN_PROGRAM_ID,\n        isSigner: false,\n        isWritable: false\n      });\n      keys.splice(4, 0, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: false\n      });\n    }\n\n    // Tạo instruction\n    const instruction = new web3.TransactionInstruction({\n      keys,\n      programId: programID,\n      data\n    });\n\n    // Tạo transaction\n    const transaction = new web3.Transaction().add(instruction);\n    return transaction;\n  } catch (error) {\n    console.error('Lỗi khi tạo giao dịch chuyển tiền:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["web3","BN","PublicKey","Transaction","Keypair","SystemProgram","TransactionInstruction","Buffer","idlFile","programID","process","env","REACT_APP_PROGRAM_ID","SECP256R1_PROGRAM_ID","SYSVAR_INSTRUCTIONS_PUBKEY","SYSVAR_CLOCK_PUBKEY","idl","checkSecp256r1Program","testSecp256r1Instruction","connection","testKeyPair","generate","testSignature","alloc","testPubkey","testMessage","testInstruction","createSecp256r1Instruction","testTx","add","feePayer","publicKey","blockhash","getLatestBlockhash","recentBlockhash","simulateTransaction","error","errorMessage","toString","includes","console","warn","createInitializeMultisigTx","threshold","multisigPDA","owner","recoveryHash","credentialId","ownerPubkey","discriminator","from","length","Error","thresholdBuffer","recoveryHashBuffer","credentialIdLenBuffer","writeUInt32LE","data","concat","Uint8Array","instruction","keys","pubkey","isSigner","isWritable","programId","tx","compressPublicKey","uncompressedKey","x","subarray","y","prefix","compressedKey","set","createConfigureWebAuthnTx","webauthnPubkey","log","Math","min","createStorePasswordHashTx","passwordHash","Array","createWebAuthnAuthTx","webauthnSignature","authenticatorData","clientDataJSON","instructionData","createAddGuardianTx","guardianPDA","guardianPubkey","guardianName","isOwner","nameBuffer","nameLenBuffer","isOwnerByte","dataBuffers","toBuffer","push","map","buffer","SIGNATURE_OFFSETS_SERIALIZED_SIZE","SIGNATURE_OFFSETS_START","DATA_START","SIGNATURE_SERIALIZED_SIZE","COMPRESSED_PUBKEY_SERIALIZED_SIZE","SECP256R1_ORDER","SECP256R1_HALF_ORDER","isGreaterThan","a","b","aBuf","isBuffer","i","subtractBigNumbers","bBuf","result","borrow","diff","message","signature","r","slice","s","finalSignature","newS","alternativeSignature","altS","totalSize","writeUInt8","publicKeyOffset","signatureOffset","messageDataOffset","writeUInt16LE","copy","testSecp256r1Signature","result1","testWithOriginalImplementation","isValid","normalizedSignature","result2","reverseNormalizedSignature","result3","airdropSignature","requestAirdrop","LAMPORTS_PER_SOL","confirmTransaction","transaction","sign","simulationResult","value","err","JSON","stringify","rBuffer","stripLeadingZeros","sBuffer","rWithPrefix","sWithPrefix","rLength","sLength","totalLength","derSignature","paddedDerSignature","messageHash","errorString","createTransferTx","destination","amount","mint","webauthnPublicKey","timestamp","isToken","amountBN","amountBuffer","toArrayLike","timestampBuffer","multisigTokenAccount","getTokenAccountsByOwner","sourceTokenAccount","destinationTokenAccount","destTokenAccounts","TOKEN_PROGRAM_ID","splice"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/frontend_test/src/utils/transactionUtils.ts"],"sourcesContent":["import { web3, BN } from '@coral-xyz/anchor';\nimport { PublicKey, Transaction, Keypair, SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { Buffer } from 'buffer';\nimport idlFile from '../idl/moon_wallet_program.json';\nimport * as elliptic from 'elliptic';\n\n// Export programID từ biến môi trường thay vì hardcode\nexport const programID = new PublicKey(process.env.REACT_APP_PROGRAM_ID || 'DeN1rBfabZezHPvrq9q7BbzUbZkrjnHE1kQDrPK8kWQ3');\n\n// Hằng số cho chương trình secp256r1\nexport const SECP256R1_PROGRAM_ID = new PublicKey('Secp256r1SigVerify1111111111111111111111111');\n\n// Hằng số cho Sysvar accounts với địa chỉ chính xác\nexport const SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');\nexport const SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');\n\n// Sửa lỗi type cho IDL\nconst idl: any = idlFile;\n\n// Cập nhật: Chương trình secp256r1 là một chương trình native của Solana, \n// nên không thể kiểm tra bằng getAccountInfo\nexport const checkSecp256r1Program = async (): Promise<boolean> => {\n  // Chương trình native luôn tồn tại trên validator chính thức\n  // Chỉ cần đảm bảo validator được khởi động với tham số phù hợp\n  return true;\n};\n\n// Thêm hàm kiểm tra chương trình secp256r1 thông qua transaction thử nghiệm nếu cần\nexport const testSecp256r1Instruction = async (connection: web3.Connection): Promise<boolean> => {\n  try {\n    // Tạo một cặp khóa giả lập cho việc kiểm tra\n    const testKeyPair = web3.Keypair.generate();\n    \n    // Tạo một chữ ký và message giả\n    const testSignature = Buffer.alloc(64, 1); // Chữ ký giả 64 bytes\n    const testPubkey = Buffer.alloc(33, 2); // Khóa công khai giả 33 bytes\n    testPubkey[0] = 0x02; // Định dạng khóa nén\n    const testMessage = Buffer.alloc(32, 3); // Message hash giả 32 bytes\n    \n    // Tạo instruction secp256r1 giả - SỬA ĐỔI: đảm bảo thứ tự tham số đúng (message, publicKey, signature)\n    const testInstruction = createSecp256r1Instruction(\n      testMessage,   // Message đầu tiên\n      testPubkey,    // Public key tiếp theo\n      testSignature  // Signature cuối cùng\n    );\n    \n    // Tạo transaction giả với instruction trên\n    const testTx = new web3.Transaction().add(testInstruction);\n    testTx.feePayer = testKeyPair.publicKey;\n    const { blockhash } = await connection.getLatestBlockhash();\n    testTx.recentBlockhash = blockhash;\n    \n    // Chỉ mô phỏng giao dịch, không gửi thật\n    await connection.simulateTransaction(testTx);\n    \n    // Nếu không có lỗi \"program not found\", chương trình tồn tại\n    return true;\n  } catch (error: any) {\n    // Kiểm tra lỗi cụ thể\n    const errorMessage = error.toString();\n    // Nếu lỗi là về chương trình không tồn tại\n    if (errorMessage.includes(\"Attempt to load a program that does not exist\") ||\n        errorMessage.includes(\"Program not found\")) {\n      console.error(\"Chương trình secp256r1 không tồn tại:\", error);\n      return false;\n    }\n    \n    // Nếu là lỗi khác (vd: chữ ký không hợp lệ), chương trình vẫn tồn tại\n    console.warn(\"Lỗi khi kiểm tra secp256r1, nhưng chương trình có thể tồn tại:\", error);\n    return true;\n  }\n};\n\n// Cập nhật lại hàm tạo transaction\nexport const createInitializeMultisigTx = async (\n  threshold: number,\n  multisigPDA: PublicKey,\n  owner: PublicKey | Keypair,\n  feePayer: Keypair,\n  recoveryHash: Uint8Array,\n  credentialId: Buffer\n): Promise<Transaction> => {\n  try {\n    const ownerPubkey = owner instanceof Keypair ? owner.publicKey : owner;\n    \n    // Sử dụng discriminator chính xác từ IDL\n    const discriminator = Buffer.from([\n      220, 130, 117, 21, 27, 227, 78, 213\n    ]);\n    \n    // Đảm bảo recoveryHash có đúng 32 bytes\n    if (recoveryHash.length !== 32) {\n      throw new Error(\"Recovery hash phải đúng 32 bytes\");\n    }\n    \n    const thresholdBuffer = Buffer.from([threshold]);\n    const recoveryHashBuffer = Buffer.from(recoveryHash);\n    \n    // Tạo buffer cho độ dài credential ID\n    const credentialIdLenBuffer = Buffer.alloc(4);\n    credentialIdLenBuffer.writeUInt32LE(credentialId.length, 0);\n    \n    // Nối tất cả lại với nhau\n    const data = Buffer.concat([\n      new Uint8Array(discriminator),\n      new Uint8Array(thresholdBuffer),\n      new Uint8Array(recoveryHashBuffer),\n      new Uint8Array(credentialIdLenBuffer),\n      new Uint8Array(credentialId)\n    ]);\n    \n    // Tạo transaction instruction\n    const instruction = new TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: feePayer.publicKey, isSigner: true, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n      ],\n      programId: programID,\n      data\n    });\n    \n    const tx = new Transaction().add(instruction);\n    return tx;\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction initialize multisig:\", error);\n    throw error;\n  }\n};\n\n// Thêm hàm compressPublicKey cho việc nén khóa công khai\nfunction compressPublicKey(uncompressedKey: Buffer): Buffer {\n  // Đảm bảo khóa bắt đầu với byte 0x04 (không nén)\n  if (uncompressedKey[0] !== 0x04 || uncompressedKey.length !== 65) {\n    throw new Error('Khóa không đúng định dạng không nén ECDSA');\n  }\n  \n  // Sử dụng Uint8Array để tránh lỗi type\n  const x = Buffer.from(uncompressedKey.subarray(1, 33));\n  const y = Buffer.from(uncompressedKey.subarray(33, 65));\n  \n  // Tính prefix: 0x02 nếu y chẵn, 0x03 nếu y lẻ\n  const prefix = (y[31] & 1) === 0 ? 0x02 : 0x03;\n  \n  // Tạo khóa nén: prefix (1 byte) + x (32 bytes)\n  const compressedKey = Buffer.alloc(33);\n  compressedKey[0] = prefix;\n  new Uint8Array(compressedKey).set(new Uint8Array(x), 1);\n  \n  return compressedKey;\n}\n\n// Cập nhật hàm configure_webauthn với discriminator chính xác từ IDL\nexport const createConfigureWebAuthnTx = async (\n  webauthnPubkey: Buffer,\n  multisigPDA: PublicKey,\n  owner: PublicKey\n): Promise<Transaction> => {\n  try {\n    // Lấy từ IDL: discriminator chính xác cho hàm configure_webauthn\n    const discriminator = Buffer.from([\n      40, 149, 116, 224, 148, 48, 159, 54\n    ]);\n    \n    // Nén khóa công khai từ 65 bytes xuống 33 bytes\n    let compressedKey: Buffer;\n    \n    if (webauthnPubkey.length === 65 && webauthnPubkey[0] === 0x04) {\n      // Khóa không nén, cần nén lại\n      compressedKey = compressPublicKey(webauthnPubkey);\n      console.log(\"Đã nén khóa từ 65 bytes xuống 33 bytes\");\n    } else if (webauthnPubkey.length === 33 && (webauthnPubkey[0] === 0x02 || webauthnPubkey[0] === 0x03)) {\n      // Khóa đã nén, sử dụng trực tiếp\n      compressedKey = webauthnPubkey;\n      console.log(\"Khóa đã ở định dạng nén (33 bytes)\");\n    } else {\n      console.warn(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPubkey.length} bytes`);\n      // Nếu không thể xử lý, tạo khóa giả\n      compressedKey = Buffer.alloc(33);\n      compressedKey[0] = 0x02; // Prefix cho khóa nén\n      if (webauthnPubkey.length > 0) {\n        // Sao chép dữ liệu nếu có\n        new Uint8Array(compressedKey).set(\n          new Uint8Array(webauthnPubkey.subarray(0, Math.min(webauthnPubkey.length, 32))),\n          1\n        );\n      }\n    }\n    \n    console.log(\"Khóa công khai WebAuthn (nén):\", compressedKey.toString('hex'));\n    console.log(\"Độ dài khóa (bytes):\", compressedKey.length);\n    \n    // Tạo dữ liệu instruction\n    const data = Buffer.concat([\n      new Uint8Array(discriminator),\n      new Uint8Array(compressedKey)\n    ]);\n    \n    // Tạo instruction với đúng accounts theo IDL\n    const instruction = new TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: owner, isSigner: true, isWritable: false },\n      ],\n      programId: programID,\n      data\n    });\n    \n    const tx = new Transaction().add(instruction);\n    return tx;\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction configure webauthn:\", error);\n    throw error;\n  }\n};\n\n/**\n * Tạo transaction cho storePasswordHash\n */\nexport const createStorePasswordHashTx = async (\n  passwordHash: Uint8Array,\n  multisigPDA: web3.PublicKey,\n  ownerPubkey: web3.PublicKey\n) => {\n  const tx = new web3.Transaction();\n  \n  // Sửa lỗi Buffer.from\n  const discriminator = Buffer.from([\n    // Thay thế với giá trị discriminator thực tế\n    125, 106, 39, 42, 99, 108, 43, 50\n  ]);\n  \n  // Sửa lại cách tạo data buffer\n  const data = Buffer.concat([\n    new Uint8Array(discriminator),\n    new Uint8Array(Buffer.from(Array.from(passwordHash)))\n  ]);\n  \n  // Thêm instruction để lưu password hash\n  tx.add(\n    new web3.TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: ownerPubkey, isSigner: true, isWritable: false },\n      ],\n      programId: programID,\n      data: data\n    })\n  );\n  \n  return tx;\n};\n\n/**\n * Tạo transaction xác thực WebAuthn\n */\nexport const createWebAuthnAuthTx = async (\n  multisigPDA: web3.PublicKey,\n  ownerPubkey: web3.PublicKey,\n  webauthnSignature: Uint8Array,\n  authenticatorData: Uint8Array,\n  clientDataJSON: Uint8Array\n): Promise<web3.Transaction> => {\n  const tx = new web3.Transaction();\n  \n  // Thêm discriminator đúng cho verify_webauthn_auth\n  const instructionData = Buffer.concat([\n    new Uint8Array(Buffer.from([234, 182, 165, 23, 186, 223, 208, 119])), // discriminator từ IDL\n    new Uint8Array(Buffer.from(webauthnSignature)),\n    new Uint8Array(Buffer.from(authenticatorData)),\n    new Uint8Array(Buffer.from(clientDataJSON))\n  ]);\n  \n  const instruction = new web3.TransactionInstruction({\n    keys: [\n      { pubkey: multisigPDA, isSigner: false, isWritable: true },\n      { pubkey: ownerPubkey, isSigner: false, isWritable: false }\n    ],\n    programId: programID,\n    data: instructionData\n  });\n  \n  tx.add(instruction);\n  return tx;\n};\n\n// Tạo hàm mới createAddGuardianTx\nexport const createAddGuardianTx = (\n  multisigPDA: PublicKey,\n  guardianPDA: PublicKey,\n  guardianPubkey: PublicKey,\n  guardianName: string,\n  recoveryHash: Uint8Array,\n  isOwner: boolean,\n  webauthnPubkey?: Buffer\n): Transaction => {\n  try {\n    // Discriminator cho add_guardian\n    const discriminator = Buffer.from([167, 189, 170, 27, 74, 240, 201, 241]);\n    \n    // Tạo buffer cho tên guardian\n    const nameBuffer = Buffer.from(guardianName);\n    const nameLenBuffer = Buffer.alloc(4);\n    nameLenBuffer.writeUInt32LE(nameBuffer.length, 0);\n    \n    // Tạo buffer cho các tham số\n    const isOwnerByte = Buffer.from([isOwner ? 1 : 0]);\n    \n    // Tạo buffers cho instruction data\n    const dataBuffers = [\n      discriminator,\n      guardianPubkey.toBuffer(),\n      nameLenBuffer,\n      nameBuffer,\n      Buffer.from(recoveryHash)\n    ];\n    \n    // Thêm isOwner\n    dataBuffers.push(isOwnerByte);\n    \n    // Xử lý webauthn_pubkey (option)\n    if (webauthnPubkey && isOwner) {\n      // Some variant (1)\n      dataBuffers.push(Buffer.from([1]));\n      \n      // Nén khóa công khai nếu cần\n      let compressedKey: Buffer;\n      if (webauthnPubkey.length === 65 && webauthnPubkey[0] === 0x04) {\n        // Khóa không nén, cần nén lại\n        compressedKey = compressPublicKey(webauthnPubkey);\n      } else if (webauthnPubkey.length === 33 && (webauthnPubkey[0] === 0x02 || webauthnPubkey[0] === 0x03)) {\n        // Khóa đã nén, sử dụng trực tiếp\n        compressedKey = webauthnPubkey;\n      } else {\n        throw new Error(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPubkey.length} bytes`);\n      }\n      \n      dataBuffers.push(compressedKey);\n    } else {\n      // None variant (0)\n      dataBuffers.push(Buffer.from([0]));\n    }\n    \n    // Nối tất cả buffer lại với nhau\n    const data = Buffer.concat(dataBuffers.map(buffer => new Uint8Array(buffer)));\n    \n    // Tạo instruction\n    const instruction = new TransactionInstruction({\n      keys: [\n        { pubkey: multisigPDA, isSigner: false, isWritable: true },\n        { pubkey: guardianPDA, isSigner: false, isWritable: true },\n        { pubkey: guardianPubkey, isSigner: true, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }\n      ],\n      programId: programID,\n      data\n    });\n    \n    return new Transaction().add(instruction);\n  } catch (error) {\n    console.error(\"Lỗi khi tạo transaction add guardian:\", error);\n    throw error;\n  }\n};\n\n// Thêm các hằng số cho curve secp256r1 - dựa trên file test đã hoạt động\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 14;\nconst SIGNATURE_OFFSETS_START = 2;\nconst DATA_START = SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START;\nconst SIGNATURE_SERIALIZED_SIZE = 64;\nconst COMPRESSED_PUBKEY_SERIALIZED_SIZE = 33;\n\n// Order của curve secp256r1\nconst SECP256R1_ORDER = new Uint8Array([\n  0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9,\n  0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51,\n]);\n\n// Nửa order của curve secp256r1\nconst SECP256R1_HALF_ORDER = new Uint8Array([\n  0x7f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xde, 0x73, 0x7d, 0x56, 0xd3, 0x8b, 0xcf, 0x42, 0x79, 0xdc,\n  0xe5, 0x61, 0x7e, 0x31, 0x92, 0xa8,\n]);\n\n// Thêm hàm so sánh số lớn\nfunction isGreaterThan(a: Uint8Array | Buffer, b: Uint8Array): boolean {\n  const aBuf = Buffer.isBuffer(a) ? a : Buffer.from(a);\n  if (aBuf.length !== b.length) {\n    return aBuf.length > b.length;\n  }\n  for (let i = 0; i < aBuf.length; i++) {\n    if (aBuf[i] !== b[i]) {\n      return aBuf[i] > b[i];\n    }\n  }\n  return false;\n}\n\n// Sửa lại hàm subtractBigNumbers để xử lý big-endian đúng cách\nfunction subtractBigNumbers(a: Uint8Array, b: Uint8Array | Buffer): Uint8Array {\n  const bBuf = Buffer.isBuffer(b) ? b : Buffer.from(b);\n  const result = new Uint8Array(a.length);\n  let borrow = 0;\n  \n  // Đảm bảo cả a và b đều có đúng 32 bytes\n  if (a.length !== 32 || bBuf.length !== 32) {\n    console.error(`Độ dài không đúng: a=${a.length}, b=${bBuf.length}, phải là 32 bytes`);\n  }\n\n  // Tính từ byte ít quan trọng nhất đến quan trọng nhất (big endian)\n  for (let i = a.length - 1; i >= 0; i--) {\n    let diff = a[i] - bBuf[i] - borrow;\n    if (diff < 0) {\n      diff += 256;\n      borrow = 1;\n    } else {\n      borrow = 0;\n    }\n    result[i] = diff;\n  }\n  \n  // Log giá trị input và output để debug\n  console.log('Input a (hex):', Buffer.from(a).toString('hex'));\n  console.log('Input b (hex):', Buffer.from(bBuf).toString('hex'));\n  console.log('Result (hex):', Buffer.from(result).toString('hex'));\n\n  return result;\n}\n\n/**\n * Tạo instruction cho chương trình Secp256r1SigVerify\n * Cài đặt dựa trên file test đã hoạt động thành công\n * @param message Message đã hash (32 bytes)\n * @param publicKey Khóa công khai secp256r1 (dạng nén, 33 bytes)\n * @param signature Chữ ký (64 bytes)\n */\nexport const createSecp256r1Instruction = (\n  message: Buffer,\n  publicKey: Buffer,\n  signature: Buffer\n): web3.TransactionInstruction => {\n  try {\n    console.log('Tạo secp256r1 instruction...');\n    console.log('- Message length:', message.length, 'bytes:', message.toString('hex'));\n    console.log('- Public key length:', publicKey.length, 'bytes:', publicKey.toString('hex'));\n    console.log('- Signature length:', signature.length, 'bytes:', signature.toString('hex'));\n    \n    // Kiểm tra kích thước\n    if (message.length !== 32) {\n      throw new Error(`Message phải có độ dài 32 bytes, nhận được ${message.length} bytes`);\n    }\n    \n    if (publicKey.length !== COMPRESSED_PUBKEY_SERIALIZED_SIZE) {\n      throw new Error(`Public key phải có độ dài 33 bytes (dạng nén), nhận được ${publicKey.length} bytes`);\n    }\n    \n    if (signature.length !== SIGNATURE_SERIALIZED_SIZE) {\n      throw new Error(`Signature phải có độ dài 64 bytes, nhận được ${signature.length} bytes`);\n    }\n    \n    // Tách r và s từ signature\n    const r = signature.slice(0, 32);\n    const s = signature.slice(32, 64);\n    \n    console.log('Signature components:');\n    console.log('- r (hex):', r.toString('hex'));\n    console.log('- s (hex):', s.toString('hex'));\n    \n    // QUAN TRỌNG: Chuẩn hóa s nếu cần\n    // Solana yêu cầu s phải trong phạm vi canonical (s <= half_order)\n    let finalSignature = signature;\n    if (isGreaterThan(s, SECP256R1_HALF_ORDER)) {\n      console.log('Chuẩn hóa signature: s > HALF_ORDER, thực hiện s = ORDER - s');\n      const newS = subtractBigNumbers(SECP256R1_ORDER, s);\n      finalSignature = Buffer.concat([r, Buffer.from(newS)]);\n      console.log('Signature sau khi chuẩn hóa (hex):', finalSignature.toString('hex'));\n    } else {\n      console.log('Signature đã chuẩn hóa, không cần thay đổi');\n    }\n    \n    // SỬA CHỮA: Tạo phiên bản chữ ký thứ hai với s chuẩn hóa ngược lại \n    // (đôi khi cách chuẩn hóa có thể ngược với những gì mong đợi)\n    let alternativeSignature = signature;\n    if (!isGreaterThan(s, SECP256R1_HALF_ORDER)) {\n      // Nếu s nhỏ hơn HALF_ORDER, thử ORDER - s\n      console.log('Thử phiên bản chữ ký thay thế: s < HALF_ORDER, thực hiện s = ORDER - s');\n      const altS = subtractBigNumbers(SECP256R1_ORDER, s);\n      alternativeSignature = Buffer.concat([r, Buffer.from(altS)]);\n      console.log('Phiên bản chữ ký thay thế (hex):', alternativeSignature.toString('hex'));\n    }\n    \n    console.log('Thử cả hai phiên bản của chữ ký (gốc và chuẩn hóa)');\n    \n    // Tính toán tổng kích thước instruction data\n    const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + message.length;\n    const instructionData = Buffer.alloc(totalSize);\n    \n    // Header - giống mẫu\n    instructionData.writeUInt8(1, 0); // num_signatures = 1\n    instructionData.writeUInt8(0, 1); // padding\n    \n    // Tính offset theo mẫu thành công\n    const publicKeyOffset = DATA_START;\n    const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n    const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n    \n    // Ghi offset vào instructionData - chính xác như mẫu\n    instructionData.writeUInt16LE(signatureOffset, SIGNATURE_OFFSETS_START);\n    instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 2);\n    instructionData.writeUInt16LE(publicKeyOffset, SIGNATURE_OFFSETS_START + 4);\n    instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 6);\n    instructionData.writeUInt16LE(messageDataOffset, SIGNATURE_OFFSETS_START + 8);\n    instructionData.writeUInt16LE(message.length, SIGNATURE_OFFSETS_START + 10);\n    instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 12);\n    \n    // Copy data vào đúng vị trí theo mẫu\n    publicKey.copy(instructionData, publicKeyOffset);               // Public key trước\n    finalSignature.copy(instructionData, signatureOffset);          // Signature đã được chuẩn hóa\n    message.copy(instructionData, messageDataOffset);               // Message cuối cùng\n    \n    console.log('Secp256r1 instruction data:');\n    console.log(`- Total size: ${instructionData.length} bytes`);\n    console.log(`- Public key offset: ${publicKeyOffset}`);\n    console.log(`- Signature offset: ${signatureOffset}`);\n    console.log(`- Message offset: ${messageDataOffset}`);\n    \n    // Lưu chữ ký thay thế để sử dụng khi cần\n    (instructionData as any).alternativeSignature = alternativeSignature;\n    \n    return new web3.TransactionInstruction({\n      keys: [],\n      programId: SECP256R1_PROGRAM_ID,\n      data: instructionData\n    });\n  } catch (error) {\n    console.error('❌ Lỗi khi tạo secp256r1 instruction:', error);\n    throw error;\n  }\n};\n\n/**\n * Kiểm tra xem chữ ký secp256r1 có hợp lệ không bằng cách mô phỏng transaction\n * @param connection Kết nối đến Solana cluster\n * @param publicKey Khóa công khai (dạng nén) dùng để xác minh\n * @param signature Chữ ký (raw format, 64 bytes) cần xác minh\n * @param message Message đã hash (32 bytes) đã được ký\n * @returns Promise<{isValid: boolean, error?: string}> Kết quả kiểm tra và lỗi nếu có\n */\nexport const testSecp256r1Signature = async (\n  connection: web3.Connection,\n  publicKey: Buffer, \n  signature: Buffer, \n  message: Buffer\n): Promise<{isValid: boolean, error?: string}> => {\n  try {\n    // Hiển thị thông tin chi tiết để debug\n    console.log('=== DEBUG: testSecp256r1Signature ===');\n    console.log('- Message (hex):', message.toString('hex'));\n  console.log('- Public key (hex):', publicKey.toString('hex'));\n  console.log('- Signature (hex):', signature.toString('hex'));\n    \n    // Log: Xác minh các giá trị đầu vào\n    if (message.length !== 32) console.warn('⚠️ WARNING: Message không phải 32 bytes');\n    if (publicKey.length !== 33) console.warn('⚠️ WARNING: Public key không phải 33 bytes');\n    if (signature.length !== 64) console.warn('⚠️ WARNING: Signature không phải 64 bytes');\n    \n    if (publicKey[0] !== 0x02 && publicKey[0] !== 0x03) {\n      console.warn('⚠️ WARNING: Public key không ở định dạng nén đúng (byte đầu phải là 0x02 hoặc 0x03)');\n    }\n    \n    // PHƯƠNG PHÁP 1: Thử xác minh với cách triển khai gốc (tương tự test_verify.js)\n    console.log('PHƯƠNG PHÁP 1: Thử xác minh với cách triển khai gốc (tương tự test_verify.js)');\n    const result1 = await testWithOriginalImplementation(connection, message, publicKey, signature);\n    \n    if (result1.isValid) {\n      console.log('✅ PHƯƠNG PHÁP 1 THÀNH CÔNG!');\n      return { isValid: true };\n    }\n    \n    console.log('❌ PHƯƠNG PHÁP 1 THẤT BẠI:', result1.error);\n    \n    // Tách r và s từ signature\n    const r = signature.slice(0, 32);\n    const s = signature.slice(32, 64);\n    \n    // Thử với phiên bản chuẩn hóa s (nếu cần)\n    console.log('PHƯƠNG PHÁP 2: Thử với chữ ký đã chuẩn hóa');\n    let normalizedSignature = signature;\n    if (isGreaterThan(s, SECP256R1_HALF_ORDER)) {\n      console.log('Chuẩn hóa signature: s > HALF_ORDER, thực hiện s = ORDER - s');\n      const newS = subtractBigNumbers(SECP256R1_ORDER, s);\n      normalizedSignature = Buffer.concat([r, Buffer.from(newS)]);\n      console.log('Signature sau khi chuẩn hóa (hex):', normalizedSignature.toString('hex'));\n      \n      const result2 = await testWithOriginalImplementation(connection, message, publicKey, normalizedSignature);\n      if (result2.isValid) {\n        console.log('✅ PHƯƠNG PHÁP 2 THÀNH CÔNG!');\n        return { isValid: true };\n      }\n      console.log('❌ PHƯƠNG PHÁP 2 THẤT BẠI:', result2.error);\n    } else {\n      console.log('Signature đã chuẩn hóa, không cần thay đổi. Bỏ qua phương pháp 2.');\n    }\n    \n    // Thử với phiên bản ngược lại của chuẩn hóa\n    console.log('PHƯƠNG PHÁP 3: Thử với chữ ký chuẩn hóa ngược lại');\n    if (!isGreaterThan(s, SECP256R1_HALF_ORDER)) {\n      console.log('Thử nghiệm ngược lại: s < HALF_ORDER, thực hiện s = ORDER - s');\n      const altS = subtractBigNumbers(SECP256R1_ORDER, s);\n      const reverseNormalizedSignature = Buffer.concat([r, Buffer.from(altS)]);\n      console.log('Chữ ký chuẩn hóa ngược (hex):', reverseNormalizedSignature.toString('hex'));\n      \n      const result3 = await testWithOriginalImplementation(connection, message, publicKey, reverseNormalizedSignature);\n      if (result3.isValid) {\n        console.log('✅ PHƯƠNG PHÁP 3 THÀNH CÔNG!');\n        return { isValid: true };\n      }\n      console.log('❌ PHƯƠNG PHÁP 3 THẤT BẠI:', result3.error);\n    } else {\n      console.log('Không thử phương pháp 3 vì s > HALF_ORDER.');\n    }\n    \n    // PHƯƠNG PHÁP 4: Thử với số lượng chữ ký khác\n    console.log('PHƯƠNG PHÁP 4: Thử với num_signatures = 0');\n    try {\n  const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + message.length;\n  const instructionData = Buffer.alloc(totalSize);\n  \n      // Thay đổi số lượng signatures\n      instructionData.writeUInt8(0, 0); // num_signatures = 0 thay vì 1\n  instructionData.writeUInt8(0, 1); // padding\n  \n      // Tính offset\n  const publicKeyOffset = DATA_START;\n  const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n  const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n  \n      // Ghi offsets\n  instructionData.writeUInt16LE(signatureOffset, SIGNATURE_OFFSETS_START);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 2);\n  instructionData.writeUInt16LE(publicKeyOffset, SIGNATURE_OFFSETS_START + 4);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 6);\n  instructionData.writeUInt16LE(messageDataOffset, SIGNATURE_OFFSETS_START + 8);\n  instructionData.writeUInt16LE(message.length, SIGNATURE_OFFSETS_START + 10);\n  instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 12);\n  \n      // Copy data\n  publicKey.copy(instructionData, publicKeyOffset);\n  signature.copy(instructionData, signatureOffset);\n  message.copy(instructionData, messageDataOffset);\n  \n      // Tạo instruction\n      const instruction = new web3.TransactionInstruction({\n        keys: [],\n        programId: SECP256R1_PROGRAM_ID,\n        data: instructionData\n      });\n      \n      // Tạo một feePayer mới\n      const feePayer = web3.Keypair.generate();\n      \n      // Airdrop SOL cho feePayer\n      const airdropSignature = await connection.requestAirdrop(\n        feePayer.publicKey,\n        web3.LAMPORTS_PER_SOL / 100\n      );\n      await connection.confirmTransaction(airdropSignature);\n      \n      // Tạo transaction\n      const transaction = new web3.Transaction();\n      const blockhash = await connection.getLatestBlockhash();\n      transaction.recentBlockhash = blockhash.blockhash;\n      transaction.feePayer = feePayer.publicKey;\n      transaction.add(instruction);\n      \n      // Ký transaction\n      transaction.sign(feePayer);\n      \n      // Mô phỏng transaction\n      console.log('Đang mô phỏng transaction với num_signatures = 0...');\n      const simulationResult = await connection.simulateTransaction(transaction);\n      \n      if (!simulationResult.value.err) {\n        console.log('✅ PHƯƠNG PHÁP 4 THÀNH CÔNG!');\n        return { isValid: true };\n      }\n      \n      console.log('❌ PHƯƠNG PHÁP 4 THẤT BẠI:', JSON.stringify(simulationResult.value.err));\n    } catch (error: any) {\n      console.error('Lỗi khi thử nghiệm phương pháp 4:', error);\n    }\n    \n    // PHƯƠNG PHÁP 5: Thử với chữ ký ở định dạng DER\n    console.log('PHƯƠNG PHÁP 5: Thử với chữ ký ở định dạng DER');\n    try {\n      // Chuyển đổi signature raw sang định dạng DER\n      const rBuffer = stripLeadingZeros(r);\n      const sBuffer = stripLeadingZeros(s);\n      \n      // Tạo DER signature\n      // Format: 30 L 02 Lr r 02 Ls s\n      let rWithPrefix = rBuffer;\n      let sWithPrefix = sBuffer;\n      \n      if (rBuffer[0] & 0x80) {\n        rWithPrefix = Buffer.concat([Buffer.from([0x00]), rBuffer]);\n      }\n      \n      if (sBuffer[0] & 0x80) {\n        sWithPrefix = Buffer.concat([Buffer.from([0x00]), sBuffer]);\n      }\n      \n      const rLength = rWithPrefix.length;\n      const sLength = sWithPrefix.length;\n      const totalLength = rLength + sLength + 4; // 4 = 2 bytes cho INTEGER tags và 2 bytes cho lengths\n      \n      const derSignature = Buffer.alloc(totalLength + 2); // +2 cho SEQUENCE tag và length\n      \n      // SEQUENCE tag\n      derSignature[0] = 0x30;\n      // SEQUENCE length\n      derSignature[1] = totalLength;\n      // INTEGER tag cho r\n      derSignature[2] = 0x02;\n      // Chiều dài của r\n      derSignature[3] = rLength;\n      // Giá trị r\n      rWithPrefix.copy(derSignature, 4);\n      // INTEGER tag cho s\n      derSignature[4 + rLength] = 0x02;\n      // Chiều dài của s\n      derSignature[5 + rLength] = sLength;\n      // Giá trị s\n      sWithPrefix.copy(derSignature, 6 + rLength);\n      \n      console.log('DER signature (hex):', derSignature.toString('hex'));\n      \n      // Tạo instruction data với DER signature\n      const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + message.length;\n      const instructionData = Buffer.alloc(totalSize);\n      \n      instructionData.writeUInt8(1, 0); // num_signatures = 1\n      instructionData.writeUInt8(0, 1); // padding\n      \n      // Tính offset\n      const publicKeyOffset = DATA_START;\n      const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n      const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n      \n      // Ghi offsets\n      instructionData.writeUInt16LE(signatureOffset, SIGNATURE_OFFSETS_START);\n      instructionData.writeUInt16LE(derSignature.length, SIGNATURE_OFFSETS_START + 2);\n      instructionData.writeUInt16LE(publicKeyOffset, SIGNATURE_OFFSETS_START + 4);\n      instructionData.writeUInt16LE(publicKey.length, SIGNATURE_OFFSETS_START + 6);\n      instructionData.writeUInt16LE(messageDataOffset, SIGNATURE_OFFSETS_START + 8);\n      instructionData.writeUInt16LE(message.length, SIGNATURE_OFFSETS_START + 10);\n      instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 12);\n      \n      // Copy data\n      publicKey.copy(instructionData, publicKeyOffset);\n      \n      // Copy DER signature và padding với 0 nếu cần\n      const paddedDerSignature = Buffer.alloc(SIGNATURE_SERIALIZED_SIZE);\n      derSignature.copy(paddedDerSignature);\n      paddedDerSignature.copy(instructionData, signatureOffset);\n      \n      message.copy(instructionData, messageDataOffset);\n      \n      // Tạo instruction\n      const instruction = new web3.TransactionInstruction({\n        keys: [],\n        programId: SECP256R1_PROGRAM_ID,\n        data: instructionData\n      });\n      \n      // Tạo một feePayer mới\n      const feePayer = web3.Keypair.generate();\n      \n      // Airdrop SOL cho feePayer\n      const airdropSignature = await connection.requestAirdrop(\n        feePayer.publicKey,\n        web3.LAMPORTS_PER_SOL / 100\n      );\n      await connection.confirmTransaction(airdropSignature);\n      \n      // Tạo transaction\n      const transaction = new web3.Transaction();\n      const blockhash = await connection.getLatestBlockhash();\n      transaction.recentBlockhash = blockhash.blockhash;\n      transaction.feePayer = feePayer.publicKey;\n      transaction.add(instruction);\n      \n      // Ký transaction\n      transaction.sign(feePayer);\n      \n      // Mô phỏng transaction\n      console.log('Đang mô phỏng transaction với DER signature...');\n      const simulationResult = await connection.simulateTransaction(transaction);\n      \n      if (!simulationResult.value.err) {\n        console.log('✅ PHƯƠNG PHÁP 5 THÀNH CÔNG!');\n        return { isValid: true };\n      }\n      \n      console.log('❌ PHƯƠNG PHÁP 5 THẤT BẠI:', JSON.stringify(simulationResult.value.err));\n    } catch (error: any) {\n      console.error('Lỗi khi thử nghiệm phương pháp 5:', error);\n    }\n    \n    // Tất cả phương pháp đều thất bại\n    return { isValid: false, error: 'Tất cả các phương pháp xác minh đều thất bại' };\n  } catch (error: any) {\n    console.error('Lỗi khi kiểm tra chữ ký secp256r1:', error);\n    return { isValid: false, error: error.toString() };\n  }\n};\n\n// Hàm để loại bỏ các byte 0 ở đầu của một buffer\nfunction stripLeadingZeros(buffer: Buffer): Buffer {\n  let i = 0;\n  while (i < buffer.length && buffer[i] === 0) {\n    i++;\n  }\n  return i === 0 ? buffer : buffer.slice(i);\n}\n\n/**\n * Thử nghiệm với cách triển khai giống hệt với test_verify.js\n * @param connection Kết nối Solana\n * @param messageHash Hash của message (32 bytes)\n * @param publicKey Public key dạng nén (33 bytes)\n * @param signature Signature (64 bytes)\n */\nexport const testWithOriginalImplementation = async (\n  connection: web3.Connection,\n  messageHash: Buffer,\n  publicKey: Buffer,\n  signature: Buffer\n): Promise<{isValid: boolean, error?: string}> => {\n  try {\n    console.log('=== KIỂM TRA THEO CÁCH TRIỂN KHAI GỐC ===');\n    console.log('Message hash:', messageHash.toString('hex'));\n    console.log('Public key:', publicKey.toString('hex'));\n    console.log('Signature:', signature.toString('hex'));\n    \n    // Tạo một feePayer mới\n    const feePayer = web3.Keypair.generate();\n    \n    // Airdrop SOL cho feePayer\n    const airdropSignature = await connection.requestAirdrop(\n      feePayer.publicKey,\n      web3.LAMPORTS_PER_SOL / 100\n    );\n    await connection.confirmTransaction(airdropSignature);\n    \n    // Tính toán kích thước instruction data\n    const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + messageHash.length;\n    const instructionData = Buffer.alloc(totalSize);\n    \n    // Header - num_signatures=1, padding=0\n    instructionData.writeUInt8(1, 0);\n    instructionData.writeUInt8(0, 1);\n    \n    // Offsets\n    const publicKeyOffset = DATA_START;\n    const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n    const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n    \n    // Write offsets - CHÍNH XÁC giống test_verify.js\n    instructionData.writeUInt16LE(signatureOffset, SIGNATURE_OFFSETS_START);\n    instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 2);\n    instructionData.writeUInt16LE(publicKeyOffset, SIGNATURE_OFFSETS_START + 4);\n    instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 6);\n    instructionData.writeUInt16LE(messageDataOffset, SIGNATURE_OFFSETS_START + 8);\n    instructionData.writeUInt16LE(messageHash.length, SIGNATURE_OFFSETS_START + 10);\n    instructionData.writeUInt16LE(0xffff, SIGNATURE_OFFSETS_START + 12);\n    \n    // Write data - CHÍNH XÁC giống test_verify.js\n    publicKey.copy(instructionData, publicKeyOffset);\n    signature.copy(instructionData, signatureOffset);\n    messageHash.copy(instructionData, messageDataOffset);\n  \n  // Tạo instruction\n    const instruction = new web3.TransactionInstruction({\n    keys: [],\n    programId: SECP256R1_PROGRAM_ID,\n    data: instructionData\n  });\n    \n    // Tạo transaction\n    const transaction = new web3.Transaction();\n    const blockhash = await connection.getLatestBlockhash();\n    transaction.recentBlockhash = blockhash.blockhash;\n    transaction.feePayer = feePayer.publicKey;\n    transaction.add(instruction);\n    \n    // Ký transaction\n    transaction.sign(feePayer);\n    \n    // Mô phỏng transaction\n    console.log('Đang mô phỏng transaction theo cách triển khai gốc...');\n    try {\n      const simulationResult = await connection.simulateTransaction(transaction);\n      \n      if (simulationResult.value.err) {\n        const errorString = JSON.stringify(simulationResult.value.err);\n        console.error('Lỗi mô phỏng (cách gốc):', errorString);\n        return { isValid: false, error: errorString };\n      }\n      \n      console.log('✅ Mô phỏng thành công!');\n      return { isValid: true };\n    } catch (error: any) {\n      console.error('Lỗi khi mô phỏng transaction (cách gốc):', error);\n      return { isValid: false, error: error.toString() };\n    }\n  } catch (error: any) {\n    console.error('Lỗi trong testWithOriginalImplementation:', error);\n    return { isValid: false, error: error.toString() };\n  }\n};\n\n/**\n * Tạo giao dịch chuyển SOL hoặc token\n * @param multisigPDA PDA của ví multisig\n * @param destination Địa chỉ nhận\n * @param amount Số lượng cần chuyển (lamports cho SOL, units cho token)\n * @param mint Địa chỉ token mint (null nếu chuyển SOL)\n * @param connection Kết nối Solana\n * @param webauthnPublicKey Khóa công khai WebAuthn (tùy chọn)\n * @param webauthnSignature Chữ ký WebAuthn (tùy chọn)\n * @param message Tin nhắn đã ký (tùy chọn)\n * @param timestamp Thời gian thực hiện (tùy chọn)\n */\nexport const createTransferTx = async (\n  multisigPDA: web3.PublicKey,\n  destination: web3.PublicKey,\n  amount: number | BN,\n  mint: web3.PublicKey | null,\n  connection: web3.Connection,\n  webauthnPublicKey?: Buffer,\n  webauthnSignature?: Buffer,\n  message?: Buffer,\n  timestamp?: number\n): Promise<web3.Transaction> => {\n  try {\n    console.log('Tạo giao dịch chuyển tiền...');\n    const isToken = mint !== null;\n    \n    // Discriminator cho transfer_sol hoặc transfer_token\n    const discriminator = isToken \n      ? Buffer.from([22, 93, 192, 70, 30, 202, 101, 106]) // transfer_token\n      : Buffer.from([85, 115, 0, 198, 211, 138, 226, 246]); // transfer_sol\n    \n    // Chuyển đổi amount sang BN nếu nó là số\n    const amountBN = typeof amount === 'number' \n      ? new BN(amount)\n      : amount;\n    \n    // Tạo buffer cho amount (8 bytes)\n    const amountBuffer = Buffer.alloc(8);\n    amountBN.toArrayLike(Buffer, 'le', 8).copy(amountBuffer);\n    \n    // Chuẩn bị buffers cho instruction data\n    const dataBuffers = [\n      discriminator,\n      destination.toBuffer(),\n      amountBuffer\n    ];\n    \n    // Thêm mint nếu chuyển token\n    if (isToken) {\n      dataBuffers.push(mint!.toBuffer());\n    }\n    \n    // Thêm timestamp nếu có\n    if (timestamp) {\n      const timestampBuffer = Buffer.alloc(8);\n      new BN(timestamp).toArrayLike(Buffer, 'le', 8).copy(timestampBuffer);\n      dataBuffers.push(timestampBuffer);\n    }\n    \n    // Thêm webauthn signature nếu có\n    if (webauthnPublicKey && webauthnSignature && message) {\n      // Some variant (1)\n      dataBuffers.push(Buffer.from([1]));\n      \n      // Nén webauthnPublicKey nếu cần\n      let compressedKey: Buffer;\n      if (webauthnPublicKey.length === 65 && webauthnPublicKey[0] === 0x04) {\n        compressedKey = compressPublicKey(webauthnPublicKey);\n      } else if (webauthnPublicKey.length === 33 && \n                (webauthnPublicKey[0] === 0x02 || webauthnPublicKey[0] === 0x03)) {\n        compressedKey = webauthnPublicKey;\n      } else {\n        throw new Error(`Khóa công khai WebAuthn không đúng định dạng: ${webauthnPublicKey.length} bytes`);\n      }\n      \n      // Gộp message, public key và signature vào instruction data\n      dataBuffers.push(message);\n      dataBuffers.push(compressedKey);\n      dataBuffers.push(webauthnSignature);\n    } else {\n      // None variant (0)\n      dataBuffers.push(Buffer.from([0]));\n    }\n    \n    // Nối tất cả buffer lại\n    const data = Buffer.concat(dataBuffers.map(buffer => \n      Buffer.isBuffer(buffer) ? new Uint8Array(buffer) : new Uint8Array(buffer)));\n    \n    // Xác định các accounts cần thiết dựa trên loại giao dịch\n    const keys = [\n      { pubkey: multisigPDA, isSigner: false, isWritable: true },\n      { pubkey: destination, isSigner: false, isWritable: true },\n      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n    ];\n    \n    // Thêm các accounts cần thiết cho token transfer\n    if (isToken) {\n      // Lấy token accounts\n      const multisigTokenAccount = await connection.getTokenAccountsByOwner(\n        multisigPDA, \n        { mint: mint! }\n      );\n      \n      if (multisigTokenAccount.value.length === 0) {\n        throw new Error(`Không tìm thấy token account cho mint ${mint!.toString()}`);\n      }\n      \n      const sourceTokenAccount = multisigTokenAccount.value[0].pubkey;\n      \n      // Kiểm tra hoặc tạo token account đích\n      let destinationTokenAccount: web3.PublicKey;\n      try {\n        const destTokenAccounts = await connection.getTokenAccountsByOwner(\n          destination,\n          { mint: mint! }\n        );\n        \n        if (destTokenAccounts.value.length > 0) {\n          destinationTokenAccount = destTokenAccounts.value[0].pubkey;\n        } else {\n          throw new Error('Cần tạo token account đích');\n        }\n      } catch (error) {\n        console.warn('Không tìm thấy token account đích, cần tạo mới');\n        // Trong trường hợp thực tế, bạn có thể muốn tạo token account đích\n        // trong một transaction riêng trước khi gọi hàm này\n        throw new Error('Người nhận chưa có token account cho loại token này');\n      }\n      \n      // Import Token Program (cần đảm bảo đã import ở đầu file)\n      const TOKEN_PROGRAM_ID = new web3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n      \n      // Thêm accounts cần thiết cho giao dịch token\n      keys.splice(1, 0, { pubkey: sourceTokenAccount, isSigner: false, isWritable: true });\n      keys.splice(2, 0, { pubkey: destinationTokenAccount, isSigner: false, isWritable: true });\n      keys.splice(3, 0, { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false });\n      keys.splice(4, 0, { pubkey: mint!, isSigner: false, isWritable: false });\n    }\n    \n    // Tạo instruction\n    const instruction = new web3.TransactionInstruction({\n      keys,\n      programId: programID,\n      data\n    });\n    \n    // Tạo transaction\n    const transaction = new web3.Transaction().add(instruction);\n    \n    return transaction;\n  } catch (error) {\n    console.error('Lỗi khi tạo giao dịch chuyển tiền:', error);\n    throw error;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}