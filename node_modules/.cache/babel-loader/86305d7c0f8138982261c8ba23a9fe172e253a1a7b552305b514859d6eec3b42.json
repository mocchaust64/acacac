{"ast":null,"code":"import { detect as jo } from \"detect-browser\";\nimport { toMiliseconds as Ae, FIVE_MINUTES as xn, fromMiliseconds as Co } from \"@walletconnect/time\";\nimport { getDocument as Be, getNavigator as Sn, getLocation as On } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as Po } from \"@walletconnect/window-metadata\";\nimport { recoverAddress as ko } from \"viem\";\nimport Vo from \"bs58\";\nimport { decodeJWT as Mo } from \"@walletconnect/relay-auth\";\nimport { toString as Q, fromString as rt, concat as Zt } from \"uint8arrays\";\nimport { RELAY_JSONRPC as Do } from \"@walletconnect/relay-api\";\nconst se = \":\";\nfunction Ie(t) {\n  const [e, n] = t.split(se);\n  return {\n    namespace: e,\n    reference: n\n  };\n}\nfunction An(t) {\n  const {\n    namespace: e,\n    reference: n\n  } = t;\n  return [e, n].join(se);\n}\nfunction Ne(t) {\n  const [e, n, r] = t.split(se);\n  return {\n    namespace: e,\n    reference: n,\n    address: r\n  };\n}\nfunction Bn(t) {\n  const {\n    namespace: e,\n    reference: n,\n    address: r\n  } = t;\n  return [e, n, r].join(se);\n}\nfunction Ue(t, e) {\n  const n = [];\n  return t.forEach(r => {\n    const o = e(r);\n    n.includes(o) || n.push(o);\n  }), n;\n}\nfunction In(t) {\n  const {\n    address: e\n  } = Ne(t);\n  return e;\n}\nfunction Nn(t) {\n  const {\n    namespace: e,\n    reference: n\n  } = Ne(t);\n  return An({\n    namespace: e,\n    reference: n\n  });\n}\nfunction Ho(t, e) {\n  const {\n    namespace: n,\n    reference: r\n  } = Ie(e);\n  return Bn({\n    namespace: n,\n    reference: r,\n    address: t\n  });\n}\nfunction qo(t) {\n  return Ue(t, In);\n}\nfunction Un(t) {\n  return Ue(t, Nn);\n}\nfunction Ko(t, e = []) {\n  const n = [];\n  return Object.keys(t).forEach(r => {\n    if (e.length && !e.includes(r)) return;\n    const o = t[r];\n    n.push(...o.accounts);\n  }), n;\n}\nfunction Fo(t, e = []) {\n  const n = [];\n  return Object.keys(t).forEach(r => {\n    if (e.length && !e.includes(r)) return;\n    const o = t[r];\n    n.push(...Un(o.accounts));\n  }), n;\n}\nfunction zo(t, e = []) {\n  const n = [];\n  return Object.keys(t).forEach(r => {\n    if (e.length && !e.includes(r)) return;\n    const o = t[r];\n    n.push(...ce(r, o));\n  }), n;\n}\nfunction ce(t, e) {\n  return t.includes(\":\") ? [t] : e.chains || [];\n}\nvar Zo = Object.defineProperty,\n  Yo = Object.defineProperties,\n  Go = Object.getOwnPropertyDescriptors,\n  Tn = Object.getOwnPropertySymbols,\n  Wo = Object.prototype.hasOwnProperty,\n  Xo = Object.prototype.propertyIsEnumerable,\n  Rn = (t, e, n) => e in t ? Zo(t, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: n\n  }) : t[e] = n,\n  _n = (t, e) => {\n    for (var n in e || (e = {})) Wo.call(e, n) && Rn(t, n, e[n]);\n    if (Tn) for (var n of Tn(e)) Xo.call(e, n) && Rn(t, n, e[n]);\n    return t;\n  },\n  Jo = (t, e) => Yo(t, Go(e));\nconst $n = \"ReactNative\",\n  Y = {\n    reactNative: \"react-native\",\n    node: \"node\",\n    browser: \"browser\",\n    unknown: \"unknown\"\n  },\n  ae = \" \",\n  Qo = \":\",\n  Ln = \"/\",\n  Te = 2,\n  ti = 1e3,\n  jn = \"js\";\nfunction Re() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction pt() {\n  return !Be() && !!Sn() && navigator.product === $n;\n}\nfunction ei() {\n  return pt() && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\" && (global == null ? void 0 : global.Platform.OS) === \"android\";\n}\nfunction ni() {\n  return pt() && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\" && (global == null ? void 0 : global.Platform.OS) === \"ios\";\n}\nfunction Yt() {\n  return !Re() && !!Sn() && !!Be();\n}\nfunction xt() {\n  return pt() ? Y.reactNative : Re() ? Y.node : Yt() ? Y.browser : Y.unknown;\n}\nfunction ri() {\n  var t;\n  try {\n    return pt() && typeof global < \"u\" && typeof (global == null ? void 0 : global.Application) < \"u\" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;\n  } catch {\n    return;\n  }\n}\nfunction Cn(t, e) {\n  const n = new URLSearchParams(t);\n  for (const r of Object.keys(e).sort()) if (e.hasOwnProperty(r)) {\n    const o = e[r];\n    o !== void 0 && n.set(r, o);\n  }\n  return n.toString();\n}\nfunction oi(t) {\n  var e, n;\n  const r = Pn();\n  try {\n    return t != null && t.url && r.url && t.url !== r.url && (console.warn(`The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${r.url}. This is probably unintended and can lead to issues.`), t.url = r.url), (e = t?.icons) != null && e.length && t.icons.length > 0 && (t.icons = t.icons.filter(o => o !== \"\")), Jo(_n(_n({}, r), t), {\n      url: t?.url || r.url,\n      name: t?.name || r.name,\n      description: t?.description || r.description,\n      icons: (n = t?.icons) != null && n.length && t.icons.length > 0 ? t.icons : r.icons\n    });\n  } catch (o) {\n    return console.warn(\"Error populating app metadata\", o), t || r;\n  }\n}\nfunction Pn() {\n  return Po() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\nfunction ii(t, e) {\n  var n;\n  const r = xt(),\n    o = {\n      protocol: t,\n      version: e,\n      env: r\n    };\n  return r === \"browser\" && (o.host = ((n = On()) == null ? void 0 : n.host) || \"unknown\"), o;\n}\nfunction kn() {\n  if (xt() === Y.reactNative && typeof global < \"u\" && typeof (global == null ? void 0 : global.Platform) < \"u\") {\n    const {\n      OS: n,\n      Version: r\n    } = global.Platform;\n    return [n, r].join(\"-\");\n  }\n  const t = jo();\n  if (t === null) return \"unknown\";\n  const e = t.os ? t.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return t.type === \"browser\" ? [e, t.name, t.version].join(\"-\") : [e, t.version].join(\"-\");\n}\nfunction Vn() {\n  var t;\n  const e = xt();\n  return e === Y.browser ? [e, ((t = On()) == null ? void 0 : t.host) || \"unknown\"].join(\":\") : e;\n}\nfunction Mn(t, e, n) {\n  const r = kn(),\n    o = Vn();\n  return [[t, e].join(\"-\"), [jn, n].join(\"-\"), r, o].join(\"/\");\n}\nfunction si({\n  protocol: t,\n  version: e,\n  relayUrl: n,\n  sdkVersion: r,\n  auth: o,\n  projectId: i,\n  useOnCloseEvent: s,\n  bundleId: c,\n  packageName: a\n}) {\n  const u = n.split(\"?\"),\n    l = Mn(t, e, r),\n    f = {\n      auth: o,\n      ua: l,\n      projectId: i,\n      useOnCloseEvent: s || void 0,\n      packageName: a || void 0,\n      bundleId: c || void 0\n    },\n    h = Cn(u[1] || \"\", f);\n  return u[0] + \"?\" + h;\n}\nfunction ci(t) {\n  let e = (t.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  const n = typeof e < \"u\" ? t.split(\"://\")[1] : t;\n  return e = e === \"wss\" ? \"https\" : \"http\", [e, n].join(\"://\");\n}\nfunction ai(t, e, n) {\n  if (!t[e] || typeof t[e] !== n) throw new Error(`Missing or invalid \"${e}\" param`);\n}\nfunction Dn(t, e = Te) {\n  return Hn(t.split(Ln), e);\n}\nfunction ui(t) {\n  return Dn(t).join(ae);\n}\nfunction gt(t, e) {\n  return t.filter(n => e.includes(n)).length === t.length;\n}\nfunction Hn(t, e = Te) {\n  return t.slice(Math.max(t.length - e, 0));\n}\nfunction fi(t) {\n  return Object.fromEntries(t.entries());\n}\nfunction li(t) {\n  return new Map(Object.entries(t));\n}\nfunction di(t, e) {\n  const n = {};\n  return Object.keys(t).forEach(r => {\n    n[r] = e(t[r]);\n  }), n;\n}\nconst hi = t => t;\nfunction qn(t) {\n  return t.trim().replace(/^\\w/, e => e.toUpperCase());\n}\nfunction pi(t) {\n  return t.split(ae).map(e => qn(e)).join(ae);\n}\nfunction gi(t = xn, e) {\n  const n = Ae(t || xn);\n  let r, o, i, s;\n  return {\n    resolve: c => {\n      i && r && (clearTimeout(i), r(c), s = Promise.resolve(c));\n    },\n    reject: c => {\n      i && o && (clearTimeout(i), o(c));\n    },\n    done: () => new Promise((c, a) => {\n      if (s) return c(s);\n      i = setTimeout(() => {\n        const u = new Error(e);\n        s = Promise.reject(u), a(u);\n      }, n), r = c, o = a;\n    })\n  };\n}\nfunction yi(t, e, n) {\n  return new Promise(async (r, o) => {\n    const i = setTimeout(() => o(new Error(n)), e);\n    try {\n      const s = await t;\n      r(s);\n    } catch (s) {\n      o(s);\n    }\n    clearTimeout(i);\n  });\n}\nfunction _e(t, e) {\n  if (typeof e == \"string\" && e.startsWith(`${t}:`)) return e;\n  if (t.toLowerCase() === \"topic\") {\n    if (typeof e != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${e}`;\n  } else if (t.toLowerCase() === \"id\") {\n    if (typeof e != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${e}`;\n  }\n  throw new Error(`Unknown expirer target type: ${t}`);\n}\nfunction mi(t) {\n  return _e(\"topic\", t);\n}\nfunction wi(t) {\n  return _e(\"id\", t);\n}\nfunction bi(t) {\n  const [e, n] = t.split(\":\"),\n    r = {\n      id: void 0,\n      topic: void 0\n    };\n  if (e === \"topic\" && typeof n == \"string\") r.topic = n;else if (e === \"id\" && Number.isInteger(Number(n))) r.id = Number(n);else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${n}`);\n  return r;\n}\nfunction Ei(t, e) {\n  return Co((e || Date.now()) + Ae(t));\n}\nfunction vi(t) {\n  return Date.now() >= Ae(t);\n}\nfunction xi(t, e) {\n  return `${t}${e ? `:${e}` : \"\"}`;\n}\nfunction at(t = [], e = []) {\n  return [...new Set([...t, ...e])];\n}\nasync function Si({\n  id: t,\n  topic: e,\n  wcDeepLink: n\n}) {\n  var r;\n  try {\n    if (!n) return;\n    const o = typeof n == \"string\" ? JSON.parse(n) : n,\n      i = o?.href;\n    if (typeof i != \"string\") return;\n    const s = Kn(i, t, e),\n      c = xt();\n    if (c === Y.browser) {\n      if (!((r = Be()) != null && r.hasFocus())) {\n        console.warn(\"Document does not have focus, skipping deeplink.\");\n        return;\n      }\n      Fn(s);\n    } else c === Y.reactNative && typeof (global == null ? void 0 : global.Linking) < \"u\" && (await global.Linking.openURL(s));\n  } catch (o) {\n    console.error(o);\n  }\n}\nfunction Kn(t, e, n) {\n  const r = `requestId=${e}&sessionTopic=${n}`;\n  t.endsWith(\"/\") && (t = t.slice(0, -1));\n  let o = `${t}`;\n  if (t.startsWith(\"https://t.me\")) {\n    const i = t.includes(\"?\") ? \"&startapp=\" : \"?startapp=\";\n    o = `${o}${i}${Yn(r, !0)}`;\n  } else o = `${o}/wc?${r}`;\n  return o;\n}\nfunction Fn(t) {\n  let e = \"_self\";\n  Zn() ? e = \"_top\" : (zn() || t.startsWith(\"https://\") || t.startsWith(\"http://\")) && (e = \"_blank\"), window.open(t, e, \"noreferrer noopener\");\n}\nasync function Oi(t, e) {\n  let n = \"\";\n  try {\n    if (Yt() && (n = localStorage.getItem(e), n)) return n;\n    n = await t.getItem(e);\n  } catch (r) {\n    console.error(r);\n  }\n  return n;\n}\nfunction $e(t, e) {\n  return t.filter(n => e.includes(n));\n}\nfunction Ai(t, e) {\n  if (!t.includes(e)) return null;\n  const n = t.split(/([&,?,=])/),\n    r = n.indexOf(e);\n  return n[r + 2];\n}\nfunction Bi() {\n  return typeof crypto < \"u\" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/gu, t => {\n    const e = Math.random() * 16 | 0;\n    return (t === \"x\" ? e : e & 3 | 8).toString(16);\n  });\n}\nfunction Ii() {\n  return typeof process < \"u\" && process.env.IS_VITEST === \"true\";\n}\nfunction zn() {\n  return typeof window < \"u\" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);\n}\nfunction Zn() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !1;\n  }\n}\nfunction Yn(t, e = !1) {\n  const n = Buffer.from(t).toString(\"base64\");\n  return e ? n.replace(/[=]/g, \"\") : n;\n}\nfunction Le(t) {\n  return Buffer.from(t, \"base64\").toString(\"utf-8\");\n}\nfunction Ni(t) {\n  return new Promise(e => setTimeout(e, t));\n}\nfunction Gt(t) {\n  if (!Number.isSafeInteger(t) || t < 0) throw new Error(\"positive integer expected, got \" + t);\n}\nfunction Ui(t) {\n  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === \"Uint8Array\";\n}\nfunction Wt(t, ...e) {\n  if (!Ui(t)) throw new Error(\"Uint8Array expected\");\n  if (e.length > 0 && !e.includes(t.length)) throw new Error(\"Uint8Array expected of length \" + e + \", got length=\" + t.length);\n}\nfunction je(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  Gt(t.outputLen), Gt(t.blockLen);\n}\nfunction Tt(t, e = !0) {\n  if (t.destroyed) throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction Gn(t, e) {\n  Wt(t);\n  const n = e.outputLen;\n  if (t.length < n) throw new Error(\"digestInto() expects output buffer of length at least \" + n);\n}\nconst ue = BigInt(2 ** 32 - 1),\n  Wn = BigInt(32);\nfunction Ti(t, e = !1) {\n  return e ? {\n    h: Number(t & ue),\n    l: Number(t >> Wn & ue)\n  } : {\n    h: Number(t >> Wn & ue) | 0,\n    l: Number(t & ue) | 0\n  };\n}\nfunction Ri(t, e = !1) {\n  let n = new Uint32Array(t.length),\n    r = new Uint32Array(t.length);\n  for (let o = 0; o < t.length; o++) {\n    const {\n      h: i,\n      l: s\n    } = Ti(t[o], e);\n    [n[o], r[o]] = [i, s];\n  }\n  return [n, r];\n}\nconst _i = (t, e, n) => t << n | e >>> 32 - n,\n  $i = (t, e, n) => e << n | t >>> 32 - n,\n  Li = (t, e, n) => e << n - 32 | t >>> 64 - n,\n  ji = (t, e, n) => t << n - 32 | e >>> 64 - n,\n  Rt = typeof globalThis == \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0;\nfunction Ci(t) {\n  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));\n}\nfunction Ce(t) {\n  return new DataView(t.buffer, t.byteOffset, t.byteLength);\n}\nfunction st(t, e) {\n  return t << 32 - e | t >>> e;\n}\nconst Xn = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nfunction Pi(t) {\n  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;\n}\nfunction Jn(t) {\n  for (let e = 0; e < t.length; e++) t[e] = Pi(t[e]);\n}\nfunction ki(t) {\n  if (typeof t != \"string\") throw new Error(\"utf8ToBytes expected string, got \" + typeof t);\n  return new Uint8Array(new TextEncoder().encode(t));\n}\nfunction _t(t) {\n  return typeof t == \"string\" && (t = ki(t)), Wt(t), t;\n}\nfunction Vi(...t) {\n  let e = 0;\n  for (let r = 0; r < t.length; r++) {\n    const o = t[r];\n    Wt(o), e += o.length;\n  }\n  const n = new Uint8Array(e);\n  for (let r = 0, o = 0; r < t.length; r++) {\n    const i = t[r];\n    n.set(i, o), o += i.length;\n  }\n  return n;\n}\nclass Pe {\n  clone() {\n    return this._cloneInto();\n  }\n}\nfunction Qn(t) {\n  const e = r => t().update(_t(r)).digest(),\n    n = t();\n  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;\n}\nfunction $t(t = 32) {\n  if (Rt && typeof Rt.getRandomValues == \"function\") return Rt.getRandomValues(new Uint8Array(t));\n  if (Rt && typeof Rt.randomBytes == \"function\") return Rt.randomBytes(t);\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nconst tr = [],\n  er = [],\n  nr = [],\n  Mi = BigInt(0),\n  Xt = BigInt(1),\n  Di = BigInt(2),\n  Hi = BigInt(7),\n  qi = BigInt(256),\n  Ki = BigInt(113);\nfor (let t = 0, e = Xt, n = 1, r = 0; t < 24; t++) {\n  [n, r] = [r, (2 * n + 3 * r) % 5], tr.push(2 * (5 * r + n)), er.push((t + 1) * (t + 2) / 2 % 64);\n  let o = Mi;\n  for (let i = 0; i < 7; i++) e = (e << Xt ^ (e >> Hi) * Ki) % qi, e & Di && (o ^= Xt << (Xt << BigInt(i)) - Xt);\n  nr.push(o);\n}\nconst [Fi, zi] = Ri(nr, !0),\n  rr = (t, e, n) => n > 32 ? Li(t, e, n) : _i(t, e, n),\n  or = (t, e, n) => n > 32 ? ji(t, e, n) : $i(t, e, n);\nfunction Zi(t, e = 24) {\n  const n = new Uint32Array(10);\n  for (let r = 24 - e; r < 24; r++) {\n    for (let s = 0; s < 10; s++) n[s] = t[s] ^ t[s + 10] ^ t[s + 20] ^ t[s + 30] ^ t[s + 40];\n    for (let s = 0; s < 10; s += 2) {\n      const c = (s + 8) % 10,\n        a = (s + 2) % 10,\n        u = n[a],\n        l = n[a + 1],\n        f = rr(u, l, 1) ^ n[c],\n        h = or(u, l, 1) ^ n[c + 1];\n      for (let y = 0; y < 50; y += 10) t[s + y] ^= f, t[s + y + 1] ^= h;\n    }\n    let o = t[2],\n      i = t[3];\n    for (let s = 0; s < 24; s++) {\n      const c = er[s],\n        a = rr(o, i, c),\n        u = or(o, i, c),\n        l = tr[s];\n      o = t[l], i = t[l + 1], t[l] = a, t[l + 1] = u;\n    }\n    for (let s = 0; s < 50; s += 10) {\n      for (let c = 0; c < 10; c++) n[c] = t[s + c];\n      for (let c = 0; c < 10; c++) t[s + c] ^= ~n[(c + 2) % 10] & n[(c + 4) % 10];\n    }\n    t[0] ^= Fi[r], t[1] ^= zi[r];\n  }\n  n.fill(0);\n}\nclass En extends Pe {\n  constructor(e, n, r, o = !1, i = 24) {\n    if (super(), this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = o, this.rounds = i, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Gt(r), 0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n    this.state = new Uint8Array(200), this.state32 = Ci(this.state);\n  }\n  keccak() {\n    Xn || Jn(this.state32), Zi(this.state32, this.rounds), Xn || Jn(this.state32), this.posOut = 0, this.pos = 0;\n  }\n  update(e) {\n    Tt(this);\n    const {\n      blockLen: n,\n      state: r\n    } = this;\n    e = _t(e);\n    const o = e.length;\n    for (let i = 0; i < o;) {\n      const s = Math.min(n - this.pos, o - i);\n      for (let c = 0; c < s; c++) r[this.pos++] ^= e[i++];\n      this.pos === n && this.keccak();\n    }\n    return this;\n  }\n  finish() {\n    if (this.finished) return;\n    this.finished = !0;\n    const {\n      state: e,\n      suffix: n,\n      pos: r,\n      blockLen: o\n    } = this;\n    e[r] ^= n, (n & 128) !== 0 && r === o - 1 && this.keccak(), e[o - 1] ^= 128, this.keccak();\n  }\n  writeInto(e) {\n    Tt(this, !1), Wt(e), this.finish();\n    const n = this.state,\n      {\n        blockLen: r\n      } = this;\n    for (let o = 0, i = e.length; o < i;) {\n      this.posOut >= r && this.keccak();\n      const s = Math.min(r - this.posOut, i - o);\n      e.set(n.subarray(this.posOut, this.posOut + s), o), this.posOut += s, o += s;\n    }\n    return e;\n  }\n  xofInto(e) {\n    if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n    return this.writeInto(e);\n  }\n  xof(e) {\n    return Gt(e), this.xofInto(new Uint8Array(e));\n  }\n  digestInto(e) {\n    if (Gn(e, this), this.finished) throw new Error(\"digest() was already called\");\n    return this.writeInto(e), this.destroy(), e;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = !0, this.state.fill(0);\n  }\n  _cloneInto(e) {\n    const {\n      blockLen: n,\n      suffix: r,\n      outputLen: o,\n      rounds: i,\n      enableXOF: s\n    } = this;\n    return e || (e = new En(n, r, o, s, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = r, e.outputLen = o, e.enableXOF = s, e.destroyed = this.destroyed, e;\n  }\n}\nconst Yi = (t, e, n) => Qn(() => new En(e, t, n)),\n  Gi = Yi(1, 136, 256 / 8),\n  Wi = \"https://rpc.walletconnect.org/v1\";\nfunction ke(t) {\n  const e = `\u0019Ethereum Signed Message:\n${t.length}`,\n    n = new TextEncoder().encode(e + t);\n  return \"0x\" + Buffer.from(Gi(n)).toString(\"hex\");\n}\nasync function ir(t, e, n, r, o, i) {\n  switch (n.t) {\n    case \"eip191\":\n      return await sr(t, e, n.s);\n    case \"eip1271\":\n      return await cr(t, e, n.s, r, o, i);\n    default:\n      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n.t}`);\n  }\n}\nasync function sr(t, e, n) {\n  return (await ko({\n    hash: ke(e),\n    signature: n\n  })).toLowerCase() === t.toLowerCase();\n}\nasync function cr(t, e, n, r, o, i) {\n  const s = Ie(r);\n  if (!s.namespace || !s.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`);\n  try {\n    const c = \"0x1626ba7e\",\n      a = \"0000000000000000000000000000000000000000000000000000000000000040\",\n      u = \"0000000000000000000000000000000000000000000000000000000000000041\",\n      l = n.substring(2),\n      f = ke(e).substring(2),\n      h = c + f + a + u + l,\n      y = await fetch(`${i || Wi}/?chainId=${r}&projectId=${o}`, {\n        method: \"POST\",\n        body: JSON.stringify({\n          id: Xi(),\n          jsonrpc: \"2.0\",\n          method: \"eth_call\",\n          params: [{\n            to: t,\n            data: h\n          }, \"latest\"]\n        })\n      }),\n      {\n        result: E\n      } = await y.json();\n    return E ? E.slice(0, c.length).toLowerCase() === c.toLowerCase() : !1;\n  } catch (c) {\n    return console.error(\"isValidEip1271Signature: \", c), !1;\n  }\n}\nfunction Xi() {\n  return Date.now() + Math.floor(Math.random() * 1e3);\n}\nfunction Ji(t) {\n  const e = atob(t),\n    n = new Uint8Array(e.length);\n  for (let s = 0; s < e.length; s++) n[s] = e.charCodeAt(s);\n  const r = n[0];\n  if (r === 0) throw new Error(\"No signatures found\");\n  const o = 1 + r * 64;\n  if (n.length < o) throw new Error(\"Transaction data too short for claimed signature count\");\n  if (n.length < 100) throw new Error(\"Transaction too short\");\n  const i = Buffer.from(t, \"base64\").slice(1, 65);\n  return Vo.encode(i);\n}\nvar Qi = Object.defineProperty,\n  ts = Object.defineProperties,\n  es = Object.getOwnPropertyDescriptors,\n  ar = Object.getOwnPropertySymbols,\n  ns = Object.prototype.hasOwnProperty,\n  rs = Object.prototype.propertyIsEnumerable,\n  ur = (t, e, n) => e in t ? Qi(t, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: n\n  }) : t[e] = n,\n  Ve = (t, e) => {\n    for (var n in e || (e = {})) ns.call(e, n) && ur(t, n, e[n]);\n    if (ar) for (var n of ar(e)) rs.call(e, n) && ur(t, n, e[n]);\n    return t;\n  },\n  fr = (t, e) => ts(t, es(e));\nconst os = \"did:pkh:\",\n  fe = t => t?.split(\":\"),\n  lr = t => {\n    const e = t && fe(t);\n    if (e) return t.includes(os) ? e[3] : e[1];\n  },\n  dr = t => {\n    const e = t && fe(t);\n    if (e) return e[2] + \":\" + e[3];\n  },\n  Me = t => {\n    const e = t && fe(t);\n    if (e) return e.pop();\n  };\nasync function is(t) {\n  const {\n      cacao: e,\n      projectId: n\n    } = t,\n    {\n      s: r,\n      p: o\n    } = e,\n    i = hr(o, o.iss),\n    s = Me(o.iss);\n  return await ir(s, i, r, dr(o.iss), n);\n}\nconst hr = (t, e) => {\n  const n = `${t.domain} wants you to sign in with your Ethereum account:`,\n    r = Me(e);\n  if (!t.aud && !t.uri) throw new Error(\"Either `aud` or `uri` is required to construct the message\");\n  let o = t.statement || void 0;\n  const i = `URI: ${t.aud || t.uri}`,\n    s = `Version: ${t.version}`,\n    c = `Chain ID: ${lr(e)}`,\n    a = `Nonce: ${t.nonce}`,\n    u = `Issued At: ${t.iat}`,\n    l = t.exp ? `Expiration Time: ${t.exp}` : void 0,\n    f = t.nbf ? `Not Before: ${t.nbf}` : void 0,\n    h = t.requestId ? `Request ID: ${t.requestId}` : void 0,\n    y = t.resources ? `Resources:${t.resources.map(p => `\n- ${p}`).join(\"\")}` : void 0,\n    E = de(t.resources);\n  if (E) {\n    const p = yt(E);\n    o = qe(o, p);\n  }\n  return [n, r, \"\", o, \"\", i, s, c, a, u, l, f, h, y].filter(p => p != null).join(`\n`);\n};\nfunction ss(t, e, n) {\n  return n.includes(\"did:pkh:\") || (n = `did:pkh:${n}`), {\n    h: {\n      t: \"caip122\"\n    },\n    p: {\n      iss: n,\n      domain: t.domain,\n      aud: t.aud,\n      version: t.version,\n      nonce: t.nonce,\n      iat: t.iat,\n      statement: t.statement,\n      requestId: t.requestId,\n      resources: t.resources,\n      nbf: t.nbf,\n      exp: t.exp\n    },\n    s: e\n  };\n}\nfunction cs(t) {\n  var e;\n  const {\n      authPayload: n,\n      chains: r,\n      methods: o\n    } = t,\n    i = n.statement || \"\";\n  if (!(r != null && r.length)) return n;\n  const s = n.chains,\n    c = $e(s, r);\n  if (!(c != null && c.length)) throw new Error(\"No supported chains\");\n  const a = pr(n.resources);\n  if (!a) return n;\n  ct(a);\n  const u = gr(a, \"eip155\");\n  let l = n?.resources || [];\n  if (u != null && u.length) {\n    const f = yr(u),\n      h = $e(f, o);\n    if (!(h != null && h.length)) throw new Error(`Supported methods don't satisfy the requested: ${JSON.stringify(f)}, supported: ${JSON.stringify(o)}`);\n    const y = De(\"request\", h, {\n        chains: c\n      }),\n      E = Er(a, \"eip155\", y);\n    l = ((e = n?.resources) == null ? void 0 : e.slice(0, -1)) || [], l.push(le(E));\n  }\n  return fr(Ve({}, n), {\n    statement: xr(i, de(l)),\n    chains: c,\n    resources: n != null && n.resources || l.length > 0 ? l : void 0\n  });\n}\nfunction pr(t) {\n  const e = de(t);\n  if (e && He(e)) return yt(e);\n}\nfunction as(t, e) {\n  var n;\n  return (n = t?.att) == null ? void 0 : n.hasOwnProperty(e);\n}\nfunction gr(t, e) {\n  var n, r;\n  return (n = t?.att) != null && n[e] ? Object.keys((r = t?.att) == null ? void 0 : r[e]) : [];\n}\nfunction us(t) {\n  return t?.map(e => Object.keys(e)) || [];\n}\nfunction yr(t) {\n  return t?.map(e => {\n    var n;\n    return (n = e.split(\"/\")) == null ? void 0 : n[1];\n  }) || [];\n}\nfunction mr(t) {\n  return Buffer.from(JSON.stringify(t)).toString(\"base64\");\n}\nfunction wr(t) {\n  return JSON.parse(Buffer.from(t, \"base64\").toString(\"utf-8\"));\n}\nfunction ct(t) {\n  if (!t) throw new Error(\"No recap provided, value is undefined\");\n  if (!t.att) throw new Error(\"No `att` property found\");\n  const e = Object.keys(t.att);\n  if (!(e != null && e.length)) throw new Error(\"No resources found in `att` property\");\n  e.forEach(n => {\n    const r = t.att[n];\n    if (Array.isArray(r)) throw new Error(`Resource must be an object: ${n}`);\n    if (typeof r != \"object\") throw new Error(`Resource must be an object: ${n}`);\n    if (!Object.keys(r).length) throw new Error(`Resource object is empty: ${n}`);\n    Object.keys(r).forEach(o => {\n      const i = r[o];\n      if (!Array.isArray(i)) throw new Error(`Ability limits ${o} must be an array of objects, found: ${i}`);\n      if (!i.length) throw new Error(`Value of ${o} is empty array, must be an array with objects`);\n      i.forEach(s => {\n        if (typeof s != \"object\") throw new Error(`Ability limits (${o}) must be an array of objects, found: ${s}`);\n      });\n    });\n  });\n}\nfunction br(t, e, n, r = {}) {\n  return n?.sort((o, i) => o.localeCompare(i)), {\n    att: {\n      [t]: De(e, n, r)\n    }\n  };\n}\nfunction Er(t, e, n) {\n  var r;\n  t.att[e] = Ve({}, n);\n  const o = (r = Object.keys(t.att)) == null ? void 0 : r.sort((s, c) => s.localeCompare(c)),\n    i = {\n      att: {}\n    };\n  return o.reduce((s, c) => (s.att[c] = t.att[c], s), i);\n}\nfunction De(t, e, n = {}) {\n  e = e?.sort((o, i) => o.localeCompare(i));\n  const r = e.map(o => ({\n    [`${t}/${o}`]: [n]\n  }));\n  return Object.assign({}, ...r);\n}\nfunction le(t) {\n  return ct(t), `urn:recap:${mr(t).replace(/=/g, \"\")}`;\n}\nfunction yt(t) {\n  const e = wr(t.replace(\"urn:recap:\", \"\"));\n  return ct(e), e;\n}\nfunction fs(t, e, n) {\n  const r = br(t, e, n);\n  return le(r);\n}\nfunction He(t) {\n  return t && t.includes(\"urn:recap:\");\n}\nfunction ls(t, e) {\n  const n = yt(t),\n    r = yt(e),\n    o = vr(n, r);\n  return le(o);\n}\nfunction vr(t, e) {\n  ct(t), ct(e);\n  const n = Object.keys(t.att).concat(Object.keys(e.att)).sort((o, i) => o.localeCompare(i)),\n    r = {\n      att: {}\n    };\n  return n.forEach(o => {\n    var i, s;\n    Object.keys(((i = t.att) == null ? void 0 : i[o]) || {}).concat(Object.keys(((s = e.att) == null ? void 0 : s[o]) || {})).sort((c, a) => c.localeCompare(a)).forEach(c => {\n      var a, u;\n      r.att[o] = fr(Ve({}, r.att[o]), {\n        [c]: ((a = t.att[o]) == null ? void 0 : a[c]) || ((u = e.att[o]) == null ? void 0 : u[c])\n      });\n    });\n  }), r;\n}\nfunction qe(t = \"\", e) {\n  ct(e);\n  const n = \"I further authorize the stated URI to perform the following actions on my behalf: \";\n  if (t.includes(n)) return t;\n  const r = [];\n  let o = 0;\n  Object.keys(e.att).forEach(c => {\n    const a = Object.keys(e.att[c]).map(f => ({\n      ability: f.split(\"/\")[0],\n      action: f.split(\"/\")[1]\n    }));\n    a.sort((f, h) => f.action.localeCompare(h.action));\n    const u = {};\n    a.forEach(f => {\n      u[f.ability] || (u[f.ability] = []), u[f.ability].push(f.action);\n    });\n    const l = Object.keys(u).map(f => (o++, `(${o}) '${f}': '${u[f].join(\"', '\")}' for '${c}'.`));\n    r.push(l.join(\", \").replace(\".,\", \".\"));\n  });\n  const i = r.join(\" \"),\n    s = `${n}${i}`;\n  return `${t ? t + \" \" : \"\"}${s}`;\n}\nfunction ds(t) {\n  var e;\n  const n = yt(t);\n  ct(n);\n  const r = (e = n.att) == null ? void 0 : e.eip155;\n  return r ? Object.keys(r).map(o => o.split(\"/\")[1]) : [];\n}\nfunction hs(t) {\n  const e = yt(t);\n  ct(e);\n  const n = [];\n  return Object.values(e.att).forEach(r => {\n    Object.values(r).forEach(o => {\n      var i;\n      (i = o?.[0]) != null && i.chains && n.push(o[0].chains);\n    });\n  }), [...new Set(n.flat())];\n}\nfunction xr(t, e) {\n  if (!e) return t;\n  const n = yt(e);\n  return ct(n), qe(t, n);\n}\nfunction de(t) {\n  if (!t) return;\n  const e = t?.[t.length - 1];\n  return He(e) ? e : void 0;\n}\nfunction Ke(t) {\n  if (!Number.isSafeInteger(t) || t < 0) throw new Error(\"positive integer expected, got \" + t);\n}\nfunction Sr(t) {\n  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === \"Uint8Array\";\n}\nfunction tt(t, ...e) {\n  if (!Sr(t)) throw new Error(\"Uint8Array expected\");\n  if (e.length > 0 && !e.includes(t.length)) throw new Error(\"Uint8Array expected of length \" + e + \", got length=\" + t.length);\n}\nfunction Or(t, e = !0) {\n  if (t.destroyed) throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction ps(t, e) {\n  tt(t);\n  const n = e.outputLen;\n  if (t.length < n) throw new Error(\"digestInto() expects output buffer of length at least \" + n);\n}\nfunction Ar(t) {\n  if (typeof t != \"boolean\") throw new Error(`boolean expected, not ${t}`);\n}\nconst mt = t => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)),\n  gs = t => new DataView(t.buffer, t.byteOffset, t.byteLength),\n  ys = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nif (!ys) throw new Error(\"Non little-endian hardware is not supported\");\nfunction ms(t) {\n  if (typeof t != \"string\") throw new Error(\"string expected\");\n  return new Uint8Array(new TextEncoder().encode(t));\n}\nfunction Fe(t) {\n  if (typeof t == \"string\") t = ms(t);else if (Sr(t)) t = ze(t);else throw new Error(\"Uint8Array expected, got \" + typeof t);\n  return t;\n}\nfunction ws(t, e) {\n  if (e == null || typeof e != \"object\") throw new Error(\"options must be defined\");\n  return Object.assign(t, e);\n}\nfunction bs(t, e) {\n  if (t.length !== e.length) return !1;\n  let n = 0;\n  for (let r = 0; r < t.length; r++) n |= t[r] ^ e[r];\n  return n === 0;\n}\nconst Es = (t, e) => {\n  function n(r, ...o) {\n    if (tt(r), t.nonceLength !== void 0) {\n      const l = o[0];\n      if (!l) throw new Error(\"nonce / iv required\");\n      t.varSizeNonce ? tt(l) : tt(l, t.nonceLength);\n    }\n    const i = t.tagLength;\n    i && o[1] !== void 0 && tt(o[1]);\n    const s = e(r, ...o),\n      c = (l, f) => {\n        if (f !== void 0) {\n          if (l !== 2) throw new Error(\"cipher output not supported\");\n          tt(f);\n        }\n      };\n    let a = !1;\n    return {\n      encrypt(l, f) {\n        if (a) throw new Error(\"cannot encrypt() twice with same key + nonce\");\n        return a = !0, tt(l), c(s.encrypt.length, f), s.encrypt(l, f);\n      },\n      decrypt(l, f) {\n        if (tt(l), i && l.length < i) throw new Error(\"invalid ciphertext length: smaller than tagLength=\" + i);\n        return c(s.decrypt.length, f), s.decrypt(l, f);\n      }\n    };\n  }\n  return Object.assign(n, t), n;\n};\nfunction Br(t, e, n = !0) {\n  if (e === void 0) return new Uint8Array(t);\n  if (e.length !== t) throw new Error(\"invalid output length, expected \" + t + \", got: \" + e.length);\n  if (n && !vs(e)) throw new Error(\"invalid output, must be aligned\");\n  return e;\n}\nfunction Ir(t, e, n, r) {\n  if (typeof t.setBigUint64 == \"function\") return t.setBigUint64(e, n, r);\n  const o = BigInt(32),\n    i = BigInt(4294967295),\n    s = Number(n >> o & i),\n    c = Number(n & i),\n    a = r ? 4 : 0,\n    u = r ? 0 : 4;\n  t.setUint32(e + a, s, r), t.setUint32(e + u, c, r);\n}\nfunction vs(t) {\n  return t.byteOffset % 4 === 0;\n}\nfunction ze(t) {\n  return Uint8Array.from(t);\n}\nfunction Lt(...t) {\n  for (let e = 0; e < t.length; e++) t[e].fill(0);\n}\nconst Nr = t => Uint8Array.from(t.split(\"\").map(e => e.charCodeAt(0))),\n  xs = Nr(\"expand 16-byte k\"),\n  Ss = Nr(\"expand 32-byte k\"),\n  Os = mt(xs),\n  As = mt(Ss);\nfunction V(t, e) {\n  return t << e | t >>> 32 - e;\n}\nfunction Ze(t) {\n  return t.byteOffset % 4 === 0;\n}\nconst he = 64,\n  Bs = 16,\n  Ur = 2 ** 32 - 1,\n  Tr = new Uint32Array();\nfunction Is(t, e, n, r, o, i, s, c) {\n  const a = o.length,\n    u = new Uint8Array(he),\n    l = mt(u),\n    f = Ze(o) && Ze(i),\n    h = f ? mt(o) : Tr,\n    y = f ? mt(i) : Tr;\n  for (let E = 0; E < a; s++) {\n    if (t(e, n, r, l, s, c), s >= Ur) throw new Error(\"arx: counter overflow\");\n    const p = Math.min(he, a - E);\n    if (f && p === he) {\n      const d = E / 4;\n      if (E % 4 !== 0) throw new Error(\"arx: invalid block position\");\n      for (let v = 0, m; v < Bs; v++) m = d + v, y[m] = h[m] ^ l[v];\n      E += he;\n      continue;\n    }\n    for (let d = 0, v; d < p; d++) v = E + d, i[v] = o[v] ^ u[d];\n    E += p;\n  }\n}\nfunction Ns(t, e) {\n  const {\n    allowShortKeys: n,\n    extendNonceFn: r,\n    counterLength: o,\n    counterRight: i,\n    rounds: s\n  } = ws({\n    allowShortKeys: !1,\n    counterLength: 8,\n    counterRight: !1,\n    rounds: 20\n  }, e);\n  if (typeof t != \"function\") throw new Error(\"core must be a function\");\n  return Ke(o), Ke(s), Ar(i), Ar(n), (c, a, u, l, f = 0) => {\n    tt(c), tt(a), tt(u);\n    const h = u.length;\n    if (l === void 0 && (l = new Uint8Array(h)), tt(l), Ke(f), f < 0 || f >= Ur) throw new Error(\"arx: counter overflow\");\n    if (l.length < h) throw new Error(`arx: output (${l.length}) is shorter than data (${h})`);\n    const y = [];\n    let E = c.length,\n      p,\n      d;\n    if (E === 32) y.push(p = ze(c)), d = As;else if (E === 16 && n) p = new Uint8Array(32), p.set(c), p.set(c, 16), d = Os, y.push(p);else throw new Error(`arx: invalid 32-byte key, got length=${E}`);\n    Ze(a) || y.push(a = ze(a));\n    const v = mt(p);\n    if (r) {\n      if (a.length !== 24) throw new Error(\"arx: extended nonce must be 24 bytes\");\n      r(d, v, mt(a.subarray(0, 16)), v), a = a.subarray(16);\n    }\n    const m = 16 - o;\n    if (m !== a.length) throw new Error(`arx: nonce must be ${m} or 16 bytes`);\n    if (m !== 12) {\n      const N = new Uint8Array(12);\n      N.set(a, i ? 0 : 12 - a.length), a = N, y.push(a);\n    }\n    const O = mt(a);\n    return Is(t, d, v, O, u, l, f, s), Lt(...y), l;\n  };\n}\nconst F = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;\nclass Us {\n  constructor(e) {\n    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, e = Fe(e), tt(e, 32);\n    const n = F(e, 0),\n      r = F(e, 2),\n      o = F(e, 4),\n      i = F(e, 6),\n      s = F(e, 8),\n      c = F(e, 10),\n      a = F(e, 12),\n      u = F(e, 14);\n    this.r[0] = n & 8191, this.r[1] = (n >>> 13 | r << 3) & 8191, this.r[2] = (r >>> 10 | o << 6) & 7939, this.r[3] = (o >>> 7 | i << 9) & 8191, this.r[4] = (i >>> 4 | s << 12) & 255, this.r[5] = s >>> 1 & 8190, this.r[6] = (s >>> 14 | c << 2) & 8191, this.r[7] = (c >>> 11 | a << 5) & 8065, this.r[8] = (a >>> 8 | u << 8) & 8191, this.r[9] = u >>> 5 & 127;\n    for (let l = 0; l < 8; l++) this.pad[l] = F(e, 16 + 2 * l);\n  }\n  process(e, n, r = !1) {\n    const o = r ? 0 : 2048,\n      {\n        h: i,\n        r: s\n      } = this,\n      c = s[0],\n      a = s[1],\n      u = s[2],\n      l = s[3],\n      f = s[4],\n      h = s[5],\n      y = s[6],\n      E = s[7],\n      p = s[8],\n      d = s[9],\n      v = F(e, n + 0),\n      m = F(e, n + 2),\n      O = F(e, n + 4),\n      N = F(e, n + 6),\n      $ = F(e, n + 8),\n      B = F(e, n + 10),\n      A = F(e, n + 12),\n      T = F(e, n + 14);\n    let S = i[0] + (v & 8191),\n      L = i[1] + ((v >>> 13 | m << 3) & 8191),\n      U = i[2] + ((m >>> 10 | O << 6) & 8191),\n      _ = i[3] + ((O >>> 7 | N << 9) & 8191),\n      j = i[4] + ((N >>> 4 | $ << 12) & 8191),\n      g = i[5] + ($ >>> 1 & 8191),\n      w = i[6] + (($ >>> 14 | B << 2) & 8191),\n      b = i[7] + ((B >>> 11 | A << 5) & 8191),\n      I = i[8] + ((A >>> 8 | T << 8) & 8191),\n      R = i[9] + (T >>> 5 | o),\n      x = 0,\n      C = x + S * c + L * (5 * d) + U * (5 * p) + _ * (5 * E) + j * (5 * y);\n    x = C >>> 13, C &= 8191, C += g * (5 * h) + w * (5 * f) + b * (5 * l) + I * (5 * u) + R * (5 * a), x += C >>> 13, C &= 8191;\n    let P = x + S * a + L * c + U * (5 * d) + _ * (5 * p) + j * (5 * E);\n    x = P >>> 13, P &= 8191, P += g * (5 * y) + w * (5 * h) + b * (5 * f) + I * (5 * l) + R * (5 * u), x += P >>> 13, P &= 8191;\n    let k = x + S * u + L * a + U * c + _ * (5 * d) + j * (5 * p);\n    x = k >>> 13, k &= 8191, k += g * (5 * E) + w * (5 * y) + b * (5 * h) + I * (5 * f) + R * (5 * l), x += k >>> 13, k &= 8191;\n    let M = x + S * l + L * u + U * a + _ * c + j * (5 * d);\n    x = M >>> 13, M &= 8191, M += g * (5 * p) + w * (5 * E) + b * (5 * y) + I * (5 * h) + R * (5 * f), x += M >>> 13, M &= 8191;\n    let D = x + S * f + L * l + U * u + _ * a + j * c;\n    x = D >>> 13, D &= 8191, D += g * (5 * d) + w * (5 * p) + b * (5 * E) + I * (5 * y) + R * (5 * h), x += D >>> 13, D &= 8191;\n    let z = x + S * h + L * f + U * l + _ * u + j * a;\n    x = z >>> 13, z &= 8191, z += g * c + w * (5 * d) + b * (5 * p) + I * (5 * E) + R * (5 * y), x += z >>> 13, z &= 8191;\n    let Z = x + S * y + L * h + U * f + _ * l + j * u;\n    x = Z >>> 13, Z &= 8191, Z += g * a + w * c + b * (5 * d) + I * (5 * p) + R * (5 * E), x += Z >>> 13, Z &= 8191;\n    let it = x + S * E + L * y + U * h + _ * f + j * l;\n    x = it >>> 13, it &= 8191, it += g * u + w * a + b * c + I * (5 * d) + R * (5 * p), x += it >>> 13, it &= 8191;\n    let W = x + S * p + L * E + U * y + _ * h + j * f;\n    x = W >>> 13, W &= 8191, W += g * l + w * u + b * a + I * c + R * (5 * d), x += W >>> 13, W &= 8191;\n    let J = x + S * d + L * p + U * E + _ * y + j * h;\n    x = J >>> 13, J &= 8191, J += g * f + w * l + b * u + I * a + R * c, x += J >>> 13, J &= 8191, x = (x << 2) + x | 0, x = x + C | 0, C = x & 8191, x = x >>> 13, P += x, i[0] = C, i[1] = P, i[2] = k, i[3] = M, i[4] = D, i[5] = z, i[6] = Z, i[7] = it, i[8] = W, i[9] = J;\n  }\n  finalize() {\n    const {\n        h: e,\n        pad: n\n      } = this,\n      r = new Uint16Array(10);\n    let o = e[1] >>> 13;\n    e[1] &= 8191;\n    for (let c = 2; c < 10; c++) e[c] += o, o = e[c] >>> 13, e[c] &= 8191;\n    e[0] += o * 5, o = e[0] >>> 13, e[0] &= 8191, e[1] += o, o = e[1] >>> 13, e[1] &= 8191, e[2] += o, r[0] = e[0] + 5, o = r[0] >>> 13, r[0] &= 8191;\n    for (let c = 1; c < 10; c++) r[c] = e[c] + o, o = r[c] >>> 13, r[c] &= 8191;\n    r[9] -= 8192;\n    let i = (o ^ 1) - 1;\n    for (let c = 0; c < 10; c++) r[c] &= i;\n    i = ~i;\n    for (let c = 0; c < 10; c++) e[c] = e[c] & i | r[c];\n    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;\n    let s = e[0] + n[0];\n    e[0] = s & 65535;\n    for (let c = 1; c < 8; c++) s = (e[c] + n[c] | 0) + (s >>> 16) | 0, e[c] = s & 65535;\n    Lt(r);\n  }\n  update(e) {\n    Or(this);\n    const {\n      buffer: n,\n      blockLen: r\n    } = this;\n    e = Fe(e);\n    const o = e.length;\n    for (let i = 0; i < o;) {\n      const s = Math.min(r - this.pos, o - i);\n      if (s === r) {\n        for (; r <= o - i; i += r) this.process(e, i);\n        continue;\n      }\n      n.set(e.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === r && (this.process(n, 0, !1), this.pos = 0);\n    }\n    return this;\n  }\n  destroy() {\n    Lt(this.h, this.r, this.buffer, this.pad);\n  }\n  digestInto(e) {\n    Or(this), ps(e, this), this.finished = !0;\n    const {\n      buffer: n,\n      h: r\n    } = this;\n    let {\n      pos: o\n    } = this;\n    if (o) {\n      for (n[o++] = 1; o < 16; o++) n[o] = 0;\n      this.process(n, 0, !0);\n    }\n    this.finalize();\n    let i = 0;\n    for (let s = 0; s < 8; s++) e[i++] = r[s] >>> 0, e[i++] = r[s] >>> 8;\n    return e;\n  }\n  digest() {\n    const {\n      buffer: e,\n      outputLen: n\n    } = this;\n    this.digestInto(e);\n    const r = e.slice(0, n);\n    return this.destroy(), r;\n  }\n}\nfunction Ts(t) {\n  const e = (r, o) => t(o).update(Fe(r)).digest(),\n    n = t(new Uint8Array(32));\n  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = r => t(r), e;\n}\nconst Rs = Ts(t => new Us(t));\nfunction _s(t, e, n, r, o, i = 20) {\n  let s = t[0],\n    c = t[1],\n    a = t[2],\n    u = t[3],\n    l = e[0],\n    f = e[1],\n    h = e[2],\n    y = e[3],\n    E = e[4],\n    p = e[5],\n    d = e[6],\n    v = e[7],\n    m = o,\n    O = n[0],\n    N = n[1],\n    $ = n[2],\n    B = s,\n    A = c,\n    T = a,\n    S = u,\n    L = l,\n    U = f,\n    _ = h,\n    j = y,\n    g = E,\n    w = p,\n    b = d,\n    I = v,\n    R = m,\n    x = O,\n    C = N,\n    P = $;\n  for (let M = 0; M < i; M += 2) B = B + L | 0, R = V(R ^ B, 16), g = g + R | 0, L = V(L ^ g, 12), B = B + L | 0, R = V(R ^ B, 8), g = g + R | 0, L = V(L ^ g, 7), A = A + U | 0, x = V(x ^ A, 16), w = w + x | 0, U = V(U ^ w, 12), A = A + U | 0, x = V(x ^ A, 8), w = w + x | 0, U = V(U ^ w, 7), T = T + _ | 0, C = V(C ^ T, 16), b = b + C | 0, _ = V(_ ^ b, 12), T = T + _ | 0, C = V(C ^ T, 8), b = b + C | 0, _ = V(_ ^ b, 7), S = S + j | 0, P = V(P ^ S, 16), I = I + P | 0, j = V(j ^ I, 12), S = S + j | 0, P = V(P ^ S, 8), I = I + P | 0, j = V(j ^ I, 7), B = B + U | 0, P = V(P ^ B, 16), b = b + P | 0, U = V(U ^ b, 12), B = B + U | 0, P = V(P ^ B, 8), b = b + P | 0, U = V(U ^ b, 7), A = A + _ | 0, R = V(R ^ A, 16), I = I + R | 0, _ = V(_ ^ I, 12), A = A + _ | 0, R = V(R ^ A, 8), I = I + R | 0, _ = V(_ ^ I, 7), T = T + j | 0, x = V(x ^ T, 16), g = g + x | 0, j = V(j ^ g, 12), T = T + j | 0, x = V(x ^ T, 8), g = g + x | 0, j = V(j ^ g, 7), S = S + L | 0, C = V(C ^ S, 16), w = w + C | 0, L = V(L ^ w, 12), S = S + L | 0, C = V(C ^ S, 8), w = w + C | 0, L = V(L ^ w, 7);\n  let k = 0;\n  r[k++] = s + B | 0, r[k++] = c + A | 0, r[k++] = a + T | 0, r[k++] = u + S | 0, r[k++] = l + L | 0, r[k++] = f + U | 0, r[k++] = h + _ | 0, r[k++] = y + j | 0, r[k++] = E + g | 0, r[k++] = p + w | 0, r[k++] = d + b | 0, r[k++] = v + I | 0, r[k++] = m + R | 0, r[k++] = O + x | 0, r[k++] = N + C | 0, r[k++] = $ + P | 0;\n}\nconst $s = Ns(_s, {\n    counterRight: !1,\n    counterLength: 4,\n    allowShortKeys: !1\n  }),\n  Ls = new Uint8Array(16),\n  Rr = (t, e) => {\n    t.update(e);\n    const n = e.length % 16;\n    n && t.update(Ls.subarray(n));\n  },\n  js = new Uint8Array(32);\nfunction _r(t, e, n, r, o) {\n  const i = t(e, n, js),\n    s = Rs.create(i);\n  o && Rr(s, o), Rr(s, r);\n  const c = new Uint8Array(16),\n    a = gs(c);\n  Ir(a, 0, BigInt(o ? o.length : 0), !0), Ir(a, 8, BigInt(r.length), !0), s.update(c);\n  const u = s.digest();\n  return Lt(i, c), u;\n}\nconst Cs = t => (e, n, r) => ({\n    encrypt(i, s) {\n      const c = i.length;\n      s = Br(c + 16, s, !1), s.set(i);\n      const a = s.subarray(0, -16);\n      t(e, n, a, a, 1);\n      const u = _r(t, e, n, a, r);\n      return s.set(u, c), Lt(u), s;\n    },\n    decrypt(i, s) {\n      s = Br(i.length - 16, s, !1);\n      const c = i.subarray(0, -16),\n        a = i.subarray(-16),\n        u = _r(t, e, n, c, r);\n      if (!bs(a, u)) throw new Error(\"invalid tag\");\n      return s.set(i.subarray(0, -16)), t(e, n, s, s, 1), Lt(u), s;\n    }\n  }),\n  $r = Es({\n    blockSize: 64,\n    nonceLength: 12,\n    tagLength: 16\n  }, Cs($s));\nclass Lr extends Pe {\n  constructor(e, n) {\n    super(), this.finished = !1, this.destroyed = !1, je(e);\n    const r = _t(n);\n    if (this.iHash = e.create(), typeof this.iHash.update != \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n    const o = this.blockLen,\n      i = new Uint8Array(o);\n    i.set(r.length > o ? e.create().update(r).digest() : r);\n    for (let s = 0; s < i.length; s++) i[s] ^= 54;\n    this.iHash.update(i), this.oHash = e.create();\n    for (let s = 0; s < i.length; s++) i[s] ^= 106;\n    this.oHash.update(i), i.fill(0);\n  }\n  update(e) {\n    return Tt(this), this.iHash.update(e), this;\n  }\n  digestInto(e) {\n    Tt(this), Wt(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();\n  }\n  digest() {\n    const e = new Uint8Array(this.oHash.outputLen);\n    return this.digestInto(e), e;\n  }\n  _cloneInto(e) {\n    e || (e = Object.create(Object.getPrototypeOf(this), {}));\n    const {\n      oHash: n,\n      iHash: r,\n      finished: o,\n      destroyed: i,\n      blockLen: s,\n      outputLen: c\n    } = this;\n    return e = e, e.finished = o, e.destroyed = i, e.blockLen = s, e.outputLen = c, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;\n  }\n  destroy() {\n    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n  }\n}\nconst pe = (t, e, n) => new Lr(t, e).update(n).digest();\npe.create = (t, e) => new Lr(t, e);\nfunction Ps(t, e, n) {\n  return je(t), n === void 0 && (n = new Uint8Array(t.outputLen)), pe(t, _t(n), _t(e));\n}\nconst Ye = new Uint8Array([0]),\n  jr = new Uint8Array();\nfunction ks(t, e, n, r = 32) {\n  if (je(t), Gt(r), r > 255 * t.outputLen) throw new Error(\"Length should be <= 255*HashLen\");\n  const o = Math.ceil(r / t.outputLen);\n  n === void 0 && (n = jr);\n  const i = new Uint8Array(o * t.outputLen),\n    s = pe.create(t, e),\n    c = s._cloneInto(),\n    a = new Uint8Array(s.outputLen);\n  for (let u = 0; u < o; u++) Ye[0] = u + 1, c.update(u === 0 ? jr : a).update(n).update(Ye).digestInto(a), i.set(a, t.outputLen * u), s._cloneInto(c);\n  return s.destroy(), c.destroy(), a.fill(0), Ye.fill(0), i.slice(0, r);\n}\nconst Vs = (t, e, n, r, o) => ks(t, Ps(t, e, n), r, o);\nfunction Ms(t, e, n, r) {\n  if (typeof t.setBigUint64 == \"function\") return t.setBigUint64(e, n, r);\n  const o = BigInt(32),\n    i = BigInt(4294967295),\n    s = Number(n >> o & i),\n    c = Number(n & i),\n    a = r ? 4 : 0,\n    u = r ? 0 : 4;\n  t.setUint32(e + a, s, r), t.setUint32(e + u, c, r);\n}\nfunction Ds(t, e, n) {\n  return t & e ^ ~t & n;\n}\nfunction Hs(t, e, n) {\n  return t & e ^ t & n ^ e & n;\n}\nclass qs extends Pe {\n  constructor(e, n, r, o) {\n    super(), this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Ce(this.buffer);\n  }\n  update(e) {\n    Tt(this);\n    const {\n      view: n,\n      buffer: r,\n      blockLen: o\n    } = this;\n    e = _t(e);\n    const i = e.length;\n    for (let s = 0; s < i;) {\n      const c = Math.min(o - this.pos, i - s);\n      if (c === o) {\n        const a = Ce(e);\n        for (; o <= i - s; s += o) this.process(a, s);\n        continue;\n      }\n      r.set(e.subarray(s, s + c), this.pos), this.pos += c, s += c, this.pos === o && (this.process(n, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    Tt(this), Gn(e, this), this.finished = !0;\n    const {\n      buffer: n,\n      view: r,\n      blockLen: o,\n      isLE: i\n    } = this;\n    let {\n      pos: s\n    } = this;\n    n[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o - s && (this.process(r, 0), s = 0);\n    for (let f = s; f < o; f++) n[f] = 0;\n    Ms(r, o - 8, BigInt(this.length * 8), i), this.process(r, 0);\n    const c = Ce(e),\n      a = this.outputLen;\n    if (a % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const u = a / 4,\n      l = this.get();\n    if (u > l.length) throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let f = 0; f < u; f++) c.setUint32(4 * f, l[f], i);\n  }\n  digest() {\n    const {\n      buffer: e,\n      outputLen: n\n    } = this;\n    this.digestInto(e);\n    const r = e.slice(0, n);\n    return this.destroy(), r;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const {\n      blockLen: n,\n      buffer: r,\n      length: o,\n      finished: i,\n      destroyed: s,\n      pos: c\n    } = this;\n    return e.length = o, e.pos = c, e.finished = i, e.destroyed = s, o % n && e.buffer.set(r), e;\n  }\n}\nconst Ks = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),\n  wt = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),\n  bt = new Uint32Array(64);\nclass Fs extends qs {\n  constructor() {\n    super(64, 32, 8, !1), this.A = wt[0] | 0, this.B = wt[1] | 0, this.C = wt[2] | 0, this.D = wt[3] | 0, this.E = wt[4] | 0, this.F = wt[5] | 0, this.G = wt[6] | 0, this.H = wt[7] | 0;\n  }\n  get() {\n    const {\n      A: e,\n      B: n,\n      C: r,\n      D: o,\n      E: i,\n      F: s,\n      G: c,\n      H: a\n    } = this;\n    return [e, n, r, o, i, s, c, a];\n  }\n  set(e, n, r, o, i, s, c, a) {\n    this.A = e | 0, this.B = n | 0, this.C = r | 0, this.D = o | 0, this.E = i | 0, this.F = s | 0, this.G = c | 0, this.H = a | 0;\n  }\n  process(e, n) {\n    for (let f = 0; f < 16; f++, n += 4) bt[f] = e.getUint32(n, !1);\n    for (let f = 16; f < 64; f++) {\n      const h = bt[f - 15],\n        y = bt[f - 2],\n        E = st(h, 7) ^ st(h, 18) ^ h >>> 3,\n        p = st(y, 17) ^ st(y, 19) ^ y >>> 10;\n      bt[f] = p + bt[f - 7] + E + bt[f - 16] | 0;\n    }\n    let {\n      A: r,\n      B: o,\n      C: i,\n      D: s,\n      E: c,\n      F: a,\n      G: u,\n      H: l\n    } = this;\n    for (let f = 0; f < 64; f++) {\n      const h = st(c, 6) ^ st(c, 11) ^ st(c, 25),\n        y = l + h + Ds(c, a, u) + Ks[f] + bt[f] | 0,\n        p = (st(r, 2) ^ st(r, 13) ^ st(r, 22)) + Hs(r, o, i) | 0;\n      l = u, u = a, a = c, c = s + y | 0, s = i, i = o, o = r, r = y + p | 0;\n    }\n    r = r + this.A | 0, o = o + this.B | 0, i = i + this.C | 0, s = s + this.D | 0, c = c + this.E | 0, a = a + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, o, i, s, c, a, u, l);\n  }\n  roundClean() {\n    bt.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n  }\n}\nconst Jt = Qn(() => new Fs()); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst ge = BigInt(0),\n  ye = BigInt(1),\n  zs = BigInt(2);\nfunction St(t) {\n  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === \"Uint8Array\";\n}\nfunction Qt(t) {\n  if (!St(t)) throw new Error(\"Uint8Array expected\");\n}\nfunction jt(t, e) {\n  if (typeof e != \"boolean\") throw new Error(t + \" boolean expected, got \" + e);\n}\nconst Zs = Array.from({\n  length: 256\n}, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction Ct(t) {\n  Qt(t);\n  let e = \"\";\n  for (let n = 0; n < t.length; n++) e += Zs[t[n]];\n  return e;\n}\nfunction Pt(t) {\n  const e = t.toString(16);\n  return e.length & 1 ? \"0\" + e : e;\n}\nfunction Ge(t) {\n  if (typeof t != \"string\") throw new Error(\"hex string expected, got \" + typeof t);\n  return t === \"\" ? ge : BigInt(\"0x\" + t);\n}\nconst ut = {\n  _0: 48,\n  _9: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102\n};\nfunction Cr(t) {\n  if (t >= ut._0 && t <= ut._9) return t - ut._0;\n  if (t >= ut.A && t <= ut.F) return t - (ut.A - 10);\n  if (t >= ut.a && t <= ut.f) return t - (ut.a - 10);\n}\nfunction kt(t) {\n  if (typeof t != \"string\") throw new Error(\"hex string expected, got \" + typeof t);\n  const e = t.length,\n    n = e / 2;\n  if (e % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + e);\n  const r = new Uint8Array(n);\n  for (let o = 0, i = 0; o < n; o++, i += 2) {\n    const s = Cr(t.charCodeAt(i)),\n      c = Cr(t.charCodeAt(i + 1));\n    if (s === void 0 || c === void 0) {\n      const a = t[i] + t[i + 1];\n      throw new Error('hex string expected, got non-hex character \"' + a + '\" at index ' + i);\n    }\n    r[o] = s * 16 + c;\n  }\n  return r;\n}\nfunction Ot(t) {\n  return Ge(Ct(t));\n}\nfunction te(t) {\n  return Qt(t), Ge(Ct(Uint8Array.from(t).reverse()));\n}\nfunction Vt(t, e) {\n  return kt(t.toString(16).padStart(e * 2, \"0\"));\n}\nfunction me(t, e) {\n  return Vt(t, e).reverse();\n}\nfunction Ys(t) {\n  return kt(Pt(t));\n}\nfunction et(t, e, n) {\n  let r;\n  if (typeof e == \"string\") try {\n    r = kt(e);\n  } catch (i) {\n    throw new Error(t + \" must be hex string or Uint8Array, cause: \" + i);\n  } else if (St(e)) r = Uint8Array.from(e);else throw new Error(t + \" must be hex string or Uint8Array\");\n  const o = r.length;\n  if (typeof n == \"number\" && o !== n) throw new Error(t + \" of length \" + n + \" expected, got \" + o);\n  return r;\n}\nfunction ee(...t) {\n  let e = 0;\n  for (let r = 0; r < t.length; r++) {\n    const o = t[r];\n    Qt(o), e += o.length;\n  }\n  const n = new Uint8Array(e);\n  for (let r = 0, o = 0; r < t.length; r++) {\n    const i = t[r];\n    n.set(i, o), o += i.length;\n  }\n  return n;\n}\nfunction Gs(t, e) {\n  if (t.length !== e.length) return !1;\n  let n = 0;\n  for (let r = 0; r < t.length; r++) n |= t[r] ^ e[r];\n  return n === 0;\n}\nfunction Ws(t) {\n  if (typeof t != \"string\") throw new Error(\"string expected\");\n  return new Uint8Array(new TextEncoder().encode(t));\n}\nconst We = t => typeof t == \"bigint\" && ge <= t;\nfunction we(t, e, n) {\n  return We(t) && We(e) && We(n) && e <= t && t < n;\n}\nfunction ft(t, e, n, r) {\n  if (!we(e, n, r)) throw new Error(\"expected valid \" + t + \": \" + n + \" <= n < \" + r + \", got \" + e);\n}\nfunction Pr(t) {\n  let e;\n  for (e = 0; t > ge; t >>= ye, e += 1);\n  return e;\n}\nfunction Xs(t, e) {\n  return t >> BigInt(e) & ye;\n}\nfunction Js(t, e, n) {\n  return t | (n ? ye : ge) << BigInt(e);\n}\nconst Xe = t => (zs << BigInt(t - 1)) - ye,\n  Je = t => new Uint8Array(t),\n  kr = t => Uint8Array.from(t);\nfunction Vr(t, e, n) {\n  if (typeof t != \"number\" || t < 2) throw new Error(\"hashLen must be a number\");\n  if (typeof e != \"number\" || e < 2) throw new Error(\"qByteLen must be a number\");\n  if (typeof n != \"function\") throw new Error(\"hmacFn must be a function\");\n  let r = Je(t),\n    o = Je(t),\n    i = 0;\n  const s = () => {\n      r.fill(1), o.fill(0), i = 0;\n    },\n    c = (...f) => n(o, r, ...f),\n    a = (f = Je()) => {\n      o = c(kr([0]), f), r = c(), f.length !== 0 && (o = c(kr([1]), f), r = c());\n    },\n    u = () => {\n      if (i++ >= 1e3) throw new Error(\"drbg: tried 1000 values\");\n      let f = 0;\n      const h = [];\n      for (; f < e;) {\n        r = c();\n        const y = r.slice();\n        h.push(y), f += r.length;\n      }\n      return ee(...h);\n    };\n  return (f, h) => {\n    s(), a(f);\n    let y;\n    for (; !(y = h(u()));) a();\n    return s(), y;\n  };\n}\nconst Qs = {\n  bigint: t => typeof t == \"bigint\",\n  function: t => typeof t == \"function\",\n  boolean: t => typeof t == \"boolean\",\n  string: t => typeof t == \"string\",\n  stringOrUint8Array: t => typeof t == \"string\" || St(t),\n  isSafeInteger: t => Number.isSafeInteger(t),\n  array: t => Array.isArray(t),\n  field: (t, e) => e.Fp.isValid(t),\n  hash: t => typeof t == \"function\" && Number.isSafeInteger(t.outputLen)\n};\nfunction Mt(t, e, n = {}) {\n  const r = (o, i, s) => {\n    const c = Qs[i];\n    if (typeof c != \"function\") throw new Error(\"invalid validator function\");\n    const a = t[o];\n    if (!(s && a === void 0) && !c(a, t)) throw new Error(\"param \" + String(o) + \" is invalid. Expected \" + i + \", got \" + a);\n  };\n  for (const [o, i] of Object.entries(e)) r(o, i, !1);\n  for (const [o, i] of Object.entries(n)) r(o, i, !0);\n  return t;\n}\nconst tc = () => {\n  throw new Error(\"not implemented\");\n};\nfunction Qe(t) {\n  const e = new WeakMap();\n  return (n, ...r) => {\n    const o = e.get(n);\n    if (o !== void 0) return o;\n    const i = t(n, ...r);\n    return e.set(n, i), i;\n  };\n}\nvar ec = Object.freeze({\n  __proto__: null,\n  isBytes: St,\n  abytes: Qt,\n  abool: jt,\n  bytesToHex: Ct,\n  numberToHexUnpadded: Pt,\n  hexToNumber: Ge,\n  hexToBytes: kt,\n  bytesToNumberBE: Ot,\n  bytesToNumberLE: te,\n  numberToBytesBE: Vt,\n  numberToBytesLE: me,\n  numberToVarBytesBE: Ys,\n  ensureBytes: et,\n  concatBytes: ee,\n  equalBytes: Gs,\n  utf8ToBytes: Ws,\n  inRange: we,\n  aInRange: ft,\n  bitLen: Pr,\n  bitGet: Xs,\n  bitSet: Js,\n  bitMask: Xe,\n  createHmacDrbg: Vr,\n  validateObject: Mt,\n  notImplemented: tc,\n  memoized: Qe\n});\nconst q = BigInt(0),\n  H = BigInt(1),\n  At = BigInt(2),\n  nc = BigInt(3),\n  tn = BigInt(4),\n  Mr = BigInt(5),\n  Dr = BigInt(8);\nfunction X(t, e) {\n  const n = t % e;\n  return n >= q ? n : e + n;\n}\nfunction Hr(t, e, n) {\n  if (e < q) throw new Error(\"invalid exponent, negatives unsupported\");\n  if (n <= q) throw new Error(\"invalid modulus\");\n  if (n === H) return q;\n  let r = H;\n  for (; e > q;) e & H && (r = r * t % n), t = t * t % n, e >>= H;\n  return r;\n}\nfunction ot(t, e, n) {\n  let r = t;\n  for (; e-- > q;) r *= r, r %= n;\n  return r;\n}\nfunction en(t, e) {\n  if (t === q) throw new Error(\"invert: expected non-zero number\");\n  if (e <= q) throw new Error(\"invert: expected positive modulus, got \" + e);\n  let n = X(t, e),\n    r = e,\n    o = q,\n    i = H;\n  for (; n !== q;) {\n    const c = r / n,\n      a = r % n,\n      u = o - i * c;\n    r = n, n = a, o = i, i = u;\n  }\n  if (r !== H) throw new Error(\"invert: does not exist\");\n  return X(o, e);\n}\nfunction rc(t) {\n  const e = (t - H) / At;\n  let n, r, o;\n  for (n = t - H, r = 0; n % At === q; n /= At, r++);\n  for (o = At; o < t && Hr(o, e, t) !== t - H; o++) if (o > 1e3) throw new Error(\"Cannot find square root: likely non-prime P\");\n  if (r === 1) {\n    const s = (t + H) / tn;\n    return function (a, u) {\n      const l = a.pow(u, s);\n      if (!a.eql(a.sqr(l), u)) throw new Error(\"Cannot find square root\");\n      return l;\n    };\n  }\n  const i = (n + H) / At;\n  return function (c, a) {\n    if (c.pow(a, e) === c.neg(c.ONE)) throw new Error(\"Cannot find square root\");\n    let u = r,\n      l = c.pow(c.mul(c.ONE, o), n),\n      f = c.pow(a, i),\n      h = c.pow(a, n);\n    for (; !c.eql(h, c.ONE);) {\n      if (c.eql(h, c.ZERO)) return c.ZERO;\n      let y = 1;\n      for (let p = c.sqr(h); y < u && !c.eql(p, c.ONE); y++) p = c.sqr(p);\n      const E = c.pow(l, H << BigInt(u - y - 1));\n      l = c.sqr(E), f = c.mul(f, E), h = c.mul(h, l), u = y;\n    }\n    return f;\n  };\n}\nfunction oc(t) {\n  if (t % tn === nc) {\n    const e = (t + H) / tn;\n    return function (r, o) {\n      const i = r.pow(o, e);\n      if (!r.eql(r.sqr(i), o)) throw new Error(\"Cannot find square root\");\n      return i;\n    };\n  }\n  if (t % Dr === Mr) {\n    const e = (t - Mr) / Dr;\n    return function (r, o) {\n      const i = r.mul(o, At),\n        s = r.pow(i, e),\n        c = r.mul(o, s),\n        a = r.mul(r.mul(c, At), s),\n        u = r.mul(c, r.sub(a, r.ONE));\n      if (!r.eql(r.sqr(u), o)) throw new Error(\"Cannot find square root\");\n      return u;\n    };\n  }\n  return rc(t);\n}\nconst ic = [\"create\", \"isValid\", \"is0\", \"neg\", \"inv\", \"sqrt\", \"sqr\", \"eql\", \"add\", \"sub\", \"mul\", \"pow\", \"div\", \"addN\", \"subN\", \"mulN\", \"sqrN\"];\nfunction sc(t) {\n  const e = {\n      ORDER: \"bigint\",\n      MASK: \"bigint\",\n      BYTES: \"isSafeInteger\",\n      BITS: \"isSafeInteger\"\n    },\n    n = ic.reduce((r, o) => (r[o] = \"function\", r), e);\n  return Mt(t, n);\n}\nfunction cc(t, e, n) {\n  if (n < q) throw new Error(\"invalid exponent, negatives unsupported\");\n  if (n === q) return t.ONE;\n  if (n === H) return e;\n  let r = t.ONE,\n    o = e;\n  for (; n > q;) n & H && (r = t.mul(r, o)), o = t.sqr(o), n >>= H;\n  return r;\n}\nfunction ac(t, e) {\n  const n = new Array(e.length),\n    r = e.reduce((i, s, c) => t.is0(s) ? i : (n[c] = i, t.mul(i, s)), t.ONE),\n    o = t.inv(r);\n  return e.reduceRight((i, s, c) => t.is0(s) ? i : (n[c] = t.mul(i, n[c]), t.mul(i, s)), o), n;\n}\nfunction qr(t, e) {\n  const n = e !== void 0 ? e : t.toString(2).length,\n    r = Math.ceil(n / 8);\n  return {\n    nBitLength: n,\n    nByteLength: r\n  };\n}\nfunction Kr(t, e, n = !1, r = {}) {\n  if (t <= q) throw new Error(\"invalid field: expected ORDER > 0, got \" + t);\n  const {\n    nBitLength: o,\n    nByteLength: i\n  } = qr(t, e);\n  if (i > 2048) throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n  let s;\n  const c = Object.freeze({\n    ORDER: t,\n    isLE: n,\n    BITS: o,\n    BYTES: i,\n    MASK: Xe(o),\n    ZERO: q,\n    ONE: H,\n    create: a => X(a, t),\n    isValid: a => {\n      if (typeof a != \"bigint\") throw new Error(\"invalid field element: expected bigint, got \" + typeof a);\n      return q <= a && a < t;\n    },\n    is0: a => a === q,\n    isOdd: a => (a & H) === H,\n    neg: a => X(-a, t),\n    eql: (a, u) => a === u,\n    sqr: a => X(a * a, t),\n    add: (a, u) => X(a + u, t),\n    sub: (a, u) => X(a - u, t),\n    mul: (a, u) => X(a * u, t),\n    pow: (a, u) => cc(c, a, u),\n    div: (a, u) => X(a * en(u, t), t),\n    sqrN: a => a * a,\n    addN: (a, u) => a + u,\n    subN: (a, u) => a - u,\n    mulN: (a, u) => a * u,\n    inv: a => en(a, t),\n    sqrt: r.sqrt || (a => (s || (s = oc(t)), s(c, a))),\n    invertBatch: a => ac(c, a),\n    cmov: (a, u, l) => l ? u : a,\n    toBytes: a => n ? me(a, i) : Vt(a, i),\n    fromBytes: a => {\n      if (a.length !== i) throw new Error(\"Field.fromBytes: expected \" + i + \" bytes, got \" + a.length);\n      return n ? te(a) : Ot(a);\n    }\n  });\n  return Object.freeze(c);\n}\nfunction Fr(t) {\n  if (typeof t != \"bigint\") throw new Error(\"field order must be bigint\");\n  const e = t.toString(2).length;\n  return Math.ceil(e / 8);\n}\nfunction zr(t) {\n  const e = Fr(t);\n  return e + Math.ceil(e / 2);\n}\nfunction uc(t, e, n = !1) {\n  const r = t.length,\n    o = Fr(e),\n    i = zr(e);\n  if (r < 16 || r < i || r > 1024) throw new Error(\"expected \" + i + \"-1024 bytes of input, got \" + r);\n  const s = n ? te(t) : Ot(t),\n    c = X(s, e - H) + H;\n  return n ? me(c, o) : Vt(c, o);\n}\nconst Zr = BigInt(0),\n  be = BigInt(1);\nfunction nn(t, e) {\n  const n = e.negate();\n  return t ? n : e;\n}\nfunction Yr(t, e) {\n  if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error(\"invalid window size, expected [1..\" + e + \"], got W=\" + t);\n}\nfunction rn(t, e) {\n  Yr(t, e);\n  const n = Math.ceil(e / t) + 1,\n    r = 2 ** (t - 1);\n  return {\n    windows: n,\n    windowSize: r\n  };\n}\nfunction fc(t, e) {\n  if (!Array.isArray(t)) throw new Error(\"array expected\");\n  t.forEach((n, r) => {\n    if (!(n instanceof e)) throw new Error(\"invalid point at index \" + r);\n  });\n}\nfunction lc(t, e) {\n  if (!Array.isArray(t)) throw new Error(\"array of scalars expected\");\n  t.forEach((n, r) => {\n    if (!e.isValid(n)) throw new Error(\"invalid scalar at index \" + r);\n  });\n}\nconst on = new WeakMap(),\n  Gr = new WeakMap();\nfunction sn(t) {\n  return Gr.get(t) || 1;\n}\nfunction dc(t, e) {\n  return {\n    constTimeNegate: nn,\n    hasPrecomputes(n) {\n      return sn(n) !== 1;\n    },\n    unsafeLadder(n, r, o = t.ZERO) {\n      let i = n;\n      for (; r > Zr;) r & be && (o = o.add(i)), i = i.double(), r >>= be;\n      return o;\n    },\n    precomputeWindow(n, r) {\n      const {\n          windows: o,\n          windowSize: i\n        } = rn(r, e),\n        s = [];\n      let c = n,\n        a = c;\n      for (let u = 0; u < o; u++) {\n        a = c, s.push(a);\n        for (let l = 1; l < i; l++) a = a.add(c), s.push(a);\n        c = a.double();\n      }\n      return s;\n    },\n    wNAF(n, r, o) {\n      const {\n        windows: i,\n        windowSize: s\n      } = rn(n, e);\n      let c = t.ZERO,\n        a = t.BASE;\n      const u = BigInt(2 ** n - 1),\n        l = 2 ** n,\n        f = BigInt(n);\n      for (let h = 0; h < i; h++) {\n        const y = h * s;\n        let E = Number(o & u);\n        o >>= f, E > s && (E -= l, o += be);\n        const p = y,\n          d = y + Math.abs(E) - 1,\n          v = h % 2 !== 0,\n          m = E < 0;\n        E === 0 ? a = a.add(nn(v, r[p])) : c = c.add(nn(m, r[d]));\n      }\n      return {\n        p: c,\n        f: a\n      };\n    },\n    wNAFUnsafe(n, r, o, i = t.ZERO) {\n      const {\n          windows: s,\n          windowSize: c\n        } = rn(n, e),\n        a = BigInt(2 ** n - 1),\n        u = 2 ** n,\n        l = BigInt(n);\n      for (let f = 0; f < s; f++) {\n        const h = f * c;\n        if (o === Zr) break;\n        let y = Number(o & a);\n        if (o >>= l, y > c && (y -= u, o += be), y === 0) continue;\n        let E = r[h + Math.abs(y) - 1];\n        y < 0 && (E = E.negate()), i = i.add(E);\n      }\n      return i;\n    },\n    getPrecomputes(n, r, o) {\n      let i = on.get(r);\n      return i || (i = this.precomputeWindow(r, n), n !== 1 && on.set(r, o(i))), i;\n    },\n    wNAFCached(n, r, o) {\n      const i = sn(n);\n      return this.wNAF(i, this.getPrecomputes(i, n, o), r);\n    },\n    wNAFCachedUnsafe(n, r, o, i) {\n      const s = sn(n);\n      return s === 1 ? this.unsafeLadder(n, r, i) : this.wNAFUnsafe(s, this.getPrecomputes(s, n, o), r, i);\n    },\n    setWindowSize(n, r) {\n      Yr(r, e), Gr.set(n, r), on.delete(n);\n    }\n  };\n}\nfunction hc(t, e, n, r) {\n  if (fc(n, t), lc(r, e), n.length !== r.length) throw new Error(\"arrays of points and scalars must have equal length\");\n  const o = t.ZERO,\n    i = Pr(BigInt(n.length)),\n    s = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1,\n    c = (1 << s) - 1,\n    a = new Array(c + 1).fill(o),\n    u = Math.floor((e.BITS - 1) / s) * s;\n  let l = o;\n  for (let f = u; f >= 0; f -= s) {\n    a.fill(o);\n    for (let y = 0; y < r.length; y++) {\n      const E = r[y],\n        p = Number(E >> BigInt(f) & BigInt(c));\n      a[p] = a[p].add(n[y]);\n    }\n    let h = o;\n    for (let y = a.length - 1, E = o; y > 0; y--) E = E.add(a[y]), h = h.add(E);\n    if (l = l.add(h), f !== 0) for (let y = 0; y < s; y++) l = l.double();\n  }\n  return l;\n}\nfunction Wr(t) {\n  return sc(t.Fp), Mt(t, {\n    n: \"bigint\",\n    h: \"bigint\",\n    Gx: \"field\",\n    Gy: \"field\"\n  }, {\n    nBitLength: \"isSafeInteger\",\n    nByteLength: \"isSafeInteger\"\n  }), Object.freeze({\n    ...qr(t.n, t.nBitLength),\n    ...t,\n    p: t.Fp.ORDER\n  });\n}\nBigInt(0), BigInt(1), BigInt(2), BigInt(8);\nconst Dt = BigInt(0),\n  cn = BigInt(1);\nfunction pc(t) {\n  return Mt(t, {\n    a: \"bigint\"\n  }, {\n    montgomeryBits: \"isSafeInteger\",\n    nByteLength: \"isSafeInteger\",\n    adjustScalarBytes: \"function\",\n    domain: \"function\",\n    powPminus2: \"function\",\n    Gu: \"bigint\"\n  }), Object.freeze({\n    ...t\n  });\n}\nfunction gc(t) {\n  const e = pc(t),\n    {\n      P: n\n    } = e,\n    r = m => X(m, n),\n    o = e.montgomeryBits,\n    i = Math.ceil(o / 8),\n    s = e.nByteLength,\n    c = e.adjustScalarBytes || (m => m),\n    a = e.powPminus2 || (m => Hr(m, n - BigInt(2), n));\n  function u(m, O, N) {\n    const $ = r(m * (O - N));\n    return O = r(O - $), N = r(N + $), [O, N];\n  }\n  const l = (e.a - BigInt(2)) / BigInt(4);\n  function f(m, O) {\n    ft(\"u\", m, Dt, n), ft(\"scalar\", O, Dt, n);\n    const N = O,\n      $ = m;\n    let B = cn,\n      A = Dt,\n      T = m,\n      S = cn,\n      L = Dt,\n      U;\n    for (let j = BigInt(o - 1); j >= Dt; j--) {\n      const g = N >> j & cn;\n      L ^= g, U = u(L, B, T), B = U[0], T = U[1], U = u(L, A, S), A = U[0], S = U[1], L = g;\n      const w = B + A,\n        b = r(w * w),\n        I = B - A,\n        R = r(I * I),\n        x = b - R,\n        C = T + S,\n        P = T - S,\n        k = r(P * w),\n        M = r(C * I),\n        D = k + M,\n        z = k - M;\n      T = r(D * D), S = r($ * r(z * z)), B = r(b * R), A = r(x * (b + r(l * x)));\n    }\n    U = u(L, B, T), B = U[0], T = U[1], U = u(L, A, S), A = U[0], S = U[1];\n    const _ = a(A);\n    return r(B * _);\n  }\n  function h(m) {\n    return me(r(m), i);\n  }\n  function y(m) {\n    const O = et(\"u coordinate\", m, i);\n    return s === 32 && (O[31] &= 127), te(O);\n  }\n  function E(m) {\n    const O = et(\"scalar\", m),\n      N = O.length;\n    if (N !== i && N !== s) {\n      let $ = \"\" + i + \" or \" + s;\n      throw new Error(\"invalid scalar, expected \" + $ + \" bytes, got \" + N);\n    }\n    return te(c(O));\n  }\n  function p(m, O) {\n    const N = y(O),\n      $ = E(m),\n      B = f(N, $);\n    if (B === Dt) throw new Error(\"invalid private or public key received\");\n    return h(B);\n  }\n  const d = h(e.Gu);\n  function v(m) {\n    return p(m, d);\n  }\n  return {\n    scalarMult: p,\n    scalarMultBase: v,\n    getSharedSecret: (m, O) => p(m, O),\n    getPublicKey: m => v(m),\n    utils: {\n      randomPrivateKey: () => e.randomBytes(e.nByteLength)\n    },\n    GuBytes: d\n  };\n}\nconst an = BigInt(\"57896044618658097711785492504343953926634992332820282019728792003956564819949\");\nBigInt(0);\nconst yc = BigInt(1),\n  Xr = BigInt(2),\n  mc = BigInt(3),\n  wc = BigInt(5);\nBigInt(8);\nfunction bc(t) {\n  const e = BigInt(10),\n    n = BigInt(20),\n    r = BigInt(40),\n    o = BigInt(80),\n    i = an,\n    c = t * t % i * t % i,\n    a = ot(c, Xr, i) * c % i,\n    u = ot(a, yc, i) * t % i,\n    l = ot(u, wc, i) * u % i,\n    f = ot(l, e, i) * l % i,\n    h = ot(f, n, i) * f % i,\n    y = ot(h, r, i) * h % i,\n    E = ot(y, o, i) * y % i,\n    p = ot(E, o, i) * y % i,\n    d = ot(p, e, i) * l % i;\n  return {\n    pow_p_5_8: ot(d, Xr, i) * t % i,\n    b2: c\n  };\n}\nfunction Ec(t) {\n  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;\n}\nconst un = gc({\n  P: an,\n  a: BigInt(486662),\n  montgomeryBits: 255,\n  nByteLength: 32,\n  Gu: BigInt(9),\n  powPminus2: t => {\n    const e = an,\n      {\n        pow_p_5_8: n,\n        b2: r\n      } = bc(t);\n    return X(ot(n, mc, e) * r, e);\n  },\n  adjustScalarBytes: Ec,\n  randomBytes: $t\n});\nfunction Jr(t) {\n  t.lowS !== void 0 && jt(\"lowS\", t.lowS), t.prehash !== void 0 && jt(\"prehash\", t.prehash);\n}\nfunction vc(t) {\n  const e = Wr(t);\n  Mt(e, {\n    a: \"field\",\n    b: \"field\"\n  }, {\n    allowedPrivateKeyLengths: \"array\",\n    wrapPrivateKey: \"boolean\",\n    isTorsionFree: \"function\",\n    clearCofactor: \"function\",\n    allowInfinityPoint: \"boolean\",\n    fromBytes: \"function\",\n    toBytes: \"function\"\n  });\n  const {\n    endo: n,\n    Fp: r,\n    a: o\n  } = e;\n  if (n) {\n    if (!r.eql(o, r.ZERO)) throw new Error(\"invalid endomorphism, can only be defined for Koblitz curves that have a=0\");\n    if (typeof n != \"object\" || typeof n.beta != \"bigint\" || typeof n.splitScalar != \"function\") throw new Error(\"invalid endomorphism, expected beta: bigint and splitScalar: function\");\n  }\n  return Object.freeze({\n    ...e\n  });\n}\nconst {\n  bytesToNumberBE: xc,\n  hexToBytes: Sc\n} = ec;\nclass Oc extends Error {\n  constructor(e = \"\") {\n    super(e);\n  }\n}\nconst lt = {\n    Err: Oc,\n    _tlv: {\n      encode: (t, e) => {\n        const {\n          Err: n\n        } = lt;\n        if (t < 0 || t > 256) throw new n(\"tlv.encode: wrong tag\");\n        if (e.length & 1) throw new n(\"tlv.encode: unpadded data\");\n        const r = e.length / 2,\n          o = Pt(r);\n        if (o.length / 2 & 128) throw new n(\"tlv.encode: long form length too big\");\n        const i = r > 127 ? Pt(o.length / 2 | 128) : \"\";\n        return Pt(t) + i + o + e;\n      },\n      decode(t, e) {\n        const {\n          Err: n\n        } = lt;\n        let r = 0;\n        if (t < 0 || t > 256) throw new n(\"tlv.encode: wrong tag\");\n        if (e.length < 2 || e[r++] !== t) throw new n(\"tlv.decode: wrong tlv\");\n        const o = e[r++],\n          i = !!(o & 128);\n        let s = 0;\n        if (!i) s = o;else {\n          const a = o & 127;\n          if (!a) throw new n(\"tlv.decode(long): indefinite length not supported\");\n          if (a > 4) throw new n(\"tlv.decode(long): byte length is too big\");\n          const u = e.subarray(r, r + a);\n          if (u.length !== a) throw new n(\"tlv.decode: length bytes not complete\");\n          if (u[0] === 0) throw new n(\"tlv.decode(long): zero leftmost byte\");\n          for (const l of u) s = s << 8 | l;\n          if (r += a, s < 128) throw new n(\"tlv.decode(long): not minimal encoding\");\n        }\n        const c = e.subarray(r, r + s);\n        if (c.length !== s) throw new n(\"tlv.decode: wrong value length\");\n        return {\n          v: c,\n          l: e.subarray(r + s)\n        };\n      }\n    },\n    _int: {\n      encode(t) {\n        const {\n          Err: e\n        } = lt;\n        if (t < dt) throw new e(\"integer: negative integers are not allowed\");\n        let n = Pt(t);\n        if (Number.parseInt(n[0], 16) & 8 && (n = \"00\" + n), n.length & 1) throw new e(\"unexpected DER parsing assertion: unpadded hex\");\n        return n;\n      },\n      decode(t) {\n        const {\n          Err: e\n        } = lt;\n        if (t[0] & 128) throw new e(\"invalid signature integer: negative\");\n        if (t[0] === 0 && !(t[1] & 128)) throw new e(\"invalid signature integer: unnecessary leading zero\");\n        return xc(t);\n      }\n    },\n    toSig(t) {\n      const {\n          Err: e,\n          _int: n,\n          _tlv: r\n        } = lt,\n        o = typeof t == \"string\" ? Sc(t) : t;\n      Qt(o);\n      const {\n        v: i,\n        l: s\n      } = r.decode(48, o);\n      if (s.length) throw new e(\"invalid signature: left bytes after parsing\");\n      const {\n          v: c,\n          l: a\n        } = r.decode(2, i),\n        {\n          v: u,\n          l\n        } = r.decode(2, a);\n      if (l.length) throw new e(\"invalid signature: left bytes after parsing\");\n      return {\n        r: n.decode(c),\n        s: n.decode(u)\n      };\n    },\n    hexFromSig(t) {\n      const {\n          _tlv: e,\n          _int: n\n        } = lt,\n        r = e.encode(2, n.encode(t.r)),\n        o = e.encode(2, n.encode(t.s)),\n        i = r + o;\n      return e.encode(48, i);\n    }\n  },\n  dt = BigInt(0),\n  K = BigInt(1);\nBigInt(2);\nconst Qr = BigInt(3);\nBigInt(4);\nfunction Ac(t) {\n  const e = vc(t),\n    {\n      Fp: n\n    } = e,\n    r = Kr(e.n, e.nBitLength),\n    o = e.toBytes || ((p, d, v) => {\n      const m = d.toAffine();\n      return ee(Uint8Array.from([4]), n.toBytes(m.x), n.toBytes(m.y));\n    }),\n    i = e.fromBytes || (p => {\n      const d = p.subarray(1),\n        v = n.fromBytes(d.subarray(0, n.BYTES)),\n        m = n.fromBytes(d.subarray(n.BYTES, 2 * n.BYTES));\n      return {\n        x: v,\n        y: m\n      };\n    });\n  function s(p) {\n    const {\n        a: d,\n        b: v\n      } = e,\n      m = n.sqr(p),\n      O = n.mul(m, p);\n    return n.add(n.add(O, n.mul(p, d)), v);\n  }\n  if (!n.eql(n.sqr(e.Gy), s(e.Gx))) throw new Error(\"bad generator point: equation left != right\");\n  function c(p) {\n    return we(p, K, e.n);\n  }\n  function a(p) {\n    const {\n      allowedPrivateKeyLengths: d,\n      nByteLength: v,\n      wrapPrivateKey: m,\n      n: O\n    } = e;\n    if (d && typeof p != \"bigint\") {\n      if (St(p) && (p = Ct(p)), typeof p != \"string\" || !d.includes(p.length)) throw new Error(\"invalid private key\");\n      p = p.padStart(v * 2, \"0\");\n    }\n    let N;\n    try {\n      N = typeof p == \"bigint\" ? p : Ot(et(\"private key\", p, v));\n    } catch {\n      throw new Error(\"invalid private key, expected hex or \" + v + \" bytes, got \" + typeof p);\n    }\n    return m && (N = X(N, O)), ft(\"private key\", N, K, O), N;\n  }\n  function u(p) {\n    if (!(p instanceof h)) throw new Error(\"ProjectivePoint expected\");\n  }\n  const l = Qe((p, d) => {\n      const {\n        px: v,\n        py: m,\n        pz: O\n      } = p;\n      if (n.eql(O, n.ONE)) return {\n        x: v,\n        y: m\n      };\n      const N = p.is0();\n      d == null && (d = N ? n.ONE : n.inv(O));\n      const $ = n.mul(v, d),\n        B = n.mul(m, d),\n        A = n.mul(O, d);\n      if (N) return {\n        x: n.ZERO,\n        y: n.ZERO\n      };\n      if (!n.eql(A, n.ONE)) throw new Error(\"invZ was invalid\");\n      return {\n        x: $,\n        y: B\n      };\n    }),\n    f = Qe(p => {\n      if (p.is0()) {\n        if (e.allowInfinityPoint && !n.is0(p.py)) return;\n        throw new Error(\"bad point: ZERO\");\n      }\n      const {\n        x: d,\n        y: v\n      } = p.toAffine();\n      if (!n.isValid(d) || !n.isValid(v)) throw new Error(\"bad point: x or y not FE\");\n      const m = n.sqr(v),\n        O = s(d);\n      if (!n.eql(m, O)) throw new Error(\"bad point: equation left != right\");\n      if (!p.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n      return !0;\n    });\n  class h {\n    constructor(d, v, m) {\n      if (this.px = d, this.py = v, this.pz = m, d == null || !n.isValid(d)) throw new Error(\"x required\");\n      if (v == null || !n.isValid(v)) throw new Error(\"y required\");\n      if (m == null || !n.isValid(m)) throw new Error(\"z required\");\n      Object.freeze(this);\n    }\n    static fromAffine(d) {\n      const {\n        x: v,\n        y: m\n      } = d || {};\n      if (!d || !n.isValid(v) || !n.isValid(m)) throw new Error(\"invalid affine point\");\n      if (d instanceof h) throw new Error(\"projective point not allowed\");\n      const O = N => n.eql(N, n.ZERO);\n      return O(v) && O(m) ? h.ZERO : new h(v, m, n.ONE);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    static normalizeZ(d) {\n      const v = n.invertBatch(d.map(m => m.pz));\n      return d.map((m, O) => m.toAffine(v[O])).map(h.fromAffine);\n    }\n    static fromHex(d) {\n      const v = h.fromAffine(i(et(\"pointHex\", d)));\n      return v.assertValidity(), v;\n    }\n    static fromPrivateKey(d) {\n      return h.BASE.multiply(a(d));\n    }\n    static msm(d, v) {\n      return hc(h, r, d, v);\n    }\n    _setWindowSize(d) {\n      E.setWindowSize(this, d);\n    }\n    assertValidity() {\n      f(this);\n    }\n    hasEvenY() {\n      const {\n        y: d\n      } = this.toAffine();\n      if (n.isOdd) return !n.isOdd(d);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n    equals(d) {\n      u(d);\n      const {\n          px: v,\n          py: m,\n          pz: O\n        } = this,\n        {\n          px: N,\n          py: $,\n          pz: B\n        } = d,\n        A = n.eql(n.mul(v, B), n.mul(N, O)),\n        T = n.eql(n.mul(m, B), n.mul($, O));\n      return A && T;\n    }\n    negate() {\n      return new h(this.px, n.neg(this.py), this.pz);\n    }\n    double() {\n      const {\n          a: d,\n          b: v\n        } = e,\n        m = n.mul(v, Qr),\n        {\n          px: O,\n          py: N,\n          pz: $\n        } = this;\n      let B = n.ZERO,\n        A = n.ZERO,\n        T = n.ZERO,\n        S = n.mul(O, O),\n        L = n.mul(N, N),\n        U = n.mul($, $),\n        _ = n.mul(O, N);\n      return _ = n.add(_, _), T = n.mul(O, $), T = n.add(T, T), B = n.mul(d, T), A = n.mul(m, U), A = n.add(B, A), B = n.sub(L, A), A = n.add(L, A), A = n.mul(B, A), B = n.mul(_, B), T = n.mul(m, T), U = n.mul(d, U), _ = n.sub(S, U), _ = n.mul(d, _), _ = n.add(_, T), T = n.add(S, S), S = n.add(T, S), S = n.add(S, U), S = n.mul(S, _), A = n.add(A, S), U = n.mul(N, $), U = n.add(U, U), S = n.mul(U, _), B = n.sub(B, S), T = n.mul(U, L), T = n.add(T, T), T = n.add(T, T), new h(B, A, T);\n    }\n    add(d) {\n      u(d);\n      const {\n          px: v,\n          py: m,\n          pz: O\n        } = this,\n        {\n          px: N,\n          py: $,\n          pz: B\n        } = d;\n      let A = n.ZERO,\n        T = n.ZERO,\n        S = n.ZERO;\n      const L = e.a,\n        U = n.mul(e.b, Qr);\n      let _ = n.mul(v, N),\n        j = n.mul(m, $),\n        g = n.mul(O, B),\n        w = n.add(v, m),\n        b = n.add(N, $);\n      w = n.mul(w, b), b = n.add(_, j), w = n.sub(w, b), b = n.add(v, O);\n      let I = n.add(N, B);\n      return b = n.mul(b, I), I = n.add(_, g), b = n.sub(b, I), I = n.add(m, O), A = n.add($, B), I = n.mul(I, A), A = n.add(j, g), I = n.sub(I, A), S = n.mul(L, b), A = n.mul(U, g), S = n.add(A, S), A = n.sub(j, S), S = n.add(j, S), T = n.mul(A, S), j = n.add(_, _), j = n.add(j, _), g = n.mul(L, g), b = n.mul(U, b), j = n.add(j, g), g = n.sub(_, g), g = n.mul(L, g), b = n.add(b, g), _ = n.mul(j, b), T = n.add(T, _), _ = n.mul(I, b), A = n.mul(w, A), A = n.sub(A, _), _ = n.mul(w, j), S = n.mul(I, S), S = n.add(S, _), new h(A, T, S);\n    }\n    subtract(d) {\n      return this.add(d.negate());\n    }\n    is0() {\n      return this.equals(h.ZERO);\n    }\n    wNAF(d) {\n      return E.wNAFCached(this, d, h.normalizeZ);\n    }\n    multiplyUnsafe(d) {\n      const {\n        endo: v,\n        n: m\n      } = e;\n      ft(\"scalar\", d, dt, m);\n      const O = h.ZERO;\n      if (d === dt) return O;\n      if (this.is0() || d === K) return this;\n      if (!v || E.hasPrecomputes(this)) return E.wNAFCachedUnsafe(this, d, h.normalizeZ);\n      let {\n          k1neg: N,\n          k1: $,\n          k2neg: B,\n          k2: A\n        } = v.splitScalar(d),\n        T = O,\n        S = O,\n        L = this;\n      for (; $ > dt || A > dt;) $ & K && (T = T.add(L)), A & K && (S = S.add(L)), L = L.double(), $ >>= K, A >>= K;\n      return N && (T = T.negate()), B && (S = S.negate()), S = new h(n.mul(S.px, v.beta), S.py, S.pz), T.add(S);\n    }\n    multiply(d) {\n      const {\n        endo: v,\n        n: m\n      } = e;\n      ft(\"scalar\", d, K, m);\n      let O, N;\n      if (v) {\n        const {\n          k1neg: $,\n          k1: B,\n          k2neg: A,\n          k2: T\n        } = v.splitScalar(d);\n        let {\n            p: S,\n            f: L\n          } = this.wNAF(B),\n          {\n            p: U,\n            f: _\n          } = this.wNAF(T);\n        S = E.constTimeNegate($, S), U = E.constTimeNegate(A, U), U = new h(n.mul(U.px, v.beta), U.py, U.pz), O = S.add(U), N = L.add(_);\n      } else {\n        const {\n          p: $,\n          f: B\n        } = this.wNAF(d);\n        O = $, N = B;\n      }\n      return h.normalizeZ([O, N])[0];\n    }\n    multiplyAndAddUnsafe(d, v, m) {\n      const O = h.BASE,\n        N = (B, A) => A === dt || A === K || !B.equals(O) ? B.multiplyUnsafe(A) : B.multiply(A),\n        $ = N(this, v).add(N(d, m));\n      return $.is0() ? void 0 : $;\n    }\n    toAffine(d) {\n      return l(this, d);\n    }\n    isTorsionFree() {\n      const {\n        h: d,\n        isTorsionFree: v\n      } = e;\n      if (d === K) return !0;\n      if (v) return v(h, this);\n      throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n    }\n    clearCofactor() {\n      const {\n        h: d,\n        clearCofactor: v\n      } = e;\n      return d === K ? this : v ? v(h, this) : this.multiplyUnsafe(e.h);\n    }\n    toRawBytes(d = !0) {\n      return jt(\"isCompressed\", d), this.assertValidity(), o(h, this, d);\n    }\n    toHex(d = !0) {\n      return jt(\"isCompressed\", d), Ct(this.toRawBytes(d));\n    }\n  }\n  h.BASE = new h(e.Gx, e.Gy, n.ONE), h.ZERO = new h(n.ZERO, n.ONE, n.ZERO);\n  const y = e.nBitLength,\n    E = dc(h, e.endo ? Math.ceil(y / 2) : y);\n  return {\n    CURVE: e,\n    ProjectivePoint: h,\n    normPrivateKeyToScalar: a,\n    weierstrassEquation: s,\n    isWithinCurveOrder: c\n  };\n}\nfunction Bc(t) {\n  const e = Wr(t);\n  return Mt(e, {\n    hash: \"hash\",\n    hmac: \"function\",\n    randomBytes: \"function\"\n  }, {\n    bits2int: \"function\",\n    bits2int_modN: \"function\",\n    lowS: \"boolean\"\n  }), Object.freeze({\n    lowS: !0,\n    ...e\n  });\n}\nfunction Ic(t) {\n  const e = Bc(t),\n    {\n      Fp: n,\n      n: r\n    } = e,\n    o = n.BYTES + 1,\n    i = 2 * n.BYTES + 1;\n  function s(g) {\n    return X(g, r);\n  }\n  function c(g) {\n    return en(g, r);\n  }\n  const {\n      ProjectivePoint: a,\n      normPrivateKeyToScalar: u,\n      weierstrassEquation: l,\n      isWithinCurveOrder: f\n    } = Ac({\n      ...e,\n      toBytes(g, w, b) {\n        const I = w.toAffine(),\n          R = n.toBytes(I.x),\n          x = ee;\n        return jt(\"isCompressed\", b), b ? x(Uint8Array.from([w.hasEvenY() ? 2 : 3]), R) : x(Uint8Array.from([4]), R, n.toBytes(I.y));\n      },\n      fromBytes(g) {\n        const w = g.length,\n          b = g[0],\n          I = g.subarray(1);\n        if (w === o && (b === 2 || b === 3)) {\n          const R = Ot(I);\n          if (!we(R, K, n.ORDER)) throw new Error(\"Point is not on curve\");\n          const x = l(R);\n          let C;\n          try {\n            C = n.sqrt(x);\n          } catch (M) {\n            const D = M instanceof Error ? \": \" + M.message : \"\";\n            throw new Error(\"Point is not on curve\" + D);\n          }\n          const P = (C & K) === K;\n          return (b & 1) === 1 !== P && (C = n.neg(C)), {\n            x: R,\n            y: C\n          };\n        } else if (w === i && b === 4) {\n          const R = n.fromBytes(I.subarray(0, n.BYTES)),\n            x = n.fromBytes(I.subarray(n.BYTES, 2 * n.BYTES));\n          return {\n            x: R,\n            y: x\n          };\n        } else {\n          const R = o,\n            x = i;\n          throw new Error(\"invalid Point, expected length of \" + R + \", or uncompressed \" + x + \", got \" + w);\n        }\n      }\n    }),\n    h = g => Ct(Vt(g, e.nByteLength));\n  function y(g) {\n    const w = r >> K;\n    return g > w;\n  }\n  function E(g) {\n    return y(g) ? s(-g) : g;\n  }\n  const p = (g, w, b) => Ot(g.slice(w, b));\n  class d {\n    constructor(w, b, I) {\n      this.r = w, this.s = b, this.recovery = I, this.assertValidity();\n    }\n    static fromCompact(w) {\n      const b = e.nByteLength;\n      return w = et(\"compactSignature\", w, b * 2), new d(p(w, 0, b), p(w, b, 2 * b));\n    }\n    static fromDER(w) {\n      const {\n        r: b,\n        s: I\n      } = lt.toSig(et(\"DER\", w));\n      return new d(b, I);\n    }\n    assertValidity() {\n      ft(\"r\", this.r, K, r), ft(\"s\", this.s, K, r);\n    }\n    addRecoveryBit(w) {\n      return new d(this.r, this.s, w);\n    }\n    recoverPublicKey(w) {\n      const {\n          r: b,\n          s: I,\n          recovery: R\n        } = this,\n        x = B(et(\"msgHash\", w));\n      if (R == null || ![0, 1, 2, 3].includes(R)) throw new Error(\"recovery id invalid\");\n      const C = R === 2 || R === 3 ? b + e.n : b;\n      if (C >= n.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n      const P = (R & 1) === 0 ? \"02\" : \"03\",\n        k = a.fromHex(P + h(C)),\n        M = c(C),\n        D = s(-x * M),\n        z = s(I * M),\n        Z = a.BASE.multiplyAndAddUnsafe(k, D, z);\n      if (!Z) throw new Error(\"point at infinify\");\n      return Z.assertValidity(), Z;\n    }\n    hasHighS() {\n      return y(this.s);\n    }\n    normalizeS() {\n      return this.hasHighS() ? new d(this.r, s(-this.s), this.recovery) : this;\n    }\n    toDERRawBytes() {\n      return kt(this.toDERHex());\n    }\n    toDERHex() {\n      return lt.hexFromSig({\n        r: this.r,\n        s: this.s\n      });\n    }\n    toCompactRawBytes() {\n      return kt(this.toCompactHex());\n    }\n    toCompactHex() {\n      return h(this.r) + h(this.s);\n    }\n  }\n  const v = {\n    isValidPrivateKey(g) {\n      try {\n        return u(g), !0;\n      } catch {\n        return !1;\n      }\n    },\n    normPrivateKeyToScalar: u,\n    randomPrivateKey: () => {\n      const g = zr(e.n);\n      return uc(e.randomBytes(g), e.n);\n    },\n    precompute(g = 8, w = a.BASE) {\n      return w._setWindowSize(g), w.multiply(BigInt(3)), w;\n    }\n  };\n  function m(g, w = !0) {\n    return a.fromPrivateKey(g).toRawBytes(w);\n  }\n  function O(g) {\n    const w = St(g),\n      b = typeof g == \"string\",\n      I = (w || b) && g.length;\n    return w ? I === o || I === i : b ? I === 2 * o || I === 2 * i : g instanceof a;\n  }\n  function N(g, w, b = !0) {\n    if (O(g)) throw new Error(\"first arg must be private key\");\n    if (!O(w)) throw new Error(\"second arg must be public key\");\n    return a.fromHex(w).multiply(u(g)).toRawBytes(b);\n  }\n  const $ = e.bits2int || function (g) {\n      if (g.length > 8192) throw new Error(\"input is too large\");\n      const w = Ot(g),\n        b = g.length * 8 - e.nBitLength;\n      return b > 0 ? w >> BigInt(b) : w;\n    },\n    B = e.bits2int_modN || function (g) {\n      return s($(g));\n    },\n    A = Xe(e.nBitLength);\n  function T(g) {\n    return ft(\"num < 2^\" + e.nBitLength, g, dt, A), Vt(g, e.nByteLength);\n  }\n  function S(g, w, b = L) {\n    if ([\"recovered\", \"canonical\"].some(W => W in b)) throw new Error(\"sign() legacy options not supported\");\n    const {\n      hash: I,\n      randomBytes: R\n    } = e;\n    let {\n      lowS: x,\n      prehash: C,\n      extraEntropy: P\n    } = b;\n    x == null && (x = !0), g = et(\"msgHash\", g), Jr(b), C && (g = et(\"prehashed msgHash\", I(g)));\n    const k = B(g),\n      M = u(w),\n      D = [T(M), T(k)];\n    if (P != null && P !== !1) {\n      const W = P === !0 ? R(n.BYTES) : P;\n      D.push(et(\"extraEntropy\", W));\n    }\n    const z = ee(...D),\n      Z = k;\n    function it(W) {\n      const J = $(W);\n      if (!f(J)) return;\n      const Oe = c(J),\n        Ft = a.BASE.multiply(J).toAffine(),\n        vt = s(Ft.x);\n      if (vt === dt) return;\n      const zt = s(Oe * s(Z + vt * M));\n      if (zt === dt) return;\n      let Ut = (Ft.x === vt ? 0 : 2) | Number(Ft.y & K),\n        vn = zt;\n      return x && y(zt) && (vn = E(zt), Ut ^= 1), new d(vt, vn, Ut);\n    }\n    return {\n      seed: z,\n      k2sig: it\n    };\n  }\n  const L = {\n      lowS: e.lowS,\n      prehash: !1\n    },\n    U = {\n      lowS: e.lowS,\n      prehash: !1\n    };\n  function _(g, w, b = L) {\n    const {\n        seed: I,\n        k2sig: R\n      } = S(g, w, b),\n      x = e;\n    return Vr(x.hash.outputLen, x.nByteLength, x.hmac)(I, R);\n  }\n  a.BASE._setWindowSize(8);\n  function j(g, w, b, I = U) {\n    const R = g;\n    w = et(\"msgHash\", w), b = et(\"publicKey\", b);\n    const {\n      lowS: x,\n      prehash: C,\n      format: P\n    } = I;\n    if (Jr(I), \"strict\" in I) throw new Error(\"options.strict was renamed to lowS\");\n    if (P !== void 0 && P !== \"compact\" && P !== \"der\") throw new Error(\"format must be compact or der\");\n    const k = typeof R == \"string\" || St(R),\n      M = !k && !P && typeof R == \"object\" && R !== null && typeof R.r == \"bigint\" && typeof R.s == \"bigint\";\n    if (!k && !M) throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n    let D, z;\n    try {\n      if (M && (D = new d(R.r, R.s)), k) {\n        try {\n          P !== \"compact\" && (D = d.fromDER(R));\n        } catch (Ut) {\n          if (!(Ut instanceof lt.Err)) throw Ut;\n        }\n        !D && P !== \"der\" && (D = d.fromCompact(R));\n      }\n      z = a.fromHex(b);\n    } catch {\n      return !1;\n    }\n    if (!D || x && D.hasHighS()) return !1;\n    C && (w = e.hash(w));\n    const {\n        r: Z,\n        s: it\n      } = D,\n      W = B(w),\n      J = c(it),\n      Oe = s(W * J),\n      Ft = s(Z * J),\n      vt = a.BASE.multiplyAndAddUnsafe(z, Oe, Ft)?.toAffine();\n    return vt ? s(vt.x) === Z : !1;\n  }\n  return {\n    CURVE: e,\n    getPublicKey: m,\n    getSharedSecret: N,\n    sign: _,\n    verify: j,\n    ProjectivePoint: a,\n    Signature: d,\n    utils: v\n  };\n}\nfunction Nc(t) {\n  return {\n    hash: t,\n    hmac: (e, ...n) => pe(t, e, Vi(...n)),\n    randomBytes: $t\n  };\n}\nfunction Uc(t, e) {\n  const n = r => Ic({\n    ...t,\n    ...Nc(r)\n  });\n  return {\n    ...n(e),\n    create: n\n  };\n}\nconst to = Kr(BigInt(\"0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff\")),\n  Tc = to.create(BigInt(\"-3\")),\n  Rc = BigInt(\"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\"),\n  _c = Uc({\n    a: Tc,\n    b: Rc,\n    Fp: to,\n    n: BigInt(\"0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\"),\n    Gx: BigInt(\"0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\"),\n    Gy: BigInt(\"0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\"),\n    h: BigInt(1),\n    lowS: !1\n  }, Jt),\n  fn = \"base10\",\n  G = \"base16\",\n  Ht = \"base64pad\",\n  Ee = \"base64url\",\n  qt = \"utf8\",\n  ln = 0,\n  Kt = 1,\n  ne = 2,\n  $c = 0,\n  eo = 1,\n  re = 12,\n  dn = 32;\nfunction Lc() {\n  const t = un.utils.randomPrivateKey(),\n    e = un.getPublicKey(t);\n  return {\n    privateKey: Q(t, G),\n    publicKey: Q(e, G)\n  };\n}\nfunction jc() {\n  const t = $t(dn);\n  return Q(t, G);\n}\nfunction Cc(t, e) {\n  const n = un.getSharedSecret(rt(t, G), rt(e, G)),\n    r = Vs(Jt, n, void 0, void 0, dn);\n  return Q(r, G);\n}\nfunction Pc(t) {\n  const e = Jt(rt(t, G));\n  return Q(e, G);\n}\nfunction kc(t) {\n  const e = Jt(rt(t, qt));\n  return Q(e, G);\n}\nfunction hn(t) {\n  return rt(`${t}`, fn);\n}\nfunction Bt(t) {\n  return Number(Q(t, fn));\n}\nfunction no(t) {\n  return t.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\nfunction ro(t) {\n  const e = t.replace(/-/g, \"+\").replace(/_/g, \"/\"),\n    n = (4 - e.length % 4) % 4;\n  return e + \"=\".repeat(n);\n}\nfunction Vc(t) {\n  const e = hn(typeof t.type < \"u\" ? t.type : ln);\n  if (Bt(e) === Kt && typeof t.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  const n = typeof t.senderPublicKey < \"u\" ? rt(t.senderPublicKey, G) : void 0,\n    r = typeof t.iv < \"u\" ? rt(t.iv, G) : $t(re),\n    o = rt(t.symKey, G),\n    i = $r(o, r).encrypt(rt(t.message, qt)),\n    s = pn({\n      type: e,\n      sealed: i,\n      iv: r,\n      senderPublicKey: n\n    });\n  return t.encoding === Ee ? no(s) : s;\n}\nfunction Mc(t) {\n  const e = rt(t.symKey, G),\n    {\n      sealed: n,\n      iv: r\n    } = ve({\n      encoded: t.encoded,\n      encoding: t.encoding\n    }),\n    o = $r(e, r).decrypt(n);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return Q(o, qt);\n}\nfunction Dc(t, e) {\n  const n = hn(ne),\n    r = $t(re),\n    o = rt(t, qt),\n    i = pn({\n      type: n,\n      sealed: o,\n      iv: r\n    });\n  return e === Ee ? no(i) : i;\n}\nfunction Hc(t, e) {\n  const {\n    sealed: n\n  } = ve({\n    encoded: t,\n    encoding: e\n  });\n  return Q(n, qt);\n}\nfunction pn(t) {\n  if (Bt(t.type) === ne) return Q(Zt([t.type, t.sealed]), Ht);\n  if (Bt(t.type) === Kt) {\n    if (typeof t.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return Q(Zt([t.type, t.senderPublicKey, t.iv, t.sealed]), Ht);\n  }\n  return Q(Zt([t.type, t.iv, t.sealed]), Ht);\n}\nfunction ve(t) {\n  const e = (t.encoding || Ht) === Ee ? ro(t.encoded) : t.encoded,\n    n = rt(e, Ht),\n    r = n.slice($c, eo),\n    o = eo;\n  if (Bt(r) === Kt) {\n    const a = o + dn,\n      u = a + re,\n      l = n.slice(o, a),\n      f = n.slice(a, u),\n      h = n.slice(u);\n    return {\n      type: r,\n      sealed: h,\n      iv: f,\n      senderPublicKey: l\n    };\n  }\n  if (Bt(r) === ne) {\n    const a = n.slice(o),\n      u = $t(re);\n    return {\n      type: r,\n      sealed: a,\n      iv: u\n    };\n  }\n  const i = o + re,\n    s = n.slice(o, i),\n    c = n.slice(i);\n  return {\n    type: r,\n    sealed: c,\n    iv: s\n  };\n}\nfunction qc(t, e) {\n  const n = ve({\n    encoded: t,\n    encoding: e?.encoding\n  });\n  return oo({\n    type: Bt(n.type),\n    senderPublicKey: typeof n.senderPublicKey < \"u\" ? Q(n.senderPublicKey, G) : void 0,\n    receiverPublicKey: e?.receiverPublicKey\n  });\n}\nfunction oo(t) {\n  const e = t?.type || ln;\n  if (e === Kt) {\n    if (typeof t?.senderPublicKey > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof t?.receiverPublicKey > \"u\") throw new Error(\"missing receiver public key\");\n  }\n  return {\n    type: e,\n    senderPublicKey: t?.senderPublicKey,\n    receiverPublicKey: t?.receiverPublicKey\n  };\n}\nfunction Kc(t) {\n  return t.type === Kt && typeof t.senderPublicKey == \"string\" && typeof t.receiverPublicKey == \"string\";\n}\nfunction Fc(t) {\n  return t.type === ne;\n}\nfunction io(t) {\n  const e = Buffer.from(t.x, \"base64\"),\n    n = Buffer.from(t.y, \"base64\");\n  return Zt([new Uint8Array([4]), e, n]);\n}\nfunction zc(t, e) {\n  const [n, r, o] = t.split(\".\"),\n    i = Buffer.from(ro(o), \"base64\");\n  if (i.length !== 64) throw new Error(\"Invalid signature length\");\n  const s = i.slice(0, 32),\n    c = i.slice(32, 64),\n    a = `${n}.${r}`,\n    u = Jt(a),\n    l = io(e);\n  if (!_c.verify(Zt([s, c]), u, l)) throw new Error(\"Invalid signature\");\n  return Mo(t).payload;\n}\nconst so = \"irn\";\nfunction Zc(t) {\n  return t?.relay || {\n    protocol: so\n  };\n}\nfunction Yc(t) {\n  const e = Do[t];\n  if (typeof e > \"u\") throw new Error(`Relay Protocol not supported: ${t}`);\n  return e;\n}\nfunction co(t, e = \"-\") {\n  const n = {},\n    r = \"relay\" + e;\n  return Object.keys(t).forEach(o => {\n    if (o.startsWith(r)) {\n      const i = o.replace(r, \"\"),\n        s = t[o];\n      n[i] = s;\n    }\n  }), n;\n}\nfunction Gc(t) {\n  if (!t.includes(\"wc:\")) {\n    const u = Le(t);\n    u != null && u.includes(\"wc:\") && (t = u);\n  }\n  t = t.includes(\"wc://\") ? t.replace(\"wc://\", \"\") : t, t = t.includes(\"wc:\") ? t.replace(\"wc:\", \"\") : t;\n  const e = t.indexOf(\":\"),\n    n = t.indexOf(\"?\") !== -1 ? t.indexOf(\"?\") : void 0,\n    r = t.substring(0, e),\n    o = t.substring(e + 1, n).split(\"@\"),\n    i = typeof n < \"u\" ? t.substring(n) : \"\",\n    s = new URLSearchParams(i),\n    c = {};\n  s.forEach((u, l) => {\n    c[l] = u;\n  });\n  const a = typeof c.methods == \"string\" ? c.methods.split(\",\") : void 0;\n  return {\n    protocol: r,\n    topic: ao(o[0]),\n    version: parseInt(o[1], 10),\n    symKey: c.symKey,\n    relay: co(c),\n    methods: a,\n    expiryTimestamp: c.expiryTimestamp ? parseInt(c.expiryTimestamp, 10) : void 0\n  };\n}\nfunction ao(t) {\n  return t.startsWith(\"//\") ? t.substring(2) : t;\n}\nfunction uo(t, e = \"-\") {\n  const n = \"relay\",\n    r = {};\n  return Object.keys(t).forEach(o => {\n    const i = o,\n      s = n + e + i;\n    t[i] && (r[s] = t[i]);\n  }), r;\n}\nfunction Wc(t) {\n  const e = new URLSearchParams(),\n    n = uo(t.relay);\n  Object.keys(n).sort().forEach(o => {\n    e.set(o, n[o]);\n  }), e.set(\"symKey\", t.symKey), t.expiryTimestamp && e.set(\"expiryTimestamp\", t.expiryTimestamp.toString()), t.methods && e.set(\"methods\", t.methods.join(\",\"));\n  const r = e.toString();\n  return `${t.protocol}:${t.topic}@${t.version}?${r}`;\n}\nfunction Xc(t, e, n) {\n  return `${t}?wc_ev=${n}&topic=${e}`;\n}\nvar Jc = Object.defineProperty,\n  Qc = Object.defineProperties,\n  ta = Object.getOwnPropertyDescriptors,\n  fo = Object.getOwnPropertySymbols,\n  ea = Object.prototype.hasOwnProperty,\n  na = Object.prototype.propertyIsEnumerable,\n  lo = (t, e, n) => e in t ? Jc(t, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: n\n  }) : t[e] = n,\n  ra = (t, e) => {\n    for (var n in e || (e = {})) ea.call(e, n) && lo(t, n, e[n]);\n    if (fo) for (var n of fo(e)) na.call(e, n) && lo(t, n, e[n]);\n    return t;\n  },\n  oa = (t, e) => Qc(t, ta(e));\nfunction It(t) {\n  const e = [];\n  return t.forEach(n => {\n    const [r, o] = n.split(\":\");\n    e.push(`${r}:${o}`);\n  }), e;\n}\nfunction ho(t) {\n  const e = [];\n  return Object.values(t).forEach(n => {\n    e.push(...It(n.accounts));\n  }), e;\n}\nfunction po(t, e) {\n  const n = [];\n  return Object.values(t).forEach(r => {\n    It(r.accounts).includes(e) && n.push(...r.methods);\n  }), n;\n}\nfunction go(t, e) {\n  const n = [];\n  return Object.values(t).forEach(r => {\n    It(r.accounts).includes(e) && n.push(...r.events);\n  }), n;\n}\nfunction ia(t, e) {\n  const n = Bo(t, e);\n  if (n) throw new Error(n.message);\n  const r = {};\n  for (const [o, i] of Object.entries(t)) r[o] = {\n    methods: i.methods,\n    events: i.events,\n    chains: i.accounts.map(s => `${s.split(\":\")[0]}:${s.split(\":\")[1]}`)\n  };\n  return r;\n}\nfunction sa(t) {\n  const {\n      proposal: {\n        requiredNamespaces: e,\n        optionalNamespaces: n = {}\n      },\n      supportedNamespaces: r\n    } = t,\n    o = yn(e),\n    i = yn(n),\n    s = {};\n  Object.keys(r).forEach(u => {\n    const l = r[u].chains,\n      f = r[u].methods,\n      h = r[u].events,\n      y = r[u].accounts;\n    l.forEach(E => {\n      if (!y.some(p => p.includes(E))) throw new Error(`No accounts provided for chain ${E} in namespace ${u}`);\n    }), s[u] = {\n      chains: l,\n      methods: f,\n      events: h,\n      accounts: y\n    };\n  });\n  const c = No(e, s, \"approve()\");\n  if (c) throw new Error(c.message);\n  const a = {};\n  return !Object.keys(e).length && !Object.keys(n).length ? s : (Object.keys(o).forEach(u => {\n    const l = r[u].chains.filter(E => {\n        var p, d;\n        return (d = (p = o[u]) == null ? void 0 : p.chains) == null ? void 0 : d.includes(E);\n      }),\n      f = r[u].methods.filter(E => {\n        var p, d;\n        return (d = (p = o[u]) == null ? void 0 : p.methods) == null ? void 0 : d.includes(E);\n      }),\n      h = r[u].events.filter(E => {\n        var p, d;\n        return (d = (p = o[u]) == null ? void 0 : p.events) == null ? void 0 : d.includes(E);\n      }),\n      y = l.map(E => r[u].accounts.filter(p => p.includes(`${E}:`))).flat();\n    a[u] = {\n      chains: l,\n      methods: f,\n      events: h,\n      accounts: y\n    };\n  }), Object.keys(i).forEach(u => {\n    var l, f, h, y, E, p;\n    if (!r[u]) return;\n    const d = (f = (l = i[u]) == null ? void 0 : l.chains) == null ? void 0 : f.filter(N => r[u].chains.includes(N)),\n      v = r[u].methods.filter(N => {\n        var $, B;\n        return (B = ($ = i[u]) == null ? void 0 : $.methods) == null ? void 0 : B.includes(N);\n      }),\n      m = r[u].events.filter(N => {\n        var $, B;\n        return (B = ($ = i[u]) == null ? void 0 : $.events) == null ? void 0 : B.includes(N);\n      }),\n      O = d?.map(N => r[u].accounts.filter($ => $.includes(`${N}:`))).flat();\n    a[u] = {\n      chains: at((h = a[u]) == null ? void 0 : h.chains, d),\n      methods: at((y = a[u]) == null ? void 0 : y.methods, v),\n      events: at((E = a[u]) == null ? void 0 : E.events, m),\n      accounts: at((p = a[u]) == null ? void 0 : p.accounts, O)\n    };\n  }), a);\n}\nfunction gn(t) {\n  return t.includes(\":\");\n}\nfunction yo(t) {\n  return gn(t) ? t.split(\":\")[0] : t;\n}\nfunction yn(t) {\n  var e, n, r;\n  const o = {};\n  if (!xe(t)) return o;\n  for (const [i, s] of Object.entries(t)) {\n    const c = gn(i) ? [i] : s.chains,\n      a = s.methods || [],\n      u = s.events || [],\n      l = yo(i);\n    o[l] = oa(ra({}, o[l]), {\n      chains: at(c, (e = o[l]) == null ? void 0 : e.chains),\n      methods: at(a, (n = o[l]) == null ? void 0 : n.methods),\n      events: at(u, (r = o[l]) == null ? void 0 : r.events)\n    });\n  }\n  return o;\n}\nfunction mo(t) {\n  const e = {};\n  return t?.forEach(n => {\n    var r;\n    const [o, i] = n.split(\":\");\n    e[o] || (e[o] = {\n      accounts: [],\n      chains: [],\n      events: [],\n      methods: []\n    }), e[o].accounts.push(n), (r = e[o].chains) == null || r.push(`${o}:${i}`);\n  }), e;\n}\nfunction ca(t, e) {\n  e = e.map(r => r.replace(\"did:pkh:\", \"\"));\n  const n = mo(e);\n  for (const [r, o] of Object.entries(n)) o.methods ? o.methods = at(o.methods, t) : o.methods = t, o.events = [\"chainChanged\", \"accountsChanged\"];\n  return n;\n}\nconst wo = {\n    INVALID_METHOD: {\n      message: \"Invalid method.\",\n      code: 1001\n    },\n    INVALID_EVENT: {\n      message: \"Invalid event.\",\n      code: 1002\n    },\n    INVALID_UPDATE_REQUEST: {\n      message: \"Invalid update request.\",\n      code: 1003\n    },\n    INVALID_EXTEND_REQUEST: {\n      message: \"Invalid extend request.\",\n      code: 1004\n    },\n    INVALID_SESSION_SETTLE_REQUEST: {\n      message: \"Invalid session settle request.\",\n      code: 1005\n    },\n    UNAUTHORIZED_METHOD: {\n      message: \"Unauthorized method.\",\n      code: 3001\n    },\n    UNAUTHORIZED_EVENT: {\n      message: \"Unauthorized event.\",\n      code: 3002\n    },\n    UNAUTHORIZED_UPDATE_REQUEST: {\n      message: \"Unauthorized update request.\",\n      code: 3003\n    },\n    UNAUTHORIZED_EXTEND_REQUEST: {\n      message: \"Unauthorized extend request.\",\n      code: 3004\n    },\n    USER_REJECTED: {\n      message: \"User rejected.\",\n      code: 5e3\n    },\n    USER_REJECTED_CHAINS: {\n      message: \"User rejected chains.\",\n      code: 5001\n    },\n    USER_REJECTED_METHODS: {\n      message: \"User rejected methods.\",\n      code: 5002\n    },\n    USER_REJECTED_EVENTS: {\n      message: \"User rejected events.\",\n      code: 5003\n    },\n    UNSUPPORTED_CHAINS: {\n      message: \"Unsupported chains.\",\n      code: 5100\n    },\n    UNSUPPORTED_METHODS: {\n      message: \"Unsupported methods.\",\n      code: 5101\n    },\n    UNSUPPORTED_EVENTS: {\n      message: \"Unsupported events.\",\n      code: 5102\n    },\n    UNSUPPORTED_ACCOUNTS: {\n      message: \"Unsupported accounts.\",\n      code: 5103\n    },\n    UNSUPPORTED_NAMESPACE_KEY: {\n      message: \"Unsupported namespace key.\",\n      code: 5104\n    },\n    USER_DISCONNECTED: {\n      message: \"User disconnected.\",\n      code: 6e3\n    },\n    SESSION_SETTLEMENT_FAILED: {\n      message: \"Session settlement failed.\",\n      code: 7e3\n    },\n    WC_METHOD_UNSUPPORTED: {\n      message: \"Unsupported wc_ method.\",\n      code: 10001\n    }\n  },\n  bo = {\n    NOT_INITIALIZED: {\n      message: \"Not initialized.\",\n      code: 1\n    },\n    NO_MATCHING_KEY: {\n      message: \"No matching key.\",\n      code: 2\n    },\n    RESTORE_WILL_OVERRIDE: {\n      message: \"Restore will override.\",\n      code: 3\n    },\n    RESUBSCRIBED: {\n      message: \"Resubscribed.\",\n      code: 4\n    },\n    MISSING_OR_INVALID: {\n      message: \"Missing or invalid.\",\n      code: 5\n    },\n    EXPIRED: {\n      message: \"Expired.\",\n      code: 6\n    },\n    UNKNOWN_TYPE: {\n      message: \"Unknown type.\",\n      code: 7\n    },\n    MISMATCHED_TOPIC: {\n      message: \"Mismatched topic.\",\n      code: 8\n    },\n    NON_CONFORMING_NAMESPACES: {\n      message: \"Non conforming namespaces.\",\n      code: 9\n    }\n  };\nfunction ht(t, e) {\n  const {\n    message: n,\n    code: r\n  } = bo[t];\n  return {\n    message: e ? `${n} ${e}` : n,\n    code: r\n  };\n}\nfunction Nt(t, e) {\n  const {\n    message: n,\n    code: r\n  } = wo[t];\n  return {\n    message: e ? `${n} ${e}` : n,\n    code: r\n  };\n}\nfunction oe(t, e) {\n  return Array.isArray(t) ? typeof e < \"u\" && t.length ? t.every(e) : !0 : !1;\n}\nfunction xe(t) {\n  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;\n}\nfunction Et(t) {\n  return typeof t > \"u\";\n}\nfunction nt(t, e) {\n  return e && Et(t) ? !0 : typeof t == \"string\" && !!t.trim().length;\n}\nfunction Se(t, e) {\n  return e && Et(t) ? !0 : typeof t == \"number\" && !isNaN(t);\n}\nfunction aa(t, e) {\n  const {\n      requiredNamespaces: n\n    } = e,\n    r = Object.keys(t.namespaces),\n    o = Object.keys(n);\n  let i = !0;\n  return gt(o, r) ? (r.forEach(s => {\n    const {\n        accounts: c,\n        methods: a,\n        events: u\n      } = t.namespaces[s],\n      l = It(c),\n      f = n[s];\n    (!gt(ce(s, f), l) || !gt(f.methods, a) || !gt(f.events, u)) && (i = !1);\n  }), i) : !1;\n}\nfunction ie(t) {\n  return nt(t, !1) && t.includes(\":\") ? t.split(\":\").length === 2 : !1;\n}\nfunction Eo(t) {\n  if (nt(t, !1) && t.includes(\":\")) {\n    const e = t.split(\":\");\n    if (e.length === 3) {\n      const n = e[0] + \":\" + e[1];\n      return !!e[2] && ie(n);\n    }\n  }\n  return !1;\n}\nfunction ua(t) {\n  function e(n) {\n    try {\n      return typeof new URL(n) < \"u\";\n    } catch {\n      return !1;\n    }\n  }\n  try {\n    if (nt(t, !1)) {\n      if (e(t)) return !0;\n      const n = Le(t);\n      return e(n);\n    }\n  } catch {}\n  return !1;\n}\nfunction fa(t) {\n  var e;\n  return (e = t?.proposer) == null ? void 0 : e.publicKey;\n}\nfunction la(t) {\n  return t?.topic;\n}\nfunction da(t, e) {\n  let n = null;\n  return nt(t?.publicKey, !1) || (n = ht(\"MISSING_OR_INVALID\", `${e} controller public key should be a string`)), n;\n}\nfunction mn(t) {\n  let e = !0;\n  return oe(t) ? t.length && (e = t.every(n => nt(n, !1))) : e = !1, e;\n}\nfunction vo(t, e, n) {\n  let r = null;\n  return oe(e) && e.length ? e.forEach(o => {\n    r || ie(o) || (r = Nt(\"UNSUPPORTED_CHAINS\", `${n}, chain ${o} should be a string and conform to \"namespace:chainId\" format`));\n  }) : ie(t) || (r = Nt(\"UNSUPPORTED_CHAINS\", `${n}, chains must be defined as \"namespace:chainId\" e.g. \"eip155:1\": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: [\"eip155:1\", \"eip155:5\"] }`)), r;\n}\nfunction xo(t, e, n) {\n  let r = null;\n  return Object.entries(t).forEach(([o, i]) => {\n    if (r) return;\n    const s = vo(o, ce(o, i), `${e} ${n}`);\n    s && (r = s);\n  }), r;\n}\nfunction So(t, e) {\n  let n = null;\n  return oe(t) ? t.forEach(r => {\n    n || Eo(r) || (n = Nt(\"UNSUPPORTED_ACCOUNTS\", `${e}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : n = Nt(\"UNSUPPORTED_ACCOUNTS\", `${e}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), n;\n}\nfunction Oo(t, e) {\n  let n = null;\n  return Object.values(t).forEach(r => {\n    if (n) return;\n    const o = So(r?.accounts, `${e} namespace`);\n    o && (n = o);\n  }), n;\n}\nfunction Ao(t, e) {\n  let n = null;\n  return mn(t?.methods) ? mn(t?.events) || (n = Nt(\"UNSUPPORTED_EVENTS\", `${e}, events should be an array of strings or empty array for no events`)) : n = Nt(\"UNSUPPORTED_METHODS\", `${e}, methods should be an array of strings or empty array for no methods`), n;\n}\nfunction wn(t, e) {\n  let n = null;\n  return Object.values(t).forEach(r => {\n    if (n) return;\n    const o = Ao(r, `${e}, namespace`);\n    o && (n = o);\n  }), n;\n}\nfunction ha(t, e, n) {\n  let r = null;\n  if (t && xe(t)) {\n    const o = wn(t, e);\n    o && (r = o);\n    const i = xo(t, e, n);\n    i && (r = i);\n  } else r = ht(\"MISSING_OR_INVALID\", `${e}, ${n} should be an object with data`);\n  return r;\n}\nfunction Bo(t, e) {\n  let n = null;\n  if (t && xe(t)) {\n    const r = wn(t, e);\n    r && (n = r);\n    const o = Oo(t, e);\n    o && (n = o);\n  } else n = ht(\"MISSING_OR_INVALID\", `${e}, namespaces should be an object with data`);\n  return n;\n}\nfunction Io(t) {\n  return nt(t.protocol, !0);\n}\nfunction pa(t, e) {\n  let n = !1;\n  return e && !t ? n = !0 : t && oe(t) && t.length && t.forEach(r => {\n    n = Io(r);\n  }), n;\n}\nfunction ga(t) {\n  return typeof t == \"number\";\n}\nfunction ya(t) {\n  return typeof t < \"u\" && typeof t !== null;\n}\nfunction ma(t) {\n  return !(!t || typeof t != \"object\" || !t.code || !Se(t.code, !1) || !t.message || !nt(t.message, !1));\n}\nfunction wa(t) {\n  return !(Et(t) || !nt(t.method, !1));\n}\nfunction ba(t) {\n  return !(Et(t) || Et(t.result) && Et(t.error) || !Se(t.id, !1) || !nt(t.jsonrpc, !1));\n}\nfunction Ea(t) {\n  return !(Et(t) || !nt(t.name, !1));\n}\nfunction va(t, e) {\n  return !(!ie(e) || !ho(t).includes(e));\n}\nfunction xa(t, e, n) {\n  return nt(n, !1) ? po(t, e).includes(n) : !1;\n}\nfunction Sa(t, e, n) {\n  return nt(n, !1) ? go(t, e).includes(n) : !1;\n}\nfunction No(t, e, n) {\n  let r = null;\n  const o = Oa(t),\n    i = Aa(e),\n    s = Object.keys(o),\n    c = Object.keys(i),\n    a = Uo(Object.keys(t)),\n    u = Uo(Object.keys(e)),\n    l = a.filter(f => !u.includes(f));\n  return l.length && (r = ht(\"NON_CONFORMING_NAMESPACES\", `${n} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${l.toString()}\n      Received: ${Object.keys(e).toString()}`)), gt(s, c) || (r = ht(\"NON_CONFORMING_NAMESPACES\", `${n} namespaces chains don't satisfy required namespaces.\n      Required: ${s.toString()}\n      Approved: ${c.toString()}`)), Object.keys(e).forEach(f => {\n    if (!f.includes(\":\") || r) return;\n    const h = It(e[f].accounts);\n    h.includes(f) || (r = ht(\"NON_CONFORMING_NAMESPACES\", `${n} namespaces accounts don't satisfy namespace accounts for ${f}\n        Required: ${f}\n        Approved: ${h.toString()}`));\n  }), s.forEach(f => {\n    r || (gt(o[f].methods, i[f].methods) ? gt(o[f].events, i[f].events) || (r = ht(\"NON_CONFORMING_NAMESPACES\", `${n} namespaces events don't satisfy namespace events for ${f}`)) : r = ht(\"NON_CONFORMING_NAMESPACES\", `${n} namespaces methods don't satisfy namespace methods for ${f}`));\n  }), r;\n}\nfunction Oa(t) {\n  const e = {};\n  return Object.keys(t).forEach(n => {\n    var r;\n    n.includes(\":\") ? e[n] = t[n] : (r = t[n].chains) == null || r.forEach(o => {\n      e[o] = {\n        methods: t[n].methods,\n        events: t[n].events\n      };\n    });\n  }), e;\n}\nfunction Uo(t) {\n  return [...new Set(t.map(e => e.includes(\":\") ? e.split(\":\")[0] : e))];\n}\nfunction Aa(t) {\n  const e = {};\n  return Object.keys(t).forEach(n => {\n    if (n.includes(\":\")) e[n] = t[n];else {\n      const r = It(t[n].accounts);\n      r?.forEach(o => {\n        e[o] = {\n          accounts: t[n].accounts.filter(i => i.includes(`${o}:`)),\n          methods: t[n].methods,\n          events: t[n].events\n        };\n      });\n    }\n  }), e;\n}\nfunction Ba(t, e) {\n  return Se(t, !1) && t <= e.max && t >= e.min;\n}\nfunction Ia() {\n  const t = xt();\n  return new Promise(e => {\n    switch (t) {\n      case Y.browser:\n        e(To());\n        break;\n      case Y.reactNative:\n        e(Ro());\n        break;\n      case Y.node:\n        e(_o());\n        break;\n      default:\n        e(!0);\n    }\n  });\n}\nfunction To() {\n  return Yt() && navigator?.onLine;\n}\nasync function Ro() {\n  if (pt() && typeof global < \"u\" && global != null && global.NetInfo) {\n    const t = await (global == null ? void 0 : global.NetInfo.fetch());\n    return t?.isConnected;\n  }\n  return !0;\n}\nfunction _o() {\n  return !0;\n}\nfunction Na(t) {\n  switch (xt()) {\n    case Y.browser:\n      $o(t);\n      break;\n    case Y.reactNative:\n      Lo(t);\n      break;\n    case Y.node:\n      break;\n  }\n}\nfunction $o(t) {\n  !pt() && Yt() && (window.addEventListener(\"online\", () => t(!0)), window.addEventListener(\"offline\", () => t(!1)));\n}\nfunction Lo(t) {\n  pt() && typeof global < \"u\" && global != null && global.NetInfo && global?.NetInfo.addEventListener(e => t(e?.isConnected));\n}\nconst bn = {};\nclass Ua {\n  static get(e) {\n    return bn[e];\n  }\n  static set(e, n) {\n    bn[e] = n;\n  }\n  static delete(e) {\n    delete bn[e];\n  }\n}\nexport { fn as BASE10, G as BASE16, Ht as BASE64, Ee as BASE64URL, Qo as COLON, Te as DEFAULT_DEPTH, ae as EMPTY_SPACE, Y as ENV_MAP, bo as INTERNAL_ERRORS, Ua as MemoryStore, ti as ONE_THOUSAND, $n as REACT_NATIVE_PRODUCT, so as RELAYER_DEFAULT_PROTOCOL, wo as SDK_ERRORS, jn as SDK_TYPE, Ln as SLASH, ln as TYPE_0, Kt as TYPE_1, ne as TYPE_2, qt as UTF8, Er as addResourceToRecap, Cn as appendToQueryString, ai as assertType, De as assignAbilityToActions, wr as base64Decode, mr as base64Encode, sa as buildApprovedNamespaces, ss as buildAuthObject, ca as buildNamespacesFromAuth, xr as buildRecapStatement, Ei as calcExpiry, pi as capitalize, qn as capitalizeWord, gi as createDelayedPromise, fs as createEncodedRecap, yi as createExpiringPromise, br as createRecap, yt as decodeRecap, Bt as decodeTypeByte, Hc as decodeTypeTwoEnvelope, Mc as decrypt, Cc as deriveSymKey, ve as deserialize, le as encodeRecap, hn as encodeTypeByte, Dc as encodeTypeTwoEnvelope, Vc as encrypt, xi as engineEvent, hi as enumify, Ji as extractSolanaTransactionId, Bn as formatAccountId, Ho as formatAccountWithChain, An as formatChainId, Kn as formatDeeplinkUrl, _e as formatExpirerTarget, wi as formatIdTarget, hr as formatMessage, ui as formatMessageContext, uo as formatRelayParams, si as formatRelayRpcUrl, qe as formatStatementFromRecap, mi as formatTopicTarget, Mn as formatUA, Wc as formatUri, Le as fromBase64, Lc as generateKeyPair, jc as generateRandomBytes32, It as getAccountsChains, Ko as getAccountsFromNamespaces, In as getAddressFromAccount, qo as getAddressesFromAccounts, ri as getAppId, Pn as getAppMetadata, To as getBrowserOnlineStatus, Nn as getChainFromAccount, Un as getChainsFromAccounts, ce as getChainsFromNamespace, Fo as getChainsFromNamespaces, hs as getChainsFromRecap, zo as getChainsFromRequiredNamespaces, $e as getCommonValuesInArrays, io as getCryptoKeyFromKeyData, pr as getDecodedRecapFromResources, Oi as getDeepLink, Me as getDidAddress, fe as getDidAddressSegments, lr as getDidChainId, xt as getEnvironment, ci as getHttpUrl, ht as getInternalError, Vn as getJavascriptID, kn as getJavascriptOS, Hn as getLastItems, Xc as getLinkModeURL, ds as getMethodsFromRecap, dr as getNamespacedDidChainId, ho as getNamespacesChains, go as getNamespacesEventsForChainId, mo as getNamespacesFromAccounts, po as getNamespacesMethodsForChainId, _o as getNodeOnlineStatus, yr as getReCapActions, Ro as getReactNativeOnlineStatus, us as getRecapAbilitiesFromResource, de as getRecapFromResources, gr as getRecapResource, ii as getRelayClientMetadata, Yc as getRelayProtocolApi, Zc as getRelayProtocolName, ia as getRequiredNamespacesFromNamespaces, Nt as getSdkError, Ai as getSearchParamFromURL, Ue as getUniqueValues, Si as handleDeeplinkRedirect, gt as hasOverlap, ke as hashEthereumMessage, Pc as hashKey, kc as hashMessage, ei as isAndroid, Yt as isBrowser, gn as isCaipNamespace, No as isConformingNamespaces, vi as isExpired, Zn as isIframe, ni as isIos, Re as isNode, Ia as isOnline, fa as isProposalStruct, pt as isReactNative, He as isRecap, aa as isSessionCompatible, la as isSessionStruct, zn as isTelegram, Ii as isTestRun, Kc as isTypeOneEnvelope, Fc as isTypeTwoEnvelope, Et as isUndefined, Eo as isValidAccountId, So as isValidAccounts, Ao as isValidActions, oe as isValidArray, ie as isValidChainId, vo as isValidChains, da as isValidController, cr as isValidEip1271Signature, sr as isValidEip191Signature, ma as isValidErrorReason, Ea as isValidEvent, ga as isValidId, Oo as isValidNamespaceAccounts, wn as isValidNamespaceActions, xo as isValidNamespaceChains, mn as isValidNamespaceMethodsOrEvents, Bo as isValidNamespaces, va as isValidNamespacesChainId, Sa as isValidNamespacesEvent, xa as isValidNamespacesRequest, Se as isValidNumber, xe as isValidObject, ya as isValidParams, ct as isValidRecap, Io as isValidRelay, pa as isValidRelays, wa as isValidRequest, Ba as isValidRequestExpiry, ha as isValidRequiredNamespaces, ba as isValidResponse, nt as isValidString, ua as isValidUrl, di as mapEntries, fi as mapToObj, at as mergeArrays, ls as mergeEncodedRecaps, vr as mergeRecaps, yn as normalizeNamespaces, li as objToMap, Fn as openDeeplink, Ne as parseAccountId, Ie as parseChainId, Dn as parseContextNames, bi as parseExpirerTarget, yo as parseNamespaceKey, co as parseRelayParams, ao as parseTopic, Gc as parseUri, oi as populateAppMetadata, cs as populateAuthPayload, as as recapHasResource, pn as serialize, Ni as sleep, $o as subscribeToBrowserNetworkChange, Na as subscribeToNetworkChange, Lo as subscribeToReactNativeNetworkChange, Yn as toBase64, Bi as uuidv4, qc as validateDecoding, oo as validateEncoding, is as validateSignedCacao, zc as verifyP256Jwt, ir as verifySignature };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}