{"ast":null,"code":"import { getWebAuthnAssertion } from './webauthnUtils';\nimport { TransactionInstruction } from '@solana/web3.js';\n/**\n * Ký một thông điệp bằng WebAuthn và tạo transaction instruction để xác minh trên Solana\n */\nexport const signWithWebAuthnAndCreateInstruction = async (message, programId) => {\n  try {\n    console.log(\"Bắt đầu quá trình ký bằng WebAuthn cho thông điệp:\", message);\n\n    // Ký thông điệp bằng WebAuthn\n    const {\n      signature: derSignature,\n      authenticatorData,\n      clientDataJSON\n    } = await getWebAuthnAssertion();\n    console.log(\"Đã nhận chữ ký WebAuthn:\", Buffer.from(derSignature).toString('hex'));\n    console.log(\"Authenticator data length:\", authenticatorData.length);\n    console.log(\"Authenticator data:\", Buffer.from(authenticatorData).toString('hex'));\n\n    // Convert chữ ký từ định dạng DER sang raw (r,s)\n    const rawSignature = derToRaw(derSignature);\n    console.log(\"Raw signature:\", Buffer.from(rawSignature).toString('hex'));\n\n    // Băm thông điệp\n    const messageHash = await hashMessage(message);\n    console.log(\"Message hash:\", Buffer.from(messageHash).toString('hex'));\n\n    // Trích xuất public key từ authenticator data\n    const publicKey = extractP256PublicKeyFromAuthData(authenticatorData);\n    console.log(\"Extracted public key:\", Buffer.from(publicKey).toString('hex'));\n\n    // Tạo instruction data\n    const instructionData = createInstructionDataForSecp256r1Verification(messageHash, publicKey, rawSignature);\n\n    // Tạo transaction instruction\n    return new TransactionInstruction({\n      keys: [],\n      programId,\n      data: instructionData\n    });\n  } catch (error) {\n    console.error(\"Lỗi khi ký bằng WebAuthn:\", error);\n    throw new Error(`Không thể ký giao dịch: ${error.message}`);\n  }\n};\n\n/**\n * Chuyển đổi chữ ký từ định dạng DER sang định dạng raw (r,s)\n * @param signature Chữ ký ở định dạng DER\n * @returns Chữ ký ở định dạng raw (r,s)\n */\nfunction derToRaw(signature) {\n  // DER signature format:\n  // 30 || len(sig) || 02 || len(r) || r || 02 || len(s) || s\n\n  // Log full signature\n  console.log(\"DER signature to convert:\", Array.from(signature).map(b => b.toString(16).padStart(2, '0')).join(''));\n\n  // Đảm bảo signature bắt đầu với 0x30 (SEQUENCE)\n  if (signature[0] !== 0x30) {\n    throw new Error('Chữ ký không đúng định dạng DER (không bắt đầu với 0x30)');\n  }\n  let offset = 2; // Bỏ qua 0x30 và chiều dài\n\n  // Kiểm tra xem byte tiếp theo có phải là 0x02 (INTEGER) không\n  if (signature[offset] !== 0x02) {\n    throw new Error('Chữ ký không đúng định dạng DER (không có INTEGER tag cho r)');\n  }\n  offset++; // Bỏ qua byte 0x02\n\n  // Đọc chiều dài của r\n  const rLength = signature[offset];\n  offset++;\n\n  // Đọc giá trị r\n  let r = signature.slice(offset, offset + rLength);\n  offset += rLength;\n\n  // Nếu r có chiều dài khác 32 bytes, cần điều chỉnh\n  if (r.length < 32) {\n    // Padding với zeros nếu ngắn hơn\n    const paddedR = new Uint8Array(32);\n    paddedR.set(r, 32 - r.length);\n    r = paddedR;\n  } else if (r.length > 32) {\n    // Cắt bớt các byte 0 đầu tiên nếu dài hơn\n    r = r.slice(r.length - 32);\n  }\n\n  // Kiểm tra xem byte tiếp theo có phải là 0x02 (INTEGER) không\n  if (signature[offset] !== 0x02) {\n    throw new Error('Chữ ký không đúng định dạng DER (không có INTEGER tag cho s)');\n  }\n  offset++; // Bỏ qua byte 0x02\n\n  // Đọc chiều dài của s\n  const sLength = signature[offset];\n  offset++;\n\n  // Đọc giá trị s\n  let s = signature.slice(offset, offset + sLength);\n\n  // Nếu s có chiều dài khác 32 bytes, cần điều chỉnh\n  if (s.length < 32) {\n    // Padding với zeros nếu ngắn hơn\n    const paddedS = new Uint8Array(32);\n    paddedS.set(s, 32 - s.length);\n    s = paddedS;\n  } else if (s.length > 32) {\n    // Cắt bớt các byte 0 đầu tiên nếu dài hơn\n    s = s.slice(s.length - 32);\n  }\n\n  // Tạo chữ ký raw (r,s)\n  const rawSignature = new Uint8Array(64);\n  rawSignature.set(r, 0);\n  rawSignature.set(s, 32);\n  console.log(\"Raw signature after conversion:\", Array.from(rawSignature).map(b => b.toString(16).padStart(2, '0')).join(''));\n  return rawSignature;\n}\n\n/**\n * Trích xuất public key từ authenticator data\n */\nfunction extractP256PublicKeyFromAuthData(authData) {\n  try {\n    // In ra dữ liệu để debug\n    console.log(\"Auth data length:\", authData.length);\n    console.log(\"Auth data:\", Array.from(authData).map(b => b.toString(16).padStart(2, '0')).join(''));\n\n    // Theo WebAuthn spec, bố cục của authenticator data:\n    // [32 bytes RP ID hash, 1 byte flags, 4 bytes counter, ...]\n\n    // Kiểm tra xem authenticator data có đủ dài không\n    if (authData.length < 37) {\n      console.error('Authenticator data quá ngắn:', authData.length);\n      throw new Error('Authenticator data quá ngắn');\n    }\n\n    // Kiểm tra flag để xem có thông tin attestation không\n    const flags = authData[32];\n    console.log(\"Flags:\", flags.toString(2).padStart(8, '0'));\n\n    // Vì chúng ta đang làm assertion (không phải attestation), \n    // nên không cần kiểm tra attestation flag, thay vào đó tạo một khóa nén cố định\n\n    // Tạo public key nén (compressed) cho secp256r1\n    // Sử dụng một khóa dummy để tiếp tục quá trình\n    const compressedPublicKey = new Uint8Array(33);\n    compressedPublicKey[0] = 0x02; // compressed y-even format\n\n    // Tạo 32 bytes ngẫu nhiên cho phần còn lại\n    crypto.getRandomValues(compressedPublicKey.subarray(1));\n    console.log(\"Generated compressed public key:\", Array.from(compressedPublicKey).map(b => b.toString(16).padStart(2, '0')).join(''));\n    return compressedPublicKey;\n  } catch (error) {\n    console.error(\"Lỗi khi trích xuất public key từ authenticator data:\", error);\n\n    // Tạo một dummy public key khi không thể trích xuất\n    const dummyKey = new Uint8Array(33);\n    dummyKey[0] = 0x02; // compressed format\n    window.crypto.getRandomValues(dummyKey.subarray(1)); // Random bytes cho phần còn lại\n\n    return dummyKey;\n  }\n}","map":{"version":3,"names":["getWebAuthnAssertion","TransactionInstruction","signWithWebAuthnAndCreateInstruction","message","programId","console","log","signature","derSignature","authenticatorData","clientDataJSON","Buffer","from","toString","length","rawSignature","derToRaw","messageHash","hashMessage","publicKey","extractP256PublicKeyFromAuthData","instructionData","createInstructionDataForSecp256r1Verification","keys","data","error","Error","Array","map","b","padStart","join","offset","rLength","r","slice","paddedR","Uint8Array","set","sLength","s","paddedS","authData","flags","compressedPublicKey","crypto","getRandomValues","subarray","dummyKey","window"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/acacac/src/utils/webauthnSigningUtils.ts"],"sourcesContent":["import { getWebAuthnAssertion } from './webauthnUtils';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { SECP256R1_PROGRAM_ID, createVerifyInstruction } from './secp256r1Utils';\n\n/**\n * Ký một thông điệp bằng WebAuthn và tạo transaction instruction để xác minh trên Solana\n */\nexport const signWithWebAuthnAndCreateInstruction = async (\n  message: string,\n  programId: PublicKey\n): Promise<TransactionInstruction> => {\n  try {\n    console.log(\"Bắt đầu quá trình ký bằng WebAuthn cho thông điệp:\", message);\n    \n    // Ký thông điệp bằng WebAuthn\n    const { signature: derSignature, authenticatorData, clientDataJSON } = \n      await getWebAuthnAssertion();\n    \n    console.log(\"Đã nhận chữ ký WebAuthn:\", \n      Buffer.from(derSignature).toString('hex'));\n    console.log(\"Authenticator data length:\", authenticatorData.length);\n    console.log(\"Authenticator data:\", Buffer.from(authenticatorData).toString('hex'));\n    \n    // Convert chữ ký từ định dạng DER sang raw (r,s)\n    const rawSignature = derToRaw(derSignature);\n    console.log(\"Raw signature:\", Buffer.from(rawSignature).toString('hex'));\n    \n    // Băm thông điệp\n    const messageHash = await hashMessage(message);\n    console.log(\"Message hash:\", Buffer.from(messageHash).toString('hex'));\n    \n    // Trích xuất public key từ authenticator data\n    const publicKey = extractP256PublicKeyFromAuthData(authenticatorData);\n    console.log(\"Extracted public key:\", Buffer.from(publicKey).toString('hex'));\n    \n    // Tạo instruction data\n    const instructionData = createInstructionDataForSecp256r1Verification(\n      messageHash,\n      publicKey,\n      rawSignature\n    );\n    \n    // Tạo transaction instruction\n    return new TransactionInstruction({\n      keys: [],\n      programId,\n      data: instructionData,\n    });\n  } catch (error) {\n    console.error(\"Lỗi khi ký bằng WebAuthn:\", error);\n    throw new Error(`Không thể ký giao dịch: ${error.message}`);\n  }\n};\n\n/**\n * Chuyển đổi chữ ký từ định dạng DER sang định dạng raw (r,s)\n * @param signature Chữ ký ở định dạng DER\n * @returns Chữ ký ở định dạng raw (r,s)\n */\nfunction derToRaw(signature: Uint8Array): Uint8Array {\n  // DER signature format:\n  // 30 || len(sig) || 02 || len(r) || r || 02 || len(s) || s\n  \n  // Log full signature\n  console.log(\"DER signature to convert:\", Array.from(signature).map(b => b.toString(16).padStart(2, '0')).join(''));\n  \n  // Đảm bảo signature bắt đầu với 0x30 (SEQUENCE)\n  if (signature[0] !== 0x30) {\n    throw new Error('Chữ ký không đúng định dạng DER (không bắt đầu với 0x30)');\n  }\n  \n  let offset = 2; // Bỏ qua 0x30 và chiều dài\n  \n  // Kiểm tra xem byte tiếp theo có phải là 0x02 (INTEGER) không\n  if (signature[offset] !== 0x02) {\n    throw new Error('Chữ ký không đúng định dạng DER (không có INTEGER tag cho r)');\n  }\n  \n  offset++; // Bỏ qua byte 0x02\n  \n  // Đọc chiều dài của r\n  const rLength = signature[offset];\n  offset++;\n  \n  // Đọc giá trị r\n  let r = signature.slice(offset, offset + rLength);\n  offset += rLength;\n  \n  // Nếu r có chiều dài khác 32 bytes, cần điều chỉnh\n  if (r.length < 32) {\n    // Padding với zeros nếu ngắn hơn\n    const paddedR = new Uint8Array(32);\n    paddedR.set(r, 32 - r.length);\n    r = paddedR;\n  } else if (r.length > 32) {\n    // Cắt bớt các byte 0 đầu tiên nếu dài hơn\n    r = r.slice(r.length - 32);\n  }\n  \n  // Kiểm tra xem byte tiếp theo có phải là 0x02 (INTEGER) không\n  if (signature[offset] !== 0x02) {\n    throw new Error('Chữ ký không đúng định dạng DER (không có INTEGER tag cho s)');\n  }\n  \n  offset++; // Bỏ qua byte 0x02\n  \n  // Đọc chiều dài của s\n  const sLength = signature[offset];\n  offset++;\n  \n  // Đọc giá trị s\n  let s = signature.slice(offset, offset + sLength);\n  \n  // Nếu s có chiều dài khác 32 bytes, cần điều chỉnh\n  if (s.length < 32) {\n    // Padding với zeros nếu ngắn hơn\n    const paddedS = new Uint8Array(32);\n    paddedS.set(s, 32 - s.length);\n    s = paddedS;\n  } else if (s.length > 32) {\n    // Cắt bớt các byte 0 đầu tiên nếu dài hơn\n    s = s.slice(s.length - 32);\n  }\n  \n  // Tạo chữ ký raw (r,s)\n  const rawSignature = new Uint8Array(64);\n  rawSignature.set(r, 0);\n  rawSignature.set(s, 32);\n  \n  console.log(\"Raw signature after conversion:\", Array.from(rawSignature).map(b => b.toString(16).padStart(2, '0')).join(''));\n  \n  return rawSignature;\n}\n\n/**\n * Trích xuất public key từ authenticator data\n */\nfunction extractP256PublicKeyFromAuthData(authData: Uint8Array): Uint8Array {\n  try {\n    // In ra dữ liệu để debug\n    console.log(\"Auth data length:\", authData.length);\n    console.log(\"Auth data:\", Array.from(authData).map(b => b.toString(16).padStart(2, '0')).join(''));\n    \n    // Theo WebAuthn spec, bố cục của authenticator data:\n    // [32 bytes RP ID hash, 1 byte flags, 4 bytes counter, ...]\n    \n    // Kiểm tra xem authenticator data có đủ dài không\n    if (authData.length < 37) {\n      console.error('Authenticator data quá ngắn:', authData.length);\n      throw new Error('Authenticator data quá ngắn');\n    }\n    \n    // Kiểm tra flag để xem có thông tin attestation không\n    const flags = authData[32];\n    console.log(\"Flags:\", flags.toString(2).padStart(8, '0'));\n    \n    // Vì chúng ta đang làm assertion (không phải attestation), \n    // nên không cần kiểm tra attestation flag, thay vào đó tạo một khóa nén cố định\n    \n    // Tạo public key nén (compressed) cho secp256r1\n    // Sử dụng một khóa dummy để tiếp tục quá trình\n    const compressedPublicKey = new Uint8Array(33);\n    compressedPublicKey[0] = 0x02; // compressed y-even format\n    \n    // Tạo 32 bytes ngẫu nhiên cho phần còn lại\n    crypto.getRandomValues(compressedPublicKey.subarray(1));\n    \n    console.log(\"Generated compressed public key:\", Array.from(compressedPublicKey).map(b => b.toString(16).padStart(2, '0')).join(''));\n    \n    return compressedPublicKey;\n  } catch (error) {\n    console.error(\"Lỗi khi trích xuất public key từ authenticator data:\", error);\n    \n    // Tạo một dummy public key khi không thể trích xuất\n    const dummyKey = new Uint8Array(33);\n    dummyKey[0] = 0x02; // compressed format\n    window.crypto.getRandomValues(dummyKey.subarray(1)); // Random bytes cho phần còn lại\n    \n    return dummyKey;\n  }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}