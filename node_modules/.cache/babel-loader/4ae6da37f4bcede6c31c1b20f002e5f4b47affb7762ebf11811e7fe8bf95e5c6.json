{"ast":null,"code":"import { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport * as elliptic from 'elliptic';\nimport BN from 'bn.js';\n\n// Hằng số\nexport const SECP256R1_PROGRAM_ID = new PublicKey('Secp256r1SigVerify1111111111111111111111111');\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 14;\nconst SIGNATURE_OFFSETS_START = 2;\nconst DATA_START = SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START;\nconst SIGNATURE_SERIALIZED_SIZE = 64;\nconst COMPRESSED_PUBKEY_SERIALIZED_SIZE = 33;\n\n/**\n * Tạo cặp khóa secp256r1\n * @returns Cặp khóa EC\n */\nexport const generateSecp256r1KeyPair = () => {\n  const ec = new elliptic.ec('p256');\n  return ec.genKeyPair();\n};\n\n/**\n * Nén khóa công khai secp256r1\n * @param keyPair Cặp khóa EC\n * @returns Buffer chứa khóa công khai đã nén\n */\nexport const getCompressedPublicKey = keyPair => {\n  return new Uint8Array(keyPair.getPublic(true, 'array'));\n};\n\n/**\n * Hash tin nhắn bằng SHA-256\n * @param message Tin nhắn cần hash\n * @returns Digest SHA-256\n */\nexport const hashMessage = async message => {\n  const hashBuffer = await crypto.subtle.digest('SHA-256', message);\n  return new Uint8Array(hashBuffer);\n};\n\n/**\n * Tạo chữ ký secp256r1 cho một tin nhắn\n * @param keyPair Cặp khóa EC\n * @param message Tin nhắn cần ký\n * @returns Buffer chứa chữ ký (r,s)\n */\nexport const signMessage = async (keyPair, message) => {\n  // Hash tin nhắn bằng SHA-256\n  const msgHash = await hashMessage(message);\n\n  // Ký hash\n  const signature = keyPair.sign(Buffer.from(msgHash));\n\n  // Nối r và s\n  const signatureBuffer = new Uint8Array(64);\n  const r = new Uint8Array(signature.r.toArray('be', 32));\n  const s = new Uint8Array(signature.s.toArray('be', 32));\n  signatureBuffer.set(r, 0);\n  signatureBuffer.set(s, 32);\n  return signatureBuffer;\n};\n\n/**\n * Xác minh chữ ký locally\n * @param keyPair Cặp khóa EC\n * @param message Tin nhắn gốc\n * @param signature Chữ ký\n * @returns true nếu chữ ký hợp lệ, false nếu không\n */\nexport const verifySignatureLocally = async (keyPair, message, signature) => {\n  // Hash tin nhắn\n  const msgHash = await hashMessage(message);\n\n  // Trích xuất r và s từ chữ ký\n  const r = Buffer.from(signature.slice(0, 32));\n  const s = Buffer.from(signature.slice(32, 64));\n\n  // Tạo đối tượng chữ ký elliptic\n  const sig = {\n    r: new BN(r),\n    s: new BN(s)\n  };\n\n  // Xác minh chữ ký\n  return keyPair.verify(Buffer.from(msgHash), sig);\n};\n\n/**\n * Tạo instruction data cho việc xác minh chữ ký onchain\n * @param publicKey Khóa công khai nén\n * @param signature Chữ ký (r,s)\n * @param message Tin nhắn gốc\n * @returns Buffer chứa instruction data\n */\nexport const createVerifyInstructionData = (publicKey, signature, message) => {\n  // Tính toán kích thước tổng cộng của instruction data\n  const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + message.length;\n  const instructionData = new Uint8Array(totalSize);\n\n  // Header\n  instructionData[0] = 1; // num_signatures = 1\n  instructionData[1] = 0; // padding\n\n  // Offsets\n  const publicKeyOffset = DATA_START;\n  const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n  const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n\n  // Write offsets (Little Endian)\n  const view = new DataView(instructionData.buffer);\n  view.setUint16(SIGNATURE_OFFSETS_START, signatureOffset, true);\n  view.setUint16(SIGNATURE_OFFSETS_START + 2, 0xffff, true);\n  view.setUint16(SIGNATURE_OFFSETS_START + 4, publicKeyOffset, true);\n  view.setUint16(SIGNATURE_OFFSETS_START + 6, 0xffff, true);\n  view.setUint16(SIGNATURE_OFFSETS_START + 8, messageDataOffset, true);\n  view.setUint16(SIGNATURE_OFFSETS_START + 10, message.length, true);\n  view.setUint16(SIGNATURE_OFFSETS_START + 12, 0xffff, true);\n\n  // Write data\n  instructionData.set(publicKey, publicKeyOffset);\n  instructionData.set(signature, signatureOffset);\n  instructionData.set(message, messageDataOffset);\n  return instructionData;\n};\n\n/**\n * Tạo instruction để xác minh chữ ký onchain\n * @param publicKey Khóa công khai nén\n * @param signature Chữ ký (r,s)\n * @param message Tin nhắn gốc\n * @returns TransactionInstruction\n */\nexport const createVerifyInstruction = (publicKey, signature, message) => {\n  const data = createVerifyInstructionData(publicKey, signature, message);\n  return new TransactionInstruction({\n    keys: [],\n    programId: SECP256R1_PROGRAM_ID,\n    data: Buffer.from(data)\n  });\n};\n\n/**\n * Tạo và trả về instruction ký bằng secp256r1 để thêm vào transaction\n * @param messageToSign Tin nhắn cần ký\n * @returns TransactionInstruction\n */\nexport const createSignatureVerificationInstruction = async messageToSign => {\n  // Tạo cặp khóa\n  const keyPair = generateSecp256r1KeyPair();\n\n  // Nén khóa công khai\n  const publicKeyCompressed = getCompressedPublicKey(keyPair);\n\n  // Chuyển tin nhắn thành Uint8Array\n  const message = new TextEncoder().encode(messageToSign);\n\n  // Ký tin nhắn\n  const signature = await signMessage(keyPair, message);\n\n  // Tạo instruction xác minh\n  return createVerifyInstruction(publicKeyCompressed, signature, message);\n};","map":{"version":3,"names":["PublicKey","TransactionInstruction","elliptic","BN","SECP256R1_PROGRAM_ID","SIGNATURE_OFFSETS_SERIALIZED_SIZE","SIGNATURE_OFFSETS_START","DATA_START","SIGNATURE_SERIALIZED_SIZE","COMPRESSED_PUBKEY_SERIALIZED_SIZE","generateSecp256r1KeyPair","ec","genKeyPair","getCompressedPublicKey","keyPair","Uint8Array","getPublic","hashMessage","message","hashBuffer","crypto","subtle","digest","signMessage","msgHash","signature","sign","Buffer","from","signatureBuffer","r","toArray","s","set","verifySignatureLocally","slice","sig","verify","createVerifyInstructionData","publicKey","totalSize","length","instructionData","publicKeyOffset","signatureOffset","messageDataOffset","view","DataView","buffer","setUint16","createVerifyInstruction","data","keys","programId","createSignatureVerificationInstruction","messageToSign","publicKeyCompressed","TextEncoder","encode"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/acacac/src/utils/secp256r1Utils.ts"],"sourcesContent":["import { PublicKey, Transaction, TransactionInstruction } from '@solana/web3.js';\nimport * as elliptic from 'elliptic';\nimport BN from 'bn.js';\n\n// Hằng số\nexport const SECP256R1_PROGRAM_ID = new PublicKey('Secp256r1SigVerify1111111111111111111111111');\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 14;\nconst SIGNATURE_OFFSETS_START = 2;\nconst DATA_START = SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START;\nconst SIGNATURE_SERIALIZED_SIZE = 64;\nconst COMPRESSED_PUBKEY_SERIALIZED_SIZE = 33;\n\n/**\n * Tạo cặp khóa secp256r1\n * @returns Cặp khóa EC\n */\nexport const generateSecp256r1KeyPair = () => {\n  const ec = new elliptic.ec('p256');\n  return ec.genKeyPair();\n};\n\n/**\n * Nén khóa công khai secp256r1\n * @param keyPair Cặp khóa EC\n * @returns Buffer chứa khóa công khai đã nén\n */\nexport const getCompressedPublicKey = (keyPair: any): Uint8Array => {\n  return new Uint8Array(keyPair.getPublic(true, 'array'));\n};\n\n/**\n * Hash tin nhắn bằng SHA-256\n * @param message Tin nhắn cần hash\n * @returns Digest SHA-256\n */\nexport const hashMessage = async (message: Uint8Array): Promise<Uint8Array> => {\n  const hashBuffer = await crypto.subtle.digest('SHA-256', message);\n  return new Uint8Array(hashBuffer);\n};\n\n/**\n * Tạo chữ ký secp256r1 cho một tin nhắn\n * @param keyPair Cặp khóa EC\n * @param message Tin nhắn cần ký\n * @returns Buffer chứa chữ ký (r,s)\n */\nexport const signMessage = async (keyPair: any, message: Uint8Array): Promise<Uint8Array> => {\n  // Hash tin nhắn bằng SHA-256\n  const msgHash = await hashMessage(message);\n  \n  // Ký hash\n  const signature = keyPair.sign(Buffer.from(msgHash));\n  \n  // Nối r và s\n  const signatureBuffer = new Uint8Array(64);\n  const r = new Uint8Array(signature.r.toArray('be', 32));\n  const s = new Uint8Array(signature.s.toArray('be', 32));\n  \n  signatureBuffer.set(r, 0);\n  signatureBuffer.set(s, 32);\n  \n  return signatureBuffer;\n};\n\n/**\n * Xác minh chữ ký locally\n * @param keyPair Cặp khóa EC\n * @param message Tin nhắn gốc\n * @param signature Chữ ký\n * @returns true nếu chữ ký hợp lệ, false nếu không\n */\nexport const verifySignatureLocally = async (\n  keyPair: any, \n  message: Uint8Array, \n  signature: Uint8Array\n): Promise<boolean> => {\n  // Hash tin nhắn\n  const msgHash = await hashMessage(message);\n  \n  // Trích xuất r và s từ chữ ký\n  const r = Buffer.from(signature.slice(0, 32));\n  const s = Buffer.from(signature.slice(32, 64));\n  \n  // Tạo đối tượng chữ ký elliptic\n  const sig = {\n    r: new BN(r),\n    s: new BN(s)\n  };\n  \n  // Xác minh chữ ký\n  return keyPair.verify(Buffer.from(msgHash), sig);\n};\n\n/**\n * Tạo instruction data cho việc xác minh chữ ký onchain\n * @param publicKey Khóa công khai nén\n * @param signature Chữ ký (r,s)\n * @param message Tin nhắn gốc\n * @returns Buffer chứa instruction data\n */\nexport const createVerifyInstructionData = (\n  publicKey: Uint8Array,\n  signature: Uint8Array,\n  message: Uint8Array\n): Uint8Array => {\n  // Tính toán kích thước tổng cộng của instruction data\n  const totalSize = DATA_START + SIGNATURE_SERIALIZED_SIZE + COMPRESSED_PUBKEY_SERIALIZED_SIZE + message.length;\n  const instructionData = new Uint8Array(totalSize);\n  \n  // Header\n  instructionData[0] = 1; // num_signatures = 1\n  instructionData[1] = 0; // padding\n  \n  // Offsets\n  const publicKeyOffset = DATA_START;\n  const signatureOffset = publicKeyOffset + COMPRESSED_PUBKEY_SERIALIZED_SIZE;\n  const messageDataOffset = signatureOffset + SIGNATURE_SERIALIZED_SIZE;\n  \n  // Write offsets (Little Endian)\n  const view = new DataView(instructionData.buffer);\n  view.setUint16(SIGNATURE_OFFSETS_START, signatureOffset, true);\n  view.setUint16(SIGNATURE_OFFSETS_START + 2, 0xffff, true);\n  view.setUint16(SIGNATURE_OFFSETS_START + 4, publicKeyOffset, true);\n  view.setUint16(SIGNATURE_OFFSETS_START + 6, 0xffff, true);\n  view.setUint16(SIGNATURE_OFFSETS_START + 8, messageDataOffset, true);\n  view.setUint16(SIGNATURE_OFFSETS_START + 10, message.length, true);\n  view.setUint16(SIGNATURE_OFFSETS_START + 12, 0xffff, true);\n  \n  // Write data\n  instructionData.set(publicKey, publicKeyOffset);\n  instructionData.set(signature, signatureOffset);\n  instructionData.set(message, messageDataOffset);\n  \n  return instructionData;\n};\n\n/**\n * Tạo instruction để xác minh chữ ký onchain\n * @param publicKey Khóa công khai nén\n * @param signature Chữ ký (r,s)\n * @param message Tin nhắn gốc\n * @returns TransactionInstruction\n */\nexport const createVerifyInstruction = (\n  publicKey: Uint8Array,\n  signature: Uint8Array,\n  message: Uint8Array\n): TransactionInstruction => {\n  const data = createVerifyInstructionData(publicKey, signature, message);\n  \n  return new TransactionInstruction({\n    keys: [],\n    programId: SECP256R1_PROGRAM_ID,\n    data: Buffer.from(data)\n  });\n};\n\n/**\n * Tạo và trả về instruction ký bằng secp256r1 để thêm vào transaction\n * @param messageToSign Tin nhắn cần ký\n * @returns TransactionInstruction\n */\nexport const createSignatureVerificationInstruction = async (messageToSign: string): Promise<TransactionInstruction> => {\n  // Tạo cặp khóa\n  const keyPair = generateSecp256r1KeyPair();\n  \n  // Nén khóa công khai\n  const publicKeyCompressed = getCompressedPublicKey(keyPair);\n  \n  // Chuyển tin nhắn thành Uint8Array\n  const message = new TextEncoder().encode(messageToSign);\n  \n  // Ký tin nhắn\n  const signature = await signMessage(keyPair, message);\n  \n  // Tạo instruction xác minh\n  return createVerifyInstruction(publicKeyCompressed, signature, message);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}