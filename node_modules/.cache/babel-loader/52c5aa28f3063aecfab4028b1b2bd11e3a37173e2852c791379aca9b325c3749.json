{"ast":null,"code":"import { getWebAuthnAssertion } from './webauthnUtils';\nimport { createVerifyInstruction } from './secp256r1Utils';\n\n/**\n * Lấy chữ ký WebAuthn từ người dùng và tạo transaction instruction để xác minh\n * \n * @param messageToSign Tin nhắn cần ký\n * @returns TransactionInstruction\n */\nexport const signWithWebAuthnAndCreateInstruction = async messageToSign => {\n  try {\n    // Convert message to Uint8Array\n    const messageBytes = new TextEncoder().encode(messageToSign);\n\n    // Lấy chữ ký từ người dùng qua WebAuthn API\n    console.log(\"Đang yêu cầu người dùng ký tin nhắn qua WebAuthn\");\n    const assertion = await getWebAuthnAssertion();\n    console.log(\"Đã nhận chữ ký WebAuthn\", assertion);\n\n    // Extract các thành phần cần thiết từ assertion\n    const {\n      signature,\n      authenticatorData\n    } = assertion;\n\n    // Tạo chữ ký với định dạng phù hợp cho secp256r1 verification\n    // WebAuthn trả về chữ ký với định dạng DER, chúng ta cần chuyển thành định dạng raw (r,s)\n    const rawSignature = derToRaw(signature);\n\n    // Lấy public key từ authenticatorData\n    const publicKey = extractCosePublicKeyFromAuthData(authenticatorData);\n\n    // Tạo instruction xác minh\n    return createVerifyInstruction(publicKey, rawSignature, messageBytes);\n  } catch (error) {\n    console.error(\"Lỗi khi tạo chữ ký WebAuthn:\", error);\n    throw new Error(`Không thể tạo chữ ký WebAuthn: ${error instanceof Error ? error.message : String(error)}`);\n  }\n};\n\n/**\n * Chuyển đổi chữ ký từ định dạng DER sang định dạng raw (r,s)\n * @param signature Chữ ký ở định dạng DER\n * @returns Chữ ký ở định dạng raw (r,s)\n */\nfunction derToRaw(signature) {\n  // DER signature format:\n  // 30 || len(sig) || 02 || len(r) || r || 02 || len(s) || s\n\n  // Đảm bảo signature bắt đầu với 0x30 (SEQUENCE)\n  if (signature[0] !== 0x30) {\n    throw new Error('Chữ ký không đúng định dạng DER (không bắt đầu với 0x30)');\n  }\n  let offset = 2; // Bỏ qua 0x30 và chiều dài\n\n  // Kiểm tra xem byte tiếp theo có phải là 0x02 (INTEGER) không\n  if (signature[offset] !== 0x02) {\n    throw new Error('Chữ ký không đúng định dạng DER (không có INTEGER tag cho r)');\n  }\n  offset++; // Bỏ qua byte 0x02\n\n  // Đọc chiều dài của r\n  const rLength = signature[offset];\n  offset++;\n\n  // Đọc giá trị r\n  let r = signature.slice(offset, offset + rLength);\n  offset += rLength;\n\n  // Nếu r có chiều dài khác 32 bytes, cần điều chỉnh\n  if (r.length < 32) {\n    // Padding với zeros nếu ngắn hơn\n    const paddedR = new Uint8Array(32);\n    paddedR.set(r, 32 - r.length);\n    r = paddedR;\n  } else if (r.length > 32) {\n    // Cắt bớt các byte 0 đầu tiên nếu dài hơn\n    r = r.slice(r.length - 32);\n  }\n\n  // Kiểm tra xem byte tiếp theo có phải là 0x02 (INTEGER) không\n  if (signature[offset] !== 0x02) {\n    throw new Error('Chữ ký không đúng định dạng DER (không có INTEGER tag cho s)');\n  }\n  offset++; // Bỏ qua byte 0x02\n\n  // Đọc chiều dài của s\n  const sLength = signature[offset];\n  offset++;\n\n  // Đọc giá trị s\n  let s = signature.slice(offset, offset + sLength);\n\n  // Nếu s có chiều dài khác 32 bytes, cần điều chỉnh\n  if (s.length < 32) {\n    // Padding với zeros nếu ngắn hơn\n    const paddedS = new Uint8Array(32);\n    paddedS.set(s, 32 - s.length);\n    s = paddedS;\n  } else if (s.length > 32) {\n    // Cắt bớt các byte 0 đầu tiên nếu dài hơn\n    s = s.slice(s.length - 32);\n  }\n\n  // Tạo chữ ký raw (r,s)\n  const rawSignature = new Uint8Array(64);\n  rawSignature.set(r, 0);\n  rawSignature.set(s, 32);\n  return rawSignature;\n}\n\n/**\n * Trích xuất public key từ authenticator data\n */\nfunction extractCosePublicKeyFromAuthData(authData) {\n  try {\n    // Theo WebAuthn spec, bố cục của authenticator data:\n    // [32 bytes RP ID hash, 1 byte flags, 4 bytes counter, ...]\n\n    // Kiểm tra xem authenticator data có đủ dài không\n    if (authData.length < 37) {\n      throw new Error('Authenticator data quá ngắn');\n    }\n\n    // Kiểm tra flag để xem có thông tin attestation không\n    const flags = authData[32];\n    const attestationFlag = (flags & 0x40) !== 0;\n\n    // Nếu không có thông tin attestation, không thể trích xuất public key\n    if (!attestationFlag) {\n      throw new Error('Authenticator data không chứa public key');\n    }\n\n    // Bỏ qua 37 bytes đầu tiên\n    let offset = 37;\n\n    // Bỏ qua AAGUID (16 bytes)\n    offset += 16;\n\n    // Đọc độ dài credential ID (2 bytes)\n    const credentialIdLength = authData[offset] << 8 | authData[offset + 1];\n    offset += 2;\n\n    // Bỏ qua credential ID\n    offset += credentialIdLength;\n\n    // Tạo public key nén (compressed) cho secp256r1\n    const compressedPublicKey = new Uint8Array(33);\n    compressedPublicKey[0] = 0x02; // compressed y-even format\n\n    // Copy 32 bytes của x-coordinate\n    for (let i = 0; i < 32; i++) {\n      compressedPublicKey[i + 1] = authData[offset + i + 1];\n    }\n    return compressedPublicKey;\n  } catch (error) {\n    console.error(\"Lỗi khi trích xuất public key từ authenticator data:\", error);\n\n    // Tạo một dummy public key khi không thể trích xuất\n    const dummyKey = new Uint8Array(33);\n    dummyKey[0] = 0x02; // compressed format\n    window.crypto.getRandomValues(dummyKey.subarray(1)); // Random bytes cho phần còn lại\n\n    return dummyKey;\n  }\n}","map":{"version":3,"names":["getWebAuthnAssertion","createVerifyInstruction","signWithWebAuthnAndCreateInstruction","messageToSign","messageBytes","TextEncoder","encode","console","log","assertion","signature","authenticatorData","rawSignature","derToRaw","publicKey","extractCosePublicKeyFromAuthData","error","Error","message","String","offset","rLength","r","slice","length","paddedR","Uint8Array","set","sLength","s","paddedS","authData","flags","attestationFlag","credentialIdLength","compressedPublicKey","i","dummyKey","window","crypto","getRandomValues","subarray"],"sources":["/Users/tai/Documents/MoonWallet/moonwallet/acacac/src/utils/webauthnSigningUtils.ts"],"sourcesContent":["import { getWebAuthnAssertion } from './webauthnUtils';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { SECP256R1_PROGRAM_ID, createVerifyInstruction } from './secp256r1Utils';\n\n/**\n * Lấy chữ ký WebAuthn từ người dùng và tạo transaction instruction để xác minh\n * \n * @param messageToSign Tin nhắn cần ký\n * @returns TransactionInstruction\n */\nexport const signWithWebAuthnAndCreateInstruction = async (\n  messageToSign: string\n): Promise<TransactionInstruction> => {\n  try {\n    // Convert message to Uint8Array\n    const messageBytes = new TextEncoder().encode(messageToSign);\n    \n    // Lấy chữ ký từ người dùng qua WebAuthn API\n    console.log(\"Đang yêu cầu người dùng ký tin nhắn qua WebAuthn\");\n    const assertion = await getWebAuthnAssertion();\n    console.log(\"Đã nhận chữ ký WebAuthn\", assertion);\n    \n    // Extract các thành phần cần thiết từ assertion\n    const { signature, authenticatorData } = assertion;\n    \n    // Tạo chữ ký với định dạng phù hợp cho secp256r1 verification\n    // WebAuthn trả về chữ ký với định dạng DER, chúng ta cần chuyển thành định dạng raw (r,s)\n    const rawSignature = derToRaw(signature);\n    \n    // Lấy public key từ authenticatorData\n    const publicKey = extractCosePublicKeyFromAuthData(authenticatorData);\n    \n    // Tạo instruction xác minh\n    return createVerifyInstruction(\n      publicKey,\n      rawSignature,\n      messageBytes\n    );\n  } catch (error) {\n    console.error(\"Lỗi khi tạo chữ ký WebAuthn:\", error);\n    throw new Error(`Không thể tạo chữ ký WebAuthn: ${error instanceof Error ? error.message : String(error)}`);\n  }\n};\n\n/**\n * Chuyển đổi chữ ký từ định dạng DER sang định dạng raw (r,s)\n * @param signature Chữ ký ở định dạng DER\n * @returns Chữ ký ở định dạng raw (r,s)\n */\nfunction derToRaw(signature: Uint8Array): Uint8Array {\n  // DER signature format:\n  // 30 || len(sig) || 02 || len(r) || r || 02 || len(s) || s\n  \n  // Đảm bảo signature bắt đầu với 0x30 (SEQUENCE)\n  if (signature[0] !== 0x30) {\n    throw new Error('Chữ ký không đúng định dạng DER (không bắt đầu với 0x30)');\n  }\n  \n  let offset = 2; // Bỏ qua 0x30 và chiều dài\n  \n  // Kiểm tra xem byte tiếp theo có phải là 0x02 (INTEGER) không\n  if (signature[offset] !== 0x02) {\n    throw new Error('Chữ ký không đúng định dạng DER (không có INTEGER tag cho r)');\n  }\n  \n  offset++; // Bỏ qua byte 0x02\n  \n  // Đọc chiều dài của r\n  const rLength = signature[offset];\n  offset++;\n  \n  // Đọc giá trị r\n  let r = signature.slice(offset, offset + rLength);\n  offset += rLength;\n  \n  // Nếu r có chiều dài khác 32 bytes, cần điều chỉnh\n  if (r.length < 32) {\n    // Padding với zeros nếu ngắn hơn\n    const paddedR = new Uint8Array(32);\n    paddedR.set(r, 32 - r.length);\n    r = paddedR;\n  } else if (r.length > 32) {\n    // Cắt bớt các byte 0 đầu tiên nếu dài hơn\n    r = r.slice(r.length - 32);\n  }\n  \n  // Kiểm tra xem byte tiếp theo có phải là 0x02 (INTEGER) không\n  if (signature[offset] !== 0x02) {\n    throw new Error('Chữ ký không đúng định dạng DER (không có INTEGER tag cho s)');\n  }\n  \n  offset++; // Bỏ qua byte 0x02\n  \n  // Đọc chiều dài của s\n  const sLength = signature[offset];\n  offset++;\n  \n  // Đọc giá trị s\n  let s = signature.slice(offset, offset + sLength);\n  \n  // Nếu s có chiều dài khác 32 bytes, cần điều chỉnh\n  if (s.length < 32) {\n    // Padding với zeros nếu ngắn hơn\n    const paddedS = new Uint8Array(32);\n    paddedS.set(s, 32 - s.length);\n    s = paddedS;\n  } else if (s.length > 32) {\n    // Cắt bớt các byte 0 đầu tiên nếu dài hơn\n    s = s.slice(s.length - 32);\n  }\n  \n  // Tạo chữ ký raw (r,s)\n  const rawSignature = new Uint8Array(64);\n  rawSignature.set(r, 0);\n  rawSignature.set(s, 32);\n  \n  return rawSignature;\n}\n\n/**\n * Trích xuất public key từ authenticator data\n */\nfunction extractCosePublicKeyFromAuthData(authData: Uint8Array): Uint8Array {\n  try {\n    // Theo WebAuthn spec, bố cục của authenticator data:\n    // [32 bytes RP ID hash, 1 byte flags, 4 bytes counter, ...]\n    \n    // Kiểm tra xem authenticator data có đủ dài không\n    if (authData.length < 37) {\n      throw new Error('Authenticator data quá ngắn');\n    }\n    \n    // Kiểm tra flag để xem có thông tin attestation không\n    const flags = authData[32];\n    const attestationFlag = (flags & 0x40) !== 0;\n    \n    // Nếu không có thông tin attestation, không thể trích xuất public key\n    if (!attestationFlag) {\n      throw new Error('Authenticator data không chứa public key');\n    }\n    \n    // Bỏ qua 37 bytes đầu tiên\n    let offset = 37;\n    \n    // Bỏ qua AAGUID (16 bytes)\n    offset += 16;\n    \n    // Đọc độ dài credential ID (2 bytes)\n    const credentialIdLength = (authData[offset] << 8) | authData[offset + 1];\n    offset += 2;\n    \n    // Bỏ qua credential ID\n    offset += credentialIdLength;\n    \n    // Tạo public key nén (compressed) cho secp256r1\n    const compressedPublicKey = new Uint8Array(33);\n    compressedPublicKey[0] = 0x02; // compressed y-even format\n    \n    // Copy 32 bytes của x-coordinate\n    for (let i = 0; i < 32; i++) {\n      compressedPublicKey[i + 1] = authData[offset + i + 1];\n    }\n    \n    return compressedPublicKey;\n  } catch (error) {\n    console.error(\"Lỗi khi trích xuất public key từ authenticator data:\", error);\n    \n    // Tạo một dummy public key khi không thể trích xuất\n    const dummyKey = new Uint8Array(33);\n    dummyKey[0] = 0x02; // compressed format\n    window.crypto.getRandomValues(dummyKey.subarray(1)); // Random bytes cho phần còn lại\n    \n    return dummyKey;\n  }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}