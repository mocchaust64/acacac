{"ast":null,"code":"import { Transaction, PublicKey } from '@solana/web3.js';\nimport QRCodeModal from '@walletconnect/qrcode-modal';\nimport WalletConnectClient from '@walletconnect/sign-client';\nimport { getSdkError, parseAccountId } from '@walletconnect/utils';\nimport base58 from 'bs58';\nimport { ClientNotInitializedError, QRCodeModalError } from './errors.js';\nexport var WalletConnectChainID;\n(function (WalletConnectChainID) {\n  WalletConnectChainID[\"Mainnet\"] = \"solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ\";\n  WalletConnectChainID[\"Devnet\"] = \"solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K\";\n})(WalletConnectChainID || (WalletConnectChainID = {}));\nexport var WalletConnectRPCMethods;\n(function (WalletConnectRPCMethods) {\n  WalletConnectRPCMethods[\"signTransaction\"] = \"solana_signTransaction\";\n  WalletConnectRPCMethods[\"signMessage\"] = \"solana_signMessage\";\n})(WalletConnectRPCMethods || (WalletConnectRPCMethods = {}));\nconst getConnectParams = chainId => ({\n  requiredNamespaces: {\n    solana: {\n      chains: [chainId],\n      methods: [WalletConnectRPCMethods.signTransaction, WalletConnectRPCMethods.signMessage],\n      events: []\n    }\n  }\n});\nconst isVersionedTransaction = transaction => 'version' in transaction;\nexport class WalletConnectWallet {\n  constructor(config) {\n    this._options = config.options;\n    this._network = config.network;\n  }\n  async connect() {\n    const client = this._client ?? (await WalletConnectClient.init(this._options));\n    const sessions = client.find(getConnectParams(this._network)).filter(s => s.acknowledged);\n    if (sessions.length) {\n      // select last matching session\n      this._session = sessions[sessions.length - 1];\n      // We assign this variable only after we're sure we've received approval\n      this._client = client;\n      return {\n        publicKey: this.publicKey\n      };\n    } else {\n      const {\n        uri,\n        approval\n      } = await client.connect(getConnectParams(this._network));\n      return new Promise((resolve, reject) => {\n        if (uri) {\n          QRCodeModal.open(uri, () => {\n            reject(new QRCodeModalError());\n          });\n        }\n        approval().then(session => {\n          this._session = session;\n          // We assign this variable only after we're sure we've received approval\n          this._client = client;\n          resolve({\n            publicKey: this.publicKey\n          });\n        }).catch(reject).finally(() => {\n          QRCodeModal.close();\n        });\n      });\n    }\n  }\n  async disconnect() {\n    if (this._client && this._session) {\n      await this._client.disconnect({\n        topic: this._session.topic,\n        reason: getSdkError('USER_DISCONNECTED')\n      });\n      this._session = undefined;\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n  get client() {\n    if (this._client) {\n      // TODO: using client.off throws an error\n      return Object.assign({}, this._client, {\n        off: this._client.removeListener\n      });\n      // return this._client;\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n  get publicKey() {\n    if (this._client && this._session) {\n      const {\n        address\n      } = parseAccountId(this._session.namespaces.solana.accounts[0]);\n      return new PublicKey(address);\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n  async signTransaction(transaction) {\n    if (this._client && this._session) {\n      let rawTransaction;\n      let legacyTransaction;\n      if (isVersionedTransaction(transaction)) {\n        // V0 transactions are serialized and passed in the `transaction` property\n        rawTransaction = Buffer.from(transaction.serialize()).toString('base64');\n        if (transaction.version === 'legacy') {\n          // For backwards-compatible, legacy transactions are spread in the params\n          legacyTransaction = Transaction.from(transaction.serialize());\n        }\n      } else {\n        rawTransaction = transaction.serialize({\n          requireAllSignatures: false,\n          verifySignatures: false\n        }).toString('base64');\n        legacyTransaction = transaction;\n      }\n      const {\n        signature\n      } = await this._client.request({\n        chainId: this._network,\n        topic: this._session.topic,\n        request: {\n          method: WalletConnectRPCMethods.signTransaction,\n          params: {\n            // Passing ...legacyTransaction is deprecated.\n            // All new clients should rely on the `transaction` parameter.\n            // The future versions will stop passing ...legacyTransaction.\n            ...legacyTransaction,\n            // New base64-encoded serialized transaction request parameter\n            transaction: rawTransaction\n          }\n        }\n      });\n      transaction.addSignature(this.publicKey, Buffer.from(base58.decode(signature)));\n      return transaction;\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n  async signMessage(message) {\n    if (this._client && this._session) {\n      const {\n        signature\n      } = await this._client.request({\n        // The network does not change the output of message signing, but this is a required parameter for SignClient\n        chainId: this._network,\n        topic: this._session.topic,\n        request: {\n          method: WalletConnectRPCMethods.signMessage,\n          params: {\n            pubkey: this.publicKey.toString(),\n            message: base58.encode(message)\n          }\n        }\n      });\n      return base58.decode(signature);\n    } else {\n      throw new ClientNotInitializedError();\n    }\n  }\n}\n//# sourceMappingURL=adapter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}